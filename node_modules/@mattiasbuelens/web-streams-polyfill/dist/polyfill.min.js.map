{"version":3,"file":"polyfill.min.js","sources":["../src/stub/number-isinteger.js","../src/stub/symbol.js","../src/utils.js","../src/stub/number-isnan.js","../spec/reference-implementation/lib/helpers.js","../src/stub/assert.js","../spec/reference-implementation/lib/utils.js","../spec/reference-implementation/lib/queue-with-sizes.js","../spec/reference-implementation/lib/writable-stream.js","../spec/reference-implementation/lib/readable-stream.js","../spec/reference-implementation/lib/byte-length-queuing-strategy.js","../spec/reference-implementation/lib/count-queuing-strategy.js","../spec/reference-implementation/lib/transform-stream.js","../src/polyfill.js"],"sourcesContent":["// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger#Polyfill\nconst NumberIsInteger = Number.isInteger || function (value) {\n  return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\nexport default NumberIsInteger;\n","const SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n  Symbol :\n  description => `Symbol(${description})`;\n\nexport default SymbolPolyfill;\n","export function noop() {\n  // do nothing\n}\n\nfunction getGlobals() {\n  /* global self, window, global */\n  if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  }\n  return undefined;\n}\n\nexport const globals = getGlobals();\n","// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN = Number.isNaN || function (x) {\n  // eslint-disable-next-line no-self-compare\n  return x !== x;\n};\n\nexport default NumberIsNaN;\n","'use strict';\nconst assert = require('better-assert');\n\nconst isFakeDetached = Symbol('is \"detached\" for our purposes');\n\nfunction IsPropertyKey(argument) {\n  return typeof argument === 'string' || typeof argument === 'symbol';\n}\n\nexports.typeIsObject = x => (typeof x === 'object' && x !== null) || typeof x === 'function';\n\nexports.createDataProperty = (o, p, v) => {\n  assert(exports.typeIsObject(o));\n  Object.defineProperty(o, p, { value: v, writable: true, enumerable: true, configurable: true });\n};\n\nexports.createArrayFromList = elements => {\n  // We use arrays to represent lists, so this is basically a no-op.\n  // Do a slice though just in case we happen to depend on the unique-ness.\n  return elements.slice();\n};\n\nexports.ArrayBufferCopy = (dest, destOffset, src, srcOffset, n) => {\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n};\n\nexports.IsFiniteNonNegativeNumber = v => {\n  if (exports.IsNonNegativeNumber(v) === false) {\n    return false;\n  }\n\n  if (v === Infinity) {\n    return false;\n  }\n\n  return true;\n};\n\nexports.IsNonNegativeNumber = v => {\n  if (typeof v !== 'number') {\n    return false;\n  }\n\n  if (Number.isNaN(v)) {\n    return false;\n  }\n\n  if (v < 0) {\n    return false;\n  }\n\n  return true;\n};\n\nfunction Call(F, V, args) {\n  if (typeof F !== 'function') {\n    throw new TypeError('Argument is not a function');\n  }\n\n  return Function.prototype.apply.call(F, V, args);\n}\n\nexports.Call = Call;\n\nexports.CreateAlgorithmFromUnderlyingMethod = (underlyingObject, methodName, algoArgCount, extraArgs) => {\n  assert(underlyingObject !== undefined);\n  assert(IsPropertyKey(methodName));\n  assert(algoArgCount === 0 || algoArgCount === 1);\n  assert(Array.isArray(extraArgs));\n  const method = underlyingObject[methodName];\n  if (method !== undefined) {\n    if (typeof method !== 'function') {\n      throw new TypeError(`${method} is not a method`);\n    }\n    switch (algoArgCount) {\n      case 0: {\n        return () => {\n          return PromiseCall(method, underlyingObject, extraArgs);\n        };\n      }\n\n      case 1: {\n        return arg => {\n          const fullArgs = [arg].concat(extraArgs);\n          return PromiseCall(method, underlyingObject, fullArgs);\n        };\n      }\n    }\n  }\n  return () => Promise.resolve();\n};\n\nexports.InvokeOrNoop = (O, P, args) => {\n  assert(O !== undefined);\n  assert(IsPropertyKey(P));\n  assert(Array.isArray(args));\n\n  const method = O[P];\n  if (method === undefined) {\n    return undefined;\n  }\n\n  return Call(method, O, args);\n};\n\nfunction PromiseCall(F, V, args) {\n  assert(typeof F === 'function');\n  assert(V !== undefined);\n  assert(Array.isArray(args));\n  try {\n    return Promise.resolve(Call(F, V, args));\n  } catch (value) {\n    return Promise.reject(value);\n  }\n}\n\nexports.PromiseCall = PromiseCall;\n\n// Not implemented correctly\nexports.TransferArrayBuffer = O => {\n  assert(!exports.IsDetachedBuffer(O));\n  const transferredIshVersion = O.slice();\n\n  // This is specifically to fool tests that test \"is transferred\" by taking a non-zero-length\n  // ArrayBuffer and checking if its byteLength starts returning 0.\n  Object.defineProperty(O, 'byteLength', {\n    get() {\n      return 0;\n    }\n  });\n  O[isFakeDetached] = true;\n\n  return transferredIshVersion;\n};\n\n// Not implemented correctly\nexports.IsDetachedBuffer = O => {\n  return isFakeDetached in O;\n};\n\nexports.ValidateAndNormalizeHighWaterMark = highWaterMark => {\n  highWaterMark = Number(highWaterMark);\n  if (Number.isNaN(highWaterMark) || highWaterMark < 0) {\n    throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');\n  }\n\n  return highWaterMark;\n};\n\nexports.MakeSizeAlgorithmFromSizeFunction = size => {\n  if (size === undefined) {\n    return () => 1;\n  }\n  if (typeof size !== 'function') {\n    throw new TypeError('size property of a queuing strategy must be a function');\n  }\n  return chunk => size(chunk);\n};\n","import { noop } from '../utils';\n\nexport default function assert() {\n  // do nothing\n}\n\nassert.AssertionError = noop;\n","'use strict';\nconst assert = require('assert');\n\nexports.rethrowAssertionErrorRejection = e => {\n  // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\n  // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\n  // expect any errors, but assertion errors are always problematic.\n  if (e && e instanceof assert.AssertionError) {\n    setTimeout(() => {\n      throw e;\n    }, 0);\n  }\n};\n","'use strict';\nconst assert = require('better-assert');\nconst { IsFiniteNonNegativeNumber } = require('./helpers.js');\n\nexports.DequeueValue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.shift();\n  container._queueTotalSize -= pair.size;\n  if (container._queueTotalSize < 0) {\n    container._queueTotalSize = 0;\n  }\n\n  return pair.value;\n};\n\nexports.EnqueueValueWithSize = (container, value, size) => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  size = Number(size);\n  if (!IsFiniteNonNegativeNumber(size)) {\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n\n  container._queue.push({ value, size });\n  container._queueTotalSize += size;\n};\n\nexports.PeekQueueValue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue[0];\n  return pair.value;\n};\n\nexports.ResetQueue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  container._queue = [];\n  container._queueTotalSize = 0;\n};\n","'use strict';\nconst assert = require('better-assert');\n\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\n// and do not appear in the standard text.\nconst verbose = require('debug')('streams:writable-stream:verbose');\n\nconst { CreateAlgorithmFromUnderlyingMethod, InvokeOrNoop, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction, typeIsObject } = require('./helpers.js');\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\nconst { DequeueValue, EnqueueValueWithSize, PeekQueueValue, ResetQueue } = require('./queue-with-sizes.js');\n\nconst AbortSteps = Symbol('[[AbortSteps]]');\nconst ErrorSteps = Symbol('[[ErrorSteps]]');\n\nclass WritableStream {\n  constructor(underlyingSink = {}, strategy = {}) {\n    InitializeWritableStream(this);\n\n    const size = strategy.size;\n    let highWaterMark = strategy.highWaterMark;\n\n    const type = underlyingSink.type;\n\n    if (type !== undefined) {\n      throw new RangeError('Invalid type is specified');\n    }\n\n    const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n    if (highWaterMark === undefined) {\n      highWaterMark = 1;\n    }\n    highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n  }\n\n  get locked() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsWritableStreamLocked(this);\n  }\n\n  abort(reason) {\n    if (IsWritableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('abort'));\n    }\n\n    if (IsWritableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot abort a stream that already has a writer'));\n    }\n\n    return WritableStreamAbort(this, reason);\n  }\n\n  getWriter() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException('getWriter');\n    }\n\n    return AcquireWritableStreamDefaultWriter(this);\n  }\n}\n\nmodule.exports = {\n  AcquireWritableStreamDefaultWriter,\n  CreateWritableStream,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamDefaultControllerErrorIfNeeded,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite,\n  WritableStreamCloseQueuedOrInFlight\n};\n\n// Abstract operations for the WritableStream.\n\nfunction AcquireWritableStreamDefaultWriter(stream) {\n  return new WritableStreamDefaultWriter(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1,\n                              sizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n\n  const stream = Object.create(WritableStream.prototype);\n  InitializeWritableStream(stream);\n\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n}\n\nfunction InitializeWritableStream(stream) {\n  stream._state = 'writable';\n\n  // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n  // 'erroring' or 'errored'. May be set to an undefined value.\n  stream._storedError = undefined;\n\n  stream._writer = undefined;\n\n  // Initialize to undefined first because the constructor of the controller checks this\n  // variable to validate the caller.\n  stream._writableStreamController = undefined;\n\n  // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  // producer without waiting for the queued writes to finish.\n  stream._writeRequests = [];\n\n  // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  stream._inFlightWriteRequest = undefined;\n\n  // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  // has been detached.\n  stream._closeRequest = undefined;\n\n  // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n  stream._inFlightCloseRequest = undefined;\n\n  // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n  stream._pendingAbortRequest = undefined;\n\n  // The backpressure signal set by the controller.\n  stream._backpressure = false;\n}\n\nfunction IsWritableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsWritableStreamLocked(stream) {\n  assert(IsWritableStream(stream) === true);\n\n  if (stream._writer === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamAbort(stream, reason) {\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return Promise.resolve(undefined);\n  }\n  if (stream._pendingAbortRequest !== undefined) {\n    return stream._pendingAbortRequest._promise;\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  let wasAlreadyErroring = false;\n  if (state === 'erroring') {\n    wasAlreadyErroring = true;\n    // reason will not be used, so don't keep a reference to it.\n    reason = undefined;\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    stream._pendingAbortRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _reason: reason,\n      _wasAlreadyErroring: wasAlreadyErroring\n    };\n  });\n  stream._pendingAbortRequest._promise = promise;\n\n  if (wasAlreadyErroring === false) {\n    WritableStreamStartErroring(stream, reason);\n  }\n\n  return promise;\n}\n\n// WritableStream API exposed for controllers.\n\nfunction WritableStreamAddWriteRequest(stream) {\n  assert(IsWritableStreamLocked(stream) === true);\n  assert(stream._state === 'writable');\n\n  const promise = new Promise((resolve, reject) => {\n    const writeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._writeRequests.push(writeRequest);\n  });\n\n  return promise;\n}\n\nfunction WritableStreamDealWithRejection(stream, error) {\n  verbose('WritableStreamDealWithRejection(stream, %o)', error);\n  const state = stream._state;\n\n  if (state === 'writable') {\n    WritableStreamStartErroring(stream, error);\n    return;\n  }\n\n  assert(state === 'erroring');\n  WritableStreamFinishErroring(stream);\n}\n\nfunction WritableStreamStartErroring(stream, reason) {\n  verbose('WritableStreamStartErroring(stream, %o)', reason);\n  assert(stream._storedError === undefined);\n  assert(stream._state === 'writable');\n\n  const controller = stream._writableStreamController;\n  assert(controller !== undefined);\n\n  stream._state = 'erroring';\n  stream._storedError = reason;\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n\n  if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {\n    WritableStreamFinishErroring(stream);\n  }\n}\n\nfunction WritableStreamFinishErroring(stream) {\n  verbose('WritableStreamFinishErroring()');\n  assert(stream._state === 'erroring');\n  assert(WritableStreamHasOperationMarkedInFlight(stream) === false);\n  stream._state = 'errored';\n  stream._writableStreamController[ErrorSteps]();\n\n  const storedError = stream._storedError;\n  for (const writeRequest of stream._writeRequests) {\n    writeRequest._reject(storedError);\n  }\n  stream._writeRequests = [];\n\n  if (stream._pendingAbortRequest === undefined) {\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const abortRequest = stream._pendingAbortRequest;\n  stream._pendingAbortRequest = undefined;\n\n  if (abortRequest._wasAlreadyErroring === true) {\n    abortRequest._reject(storedError);\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n  promise.then(\n      () => {\n        abortRequest._resolve();\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      },\n      reason => {\n        abortRequest._reject(reason);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      });\n}\n\nfunction WritableStreamFinishInFlightWrite(stream) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest._resolve(undefined);\n  stream._inFlightWriteRequest = undefined;\n}\n\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest._reject(error);\n  stream._inFlightWriteRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  WritableStreamDealWithRejection(stream, error);\n}\n\nfunction WritableStreamFinishInFlightClose(stream) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest._resolve(undefined);\n  stream._inFlightCloseRequest = undefined;\n\n  const state = stream._state;\n\n  assert(state === 'writable' || state === 'erroring');\n\n  if (state === 'erroring') {\n    // The error was too late to do anything, so it is ignored.\n    stream._storedError = undefined;\n    if (stream._pendingAbortRequest !== undefined) {\n      stream._pendingAbortRequest._resolve();\n      stream._pendingAbortRequest = undefined;\n    }\n  }\n\n  stream._state = 'closed';\n\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseResolve(writer);\n  }\n\n  assert(stream._pendingAbortRequest === undefined);\n  assert(stream._storedError === undefined);\n}\n\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest._reject(error);\n  stream._inFlightCloseRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  // Never execute sink abort() after sink close().\n  if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._reject(error);\n    stream._pendingAbortRequest = undefined;\n  }\n  WritableStreamDealWithRejection(stream, error);\n}\n\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    verbose('WritableStreamHasOperationMarkedInFlight() is false');\n    return false;\n  }\n\n  verbose('WritableStreamHasOperationMarkedInFlight() is true');\n  return true;\n}\n\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\n  assert(stream._inFlightCloseRequest === undefined);\n  assert(stream._closeRequest !== undefined);\n  stream._inFlightCloseRequest = stream._closeRequest;\n  stream._closeRequest = undefined;\n}\n\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\n  assert(stream._inFlightWriteRequest === undefined);\n  assert(stream._writeRequests.length !== 0);\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\n\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n  verbose('WritableStreamRejectCloseAndClosedPromiseIfNeeded()');\n  assert(stream._state === 'errored');\n  if (stream._closeRequest !== undefined) {\n    assert(stream._inFlightCloseRequest === undefined);\n\n    stream._closeRequest._reject(stream._storedError);\n    stream._closeRequest = undefined;\n  }\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\n    writer._closedPromise.catch(() => {});\n  }\n}\n\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\n  assert(stream._state === 'writable');\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\n\n  const writer = stream._writer;\n  if (writer !== undefined && backpressure !== stream._backpressure) {\n    if (backpressure === true) {\n      defaultWriterReadyPromiseReset(writer);\n    } else {\n      assert(backpressure === false);\n\n      defaultWriterReadyPromiseResolve(writer);\n    }\n  }\n\n  stream._backpressure = backpressure;\n}\n\nclass WritableStreamDefaultWriter {\n  constructor(stream) {\n    if (IsWritableStream(stream) === false) {\n      throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');\n    }\n    if (IsWritableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n    }\n\n    this._ownerWritableStream = stream;\n    stream._writer = this;\n\n    const state = stream._state;\n\n    if (state === 'writable') {\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {\n        defaultWriterReadyPromiseInitialize(this);\n      } else {\n        defaultWriterReadyPromiseInitializeAsResolved(this);\n      }\n\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'erroring') {\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n      this._readyPromise.catch(() => {});\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'closed') {\n      defaultWriterReadyPromiseInitializeAsResolved(this);\n      defaultWriterClosedPromiseInitializeAsResolved(this);\n    } else {\n      assert(state === 'errored');\n\n      const storedError = stream._storedError;\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n      this._readyPromise.catch(() => {});\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n      this._closedPromise.catch(() => {});\n    }\n  }\n\n  get closed() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  get desiredSize() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException('desiredSize');\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      throw defaultWriterLockException('desiredSize');\n    }\n\n    return WritableStreamDefaultWriterGetDesiredSize(this);\n  }\n\n  get ready() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('ready'));\n    }\n\n    return this._readyPromise;\n  }\n\n  abort(reason) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('abort'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return Promise.reject(defaultWriterLockException('abort'));\n    }\n\n    return WritableStreamDefaultWriterAbort(this, reason);\n  }\n\n  close() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('close'));\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return Promise.reject(defaultWriterLockException('close'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true) {\n      return Promise.reject(new TypeError('cannot close an already-closing stream'));\n    }\n\n    return WritableStreamDefaultWriterClose(this);\n  }\n\n  releaseLock() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException('releaseLock');\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return;\n    }\n\n    assert(stream._writer !== undefined);\n\n    WritableStreamDefaultWriterRelease(this);\n  }\n\n  write(chunk) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('write'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return Promise.reject(defaultWriterLockException('write to'));\n    }\n\n    return WritableStreamDefaultWriterWrite(this, chunk);\n  }\n}\n\n// Abstract operations for the WritableStreamDefaultWriter.\n\nfunction IsWritableStreamDefaultWriter(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamAbort(stream, reason);\n}\n\nfunction WritableStreamDefaultWriterClose(writer) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return Promise.reject(new TypeError(\n      `The stream (in ${state} state) is not in the writable state and cannot be closed`));\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\n\n  const promise = new Promise((resolve, reject) => {\n    const closeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._closeRequest = closeRequest;\n  });\n\n  if (stream._backpressure === true && state === 'writable') {\n    defaultWriterReadyPromiseResolve(writer);\n  }\n\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n\n  return promise;\n}\n\n\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n    return Promise.resolve();\n  }\n\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  return WritableStreamDefaultWriterClose(writer);\n}\n\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n  if (writer._closedPromiseState === 'pending') {\n    defaultWriterClosedPromiseReject(writer, error);\n  } else {\n    defaultWriterClosedPromiseResetToRejected(writer, error);\n  }\n  writer._closedPromise.catch(() => {});\n}\n\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n  verbose('WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, %o)', error);\n  if (writer._readyPromiseState === 'pending') {\n    defaultWriterReadyPromiseReject(writer, error);\n  } else {\n    defaultWriterReadyPromiseResetToRejected(writer, error);\n  }\n  writer._readyPromise.catch(() => {});\n}\n\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\n  const stream = writer._ownerWritableStream;\n  const state = stream._state;\n\n  if (state === 'errored' || state === 'erroring') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\n\nfunction WritableStreamDefaultWriterRelease(writer) {\n  const stream = writer._ownerWritableStream;\n  assert(stream !== undefined);\n  assert(stream._writer === writer);\n\n  const releasedError = new TypeError(\n    'Writer was released and can no longer be used to monitor the stream\\'s closedness');\n\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n\n  // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  // rejected until afterwards. This means that simply testing state will not work.\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined;\n}\n\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const controller = stream._writableStreamController;\n\n  const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n\n  if (stream !== writer._ownerWritableStream) {\n    return Promise.reject(defaultWriterLockException('write to'));\n  }\n\n  const state = stream._state;\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n    return Promise.reject(new TypeError('The stream is closing or closed and cannot be written to'));\n  }\n  if (state === 'erroring') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(state === 'writable');\n\n  const promise = WritableStreamAddWriteRequest(stream);\n\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n\n  return promise;\n}\n\nclass WritableStreamDefaultController {\n  constructor() {\n    throw new TypeError('WritableStreamDefaultController cannot be constructed explicitly');\n  }\n\n  error(e) {\n    if (IsWritableStreamDefaultController(this) === false) {\n      throw new TypeError(\n        'WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\n    }\n    const state = this._controlledWritableStream._state;\n    if (state !== 'writable') {\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n      // just treat it as a no-op.\n      return;\n    }\n\n    WritableStreamDefaultControllerError(this, e);\n  }\n\n  [AbortSteps](reason) {\n    const result = this._abortAlgorithm(reason);\n    WritableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  [ErrorSteps]() {\n    ResetQueue(this);\n  }\n}\n\n// Abstract operations implementing interface required by the WritableStream.\n\nfunction IsWritableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                              abortAlgorithm, highWaterMark, sizeAlgorithm) {\n  assert(IsWritableStream(stream) === true);\n  assert(stream._writableStreamController === undefined);\n\n  controller._controlledWritableStream = stream;\n  stream._writableStreamController = controller;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._started = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._writeAlgorithm = writeAlgorithm;\n  controller._closeAlgorithm = closeAlgorithm;\n  controller._abortAlgorithm = abortAlgorithm;\n\n  const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n  WritableStreamUpdateBackpressure(stream, backpressure);\n\n  const startResult = startAlgorithm();\n  const startPromise = Promise.resolve(startResult);\n  startPromise.then(\n      () => {\n        assert(stream._state === 'writable' || stream._state === 'erroring');\n        controller._started = true;\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n      },\n      r => {\n        assert(stream._state === 'writable' || stream._state === 'erroring');\n        controller._started = true;\n        WritableStreamDealWithRejection(stream, r);\n      }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n  assert(underlyingSink !== undefined);\n\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingSink, 'start', [controller]);\n  }\n\n  const writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'write', 1, [controller]);\n  const closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'close', 0, []);\n  const abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'abort', 1, []);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n}\n\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller) {\n  controller._writeAlgorithm = undefined;\n  controller._closeAlgorithm = undefined;\n  controller._abortAlgorithm = undefined;\n  controller._strategySizeAlgorithm = undefined;\n}\n\nfunction WritableStreamDefaultControllerClose(controller) {\n  EnqueueValueWithSize(controller, 'close', 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n  try {\n    return controller._strategySizeAlgorithm(chunk);\n  } catch (chunkSizeE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n    return 1;\n  }\n}\n\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n  const writeRecord = { chunk };\n\n  try {\n    EnqueueValueWithSize(controller, writeRecord, chunkSize);\n  } catch (enqueueE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n    return;\n  }\n\n  const stream = controller._controlledWritableStream;\n  if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n  }\n\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\n// Abstract operations for the WritableStreamDefaultController.\n\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n  verbose('WritableStreamDefaultControllerAdvanceQueueIfNeeded()');\n  const stream = controller._controlledWritableStream;\n\n  if (controller._started === false) {\n    return;\n  }\n\n  if (stream._inFlightWriteRequest !== undefined) {\n    return;\n  }\n\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return;\n  }\n  if (state === 'erroring') {\n    WritableStreamFinishErroring(stream);\n    return;\n  }\n\n  if (controller._queue.length === 0) {\n    return;\n  }\n\n  const writeRecord = PeekQueueValue(controller);\n  if (writeRecord === 'close') {\n    WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n    WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);\n  }\n}\n\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n  if (controller._controlledWritableStream._state === 'writable') {\n    WritableStreamDefaultControllerError(controller, error);\n  }\n}\n\nfunction WritableStreamDefaultControllerProcessClose(controller) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkCloseRequestInFlight(stream);\n\n  DequeueValue(controller);\n  assert(controller._queue.length === 0);\n\n  const sinkClosePromise = controller._closeAlgorithm();\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  sinkClosePromise.then(\n    () => {\n      WritableStreamFinishInFlightClose(stream);\n    },\n    reason => {\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\n\n  const sinkWritePromise = controller._writeAlgorithm(chunk);\n  sinkWritePromise.then(\n    () => {\n      WritableStreamFinishInFlightWrite(stream);\n\n      const state = stream._state;\n      assert(state === 'writable' || state === 'erroring');\n\n      DequeueValue(controller);\n\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n      }\n\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    },\n    reason => {\n      if (stream._state === 'writable') {\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n      }\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n}\n\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultControllerError(controller, error) {\n  const stream = controller._controlledWritableStream;\n\n  assert(stream._state === 'writable');\n\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  WritableStreamStartErroring(stream, error);\n}\n\n// Helper functions for the WritableStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n\n// Helper functions for the WritableStreamDefaultWriter.\n\nfunction defaultWriterBrandCheckException(name) {\n  return new TypeError(\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\n\nfunction defaultWriterLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\n\nfunction defaultWriterClosedPromiseInitialize(writer) {\n  writer._closedPromise = new Promise((resolve, reject) => {\n    writer._closedPromise_resolve = resolve;\n    writer._closedPromise_reject = reject;\n    writer._closedPromiseState = 'pending';\n  });\n}\n\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n  writer._closedPromise = Promise.reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\n  writer._closedPromise = Promise.resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterClosedPromiseReject(writer, reason) {\n  assert(writer._closedPromise_resolve !== undefined);\n  assert(writer._closedPromise_reject !== undefined);\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\n  assert(writer._closedPromise_resolve === undefined);\n  assert(writer._closedPromise_reject === undefined);\n  assert(writer._closedPromiseState !== 'pending');\n\n  writer._closedPromise = Promise.reject(reason);\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResolve(writer) {\n  assert(writer._closedPromise_resolve !== undefined);\n  assert(writer._closedPromise_reject !== undefined);\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterReadyPromiseInitialize(writer) {\n  verbose('defaultWriterReadyPromiseInitialize()');\n  writer._readyPromise = new Promise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n  verbose('defaultWriterReadyPromiseInitializeAsRejected(writer, %o)', reason);\n  writer._readyPromise = Promise.reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\n  verbose('defaultWriterReadyPromiseInitializeAsResolved()');\n  writer._readyPromise = Promise.resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n\nfunction defaultWriterReadyPromiseReject(writer, reason) {\n  verbose('defaultWriterReadyPromiseReject(writer, %o)', reason);\n  assert(writer._readyPromise_resolve !== undefined);\n  assert(writer._readyPromise_reject !== undefined);\n\n  writer._readyPromise_reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseReset(writer) {\n  verbose('defaultWriterReadyPromiseReset()');\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  writer._readyPromise = new Promise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\n  verbose('defaultWriterReadyPromiseResetToRejected(writer, %o)', reason);\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  writer._readyPromise = Promise.reject(reason);\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseResolve(writer) {\n  verbose('defaultWriterReadyPromiseResolve()');\n  assert(writer._readyPromise_resolve !== undefined);\n  assert(writer._readyPromise_reject !== undefined);\n\n  writer._readyPromise_resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n","'use strict';\nconst assert = require('better-assert');\nconst { ArrayBufferCopy, CreateAlgorithmFromUnderlyingMethod, IsFiniteNonNegativeNumber, InvokeOrNoop,\n        IsDetachedBuffer, TransferArrayBuffer, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction, createArrayFromList, typeIsObject } = require('./helpers.js');\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\nconst { DequeueValue, EnqueueValueWithSize, ResetQueue } = require('./queue-with-sizes.js');\nconst { AcquireWritableStreamDefaultWriter, IsWritableStream, IsWritableStreamLocked,\n        WritableStreamAbort, WritableStreamDefaultWriterCloseWithErrorPropagation,\n        WritableStreamDefaultWriterRelease, WritableStreamDefaultWriterWrite, WritableStreamCloseQueuedOrInFlight } =\n      require('./writable-stream.js');\n\nconst CancelSteps = Symbol('[[CancelSteps]]');\nconst PullSteps = Symbol('[[PullSteps]]');\n\nclass ReadableStream {\n  constructor(underlyingSource = {}, strategy = {}) {\n    InitializeReadableStream(this);\n\n    const size = strategy.size;\n    let highWaterMark = strategy.highWaterMark;\n\n    const type = underlyingSource.type;\n    const typeString = String(type);\n    if (typeString === 'bytes') {\n      if (size !== undefined) {\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\n      }\n\n      if (highWaterMark === undefined) {\n        highWaterMark = 0;\n      }\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n      SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n    } else if (type === undefined) {\n      const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n\n      if (highWaterMark === undefined) {\n        highWaterMark = 1;\n      }\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n    } else {\n      throw new RangeError('Invalid type is specified');\n    }\n  }\n\n  get locked() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsReadableStreamLocked(this);\n  }\n\n  cancel(reason) {\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('cancel'));\n    }\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));\n    }\n\n    return ReadableStreamCancel(this, reason);\n  }\n\n  getReader({ mode } = {}) {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('getReader');\n    }\n\n    if (mode === undefined) {\n      return AcquireReadableStreamDefaultReader(this);\n    }\n\n    mode = String(mode);\n\n    if (mode === 'byob') {\n      return AcquireReadableStreamBYOBReader(this);\n    }\n\n    throw new RangeError('Invalid mode is specified');\n  }\n\n  pipeThrough({ writable, readable }, options) {\n    if (writable === undefined || readable === undefined) {\n      throw new TypeError('readable and writable arguments must be defined');\n    }\n\n    const promise = this.pipeTo(writable, options);\n\n    ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise);\n\n    return readable;\n  }\n\n  pipeTo(dest, { preventClose, preventAbort, preventCancel } = {}) {\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('pipeTo'));\n    }\n    if (IsWritableStream(dest) === false) {\n      return Promise.reject(\n        new TypeError('ReadableStream.prototype.pipeTo\\'s first argument must be a WritableStream'));\n    }\n\n    preventClose = Boolean(preventClose);\n    preventAbort = Boolean(preventAbort);\n    preventCancel = Boolean(preventCancel);\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n    }\n    if (IsWritableStreamLocked(dest) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n    }\n\n    const reader = AcquireReadableStreamDefaultReader(this);\n    const writer = AcquireWritableStreamDefaultWriter(dest);\n\n    let shuttingDown = false;\n\n    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n    let currentWrite = Promise.resolve();\n\n    return new Promise((resolve, reject) => {\n      // Using reader and writer, read all chunks from this and write them to dest\n      // - Backpressure must be enforced\n      // - Shutdown must stop all activity\n      function pipeLoop() {\n        if (shuttingDown === true) {\n          return Promise.resolve();\n        }\n\n        return writer._readyPromise.then(() => {\n          return ReadableStreamDefaultReaderRead(reader).then(({ value, done }) => {\n            if (done === true) {\n              return;\n            }\n\n            currentWrite = WritableStreamDefaultWriterWrite(writer, value).catch(() => {});\n          });\n        })\n        .then(pipeLoop);\n      }\n\n      // Errors must be propagated forward\n      isOrBecomesErrored(this, reader._closedPromise, storedError => {\n        if (preventAbort === false) {\n          shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n        } else {\n          shutdown(true, storedError);\n        }\n      });\n\n      // Errors must be propagated backward\n      isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n        if (preventCancel === false) {\n          shutdownWithAction(() => ReadableStreamCancel(this, storedError), true, storedError);\n        } else {\n          shutdown(true, storedError);\n        }\n      });\n\n      // Closing must be propagated forward\n      isOrBecomesClosed(this, reader._closedPromise, () => {\n        if (preventClose === false) {\n          shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n        } else {\n          shutdown();\n        }\n      });\n\n      // Closing must be propagated backward\n      if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === 'closed') {\n        const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n\n        if (preventCancel === false) {\n          shutdownWithAction(() => ReadableStreamCancel(this, destClosed), true, destClosed);\n        } else {\n          shutdown(true, destClosed);\n        }\n      }\n\n      pipeLoop().catch(err => {\n        currentWrite = Promise.resolve();\n        rethrowAssertionErrorRejection(err);\n      });\n\n      function waitForWritesToFinish() {\n        // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n        // for that too.\n        const oldCurrentWrite = currentWrite;\n        return currentWrite.then(() => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n      }\n\n      function isOrBecomesErrored(stream, promise, action) {\n        if (stream._state === 'errored') {\n          action(stream._storedError);\n        } else {\n          promise.catch(action).catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function isOrBecomesClosed(stream, promise, action) {\n        if (stream._state === 'closed') {\n          action();\n        } else {\n          promise.then(action).catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function shutdownWithAction(action, originalIsError, originalError) {\n        if (shuttingDown === true) {\n          return;\n        }\n        shuttingDown = true;\n\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n          waitForWritesToFinish().then(doTheRest);\n        } else {\n          doTheRest();\n        }\n\n        function doTheRest() {\n          action().then(\n            () => finalize(originalIsError, originalError),\n            newError => finalize(true, newError)\n          )\n          .catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function shutdown(isError, error) {\n        if (shuttingDown === true) {\n          return;\n        }\n        shuttingDown = true;\n\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n          waitForWritesToFinish().then(() => finalize(isError, error)).catch(rethrowAssertionErrorRejection);\n        } else {\n          finalize(isError, error);\n        }\n      }\n\n      function finalize(isError, error) {\n        WritableStreamDefaultWriterRelease(writer);\n        ReadableStreamReaderGenericRelease(reader);\n\n        if (isError) {\n          reject(error);\n        } else {\n          resolve(undefined);\n        }\n      }\n    });\n  }\n\n  tee() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('tee');\n    }\n\n    const branches = ReadableStreamTee(this, false);\n    return createArrayFromList(branches);\n  }\n}\n\nmodule.exports = {\n  CreateReadableByteStream,\n  CreateReadableStream,\n  ReadableStream,\n  IsReadableStreamDisturbed,\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError,\n  ReadableStreamDefaultControllerGetDesiredSize,\n  ReadableStreamDefaultControllerHasBackpressure,\n  ReadableStreamDefaultControllerCanCloseOrEnqueue\n};\n\n// Abstract operations for the ReadableStream.\n\nfunction AcquireReadableStreamBYOBReader(stream) {\n  return new ReadableStreamBYOBReader(stream);\n}\n\nfunction AcquireReadableStreamDefaultReader(stream) {\n  return new ReadableStreamDefaultReader(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1,\n                              sizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n\n  const stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\n\n  SetUpReadableStreamDefaultController(\n      stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n\n  return stream;\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 0,\n                                  autoAllocateChunkSize = undefined) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  const stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller = Object.create(ReadableByteStreamController.prototype);\n\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\n                                    autoAllocateChunkSize);\n\n  return stream;\n}\n\nfunction InitializeReadableStream(stream) {\n  stream._state = 'readable';\n  stream._reader = undefined;\n  stream._storedError = undefined;\n  stream._disturbed = false;\n}\n\nfunction IsReadableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDisturbed(stream) {\n  assert(IsReadableStream(stream) === true);\n\n  return stream._disturbed;\n}\n\nfunction IsReadableStreamLocked(stream) {\n  assert(IsReadableStream(stream) === true);\n\n  if (stream._reader === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamTee(stream, cloneForBranch2) {\n  assert(IsReadableStream(stream) === true);\n  assert(typeof cloneForBranch2 === 'boolean');\n\n  const reader = AcquireReadableStreamDefaultReader(stream);\n\n  let closedOrErrored = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1;\n  let reason2;\n  let branch1;\n  let branch2;\n\n  let resolveCancelPromise;\n  const cancelPromise = new Promise(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function pullAlgorithm() {\n    return ReadableStreamDefaultReaderRead(reader).then(result => {\n      assert(typeIsObject(result));\n      const value = result.value;\n      const done = result.done;\n      assert(typeof done === 'boolean');\n\n      if (done === true && closedOrErrored === false) {\n        if (canceled1 === false) {\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n        }\n        if (canceled2 === false) {\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n        }\n        closedOrErrored = true;\n      }\n\n      if (closedOrErrored === true) {\n        return;\n      }\n\n      const value1 = value;\n      const value2 = value;\n\n      // There is no way to access the cloning code right now in the reference implementation.\n      // If we add one then we'll need an implementation for serializable objects.\n      // if (canceled2 === false && cloneForBranch2 === true) {\n      //   value2 = StructuredDeserialize(StructuredSerialize(value2));\n      // }\n\n      if (canceled1 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\n      }\n\n      if (canceled2 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\n      }\n    });\n  }\n\n  function cancel1Algorithm(reason) {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2 === true) {\n      const compositeReason = createArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason) {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1 === true) {\n      const compositeReason = createArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm() {}\n\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n\n  reader._closedPromise.catch(r => {\n    if (closedOrErrored === true) {\n      return;\n    }\n\n    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n    closedOrErrored = true;\n  });\n\n  return [branch1, branch2];\n}\n\n// ReadableStream API exposed for controllers.\n\nfunction ReadableStreamAddReadIntoRequest(stream, forAuthorCode) {\n  assert(IsReadableStreamBYOBReader(stream._reader) === true);\n  assert(stream._state === 'readable' || stream._state === 'closed');\n\n  const promise = new Promise((resolve, reject) => {\n    const readIntoRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _forAuthorCode: forAuthorCode\n    };\n\n    stream._reader._readIntoRequests.push(readIntoRequest);\n  });\n\n  return promise;\n}\n\nfunction ReadableStreamAddReadRequest(stream, forAuthorCode) {\n  assert(IsReadableStreamDefaultReader(stream._reader) === true);\n  assert(stream._state === 'readable');\n\n  const promise = new Promise((resolve, reject) => {\n    const readRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _forAuthorCode: forAuthorCode\n    };\n\n    stream._reader._readRequests.push(readRequest);\n  });\n\n  return promise;\n}\n\nfunction ReadableStreamCancel(stream, reason) {\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(undefined);\n  }\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  ReadableStreamClose(stream);\n\n  const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n  return sourceCancelPromise.then(() => undefined);\n}\n\nfunction ReadableStreamClose(stream) {\n  assert(stream._state === 'readable');\n\n  stream._state = 'closed';\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (const { _resolve, _forAuthorCode } of reader._readRequests) {\n      _resolve(ReadableStreamCreateReadResult(undefined, true, _forAuthorCode));\n    }\n    reader._readRequests = [];\n  }\n\n  defaultReaderClosedPromiseResolve(reader);\n\n  return undefined;\n}\n\nfunction ReadableStreamCreateReadResult(value, done, forAuthorCode) {\n  let prototype = null;\n  if (forAuthorCode === true) {\n    prototype = Object.prototype;\n  }\n  assert(typeof done === 'boolean');\n  const obj = Object.create(prototype);\n  Object.defineProperty(obj, 'value', { value, enumerable: true, writable: true, configurable: true });\n  Object.defineProperty(obj, 'done', { value: done, enumerable: true, writable: true, configurable: true });\n  return obj;\n}\n\nfunction ReadableStreamError(stream, e) {\n  assert(IsReadableStream(stream) === true);\n  assert(stream._state === 'readable');\n\n  stream._state = 'errored';\n  stream._storedError = e;\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (const readRequest of reader._readRequests) {\n      readRequest._reject(e);\n    }\n\n    reader._readRequests = [];\n  } else {\n    assert(IsReadableStreamBYOBReader(reader));\n\n    for (const readIntoRequest of reader._readIntoRequests) {\n      readIntoRequest._reject(e);\n    }\n\n    reader._readIntoRequests = [];\n  }\n\n  defaultReaderClosedPromiseReject(reader, e);\n  reader._closedPromise.catch(() => {});\n}\n\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n  const reader = stream._reader;\n\n  assert(reader._readIntoRequests.length > 0);\n\n  const readIntoRequest = reader._readIntoRequests.shift();\n  readIntoRequest._resolve(ReadableStreamCreateReadResult(chunk, done, readIntoRequest._forAuthorCode));\n}\n\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n  const reader = stream._reader;\n\n  assert(reader._readRequests.length > 0);\n\n  const readRequest = reader._readRequests.shift();\n  readRequest._resolve(ReadableStreamCreateReadResult(chunk, done, readRequest._forAuthorCode));\n}\n\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n  return stream._reader._readIntoRequests.length;\n}\n\nfunction ReadableStreamGetNumReadRequests(stream) {\n  return stream._reader._readRequests.length;\n}\n\nfunction ReadableStreamHasBYOBReader(stream) {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamBYOBReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamHasDefaultReader(stream) {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nclass ReadableStreamDefaultReader {\n  constructor(stream) {\n    if (IsReadableStream(stream) === false) {\n      throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');\n    }\n    if (IsReadableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readRequests = [];\n  }\n\n  get closed() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  cancel(reason) {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  read() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    return ReadableStreamDefaultReaderRead(this, true);\n  }\n\n  releaseLock() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      throw defaultReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\nclass ReadableStreamBYOBReader {\n  constructor(stream) {\n    if (!IsReadableStream(stream)) {\n      throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' +\n          'byte source');\n    }\n    if (IsReadableByteStreamController(stream._readableStreamController) === false) {\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n          'source');\n    }\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readIntoRequests = [];\n  }\n\n  get closed() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  cancel(reason) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  read(view) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      return Promise.reject(new TypeError('view must be an array buffer view'));\n    }\n\n    if (IsDetachedBuffer(view.buffer) === true) {\n      return Promise.reject(new TypeError('Cannot read into a view onto a detached ArrayBuffer'));\n    }\n\n    if (view.byteLength === 0) {\n      return Promise.reject(new TypeError('view must have non-zero byteLength'));\n    }\n\n    return ReadableStreamBYOBReaderRead(this, view, true);\n  }\n\n  releaseLock() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      throw byobReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readIntoRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\n// Abstract operations for the readers.\n\nfunction IsReadableStreamBYOBReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDefaultReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === 'closed') {\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n    assert(stream._state === 'errored');\n\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n    reader._closedPromise.catch(() => {});\n  }\n}\n\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\n\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  return ReadableStreamCancel(stream, reason);\n}\n\nfunction ReadableStreamReaderGenericRelease(reader) {\n  assert(reader._ownerReadableStream !== undefined);\n  assert(reader._ownerReadableStream._reader === reader);\n\n  if (reader._ownerReadableStream._state === 'readable') {\n    defaultReaderClosedPromiseReject(\n        reader,\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  } else {\n    defaultReaderClosedPromiseResetToRejected(\n        reader,\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  }\n  reader._closedPromise.catch(() => {});\n\n  reader._ownerReadableStream._reader = undefined;\n  reader._ownerReadableStream = undefined;\n}\n\nfunction ReadableStreamBYOBReaderRead(reader, view, forAuthorCode = false) {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  // Controllers must implement this.\n  return ReadableByteStreamControllerPullInto(stream._readableStreamController, view, forAuthorCode);\n}\n\nfunction ReadableStreamDefaultReaderRead(reader, forAuthorCode = false) {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(ReadableStreamCreateReadResult(undefined, true, forAuthorCode));\n  }\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(stream._state === 'readable');\n\n  return stream._readableStreamController[PullSteps](forAuthorCode);\n}\n\n// Controllers\n\nclass ReadableStreamDefaultController {\n  constructor() {\n    throw new TypeError();\n  }\n\n  get desiredSize() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('close');\n    }\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError('The stream is not in a state that permits close');\n    }\n\n    ReadableStreamDefaultControllerClose(this);\n  }\n\n  enqueue(chunk) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError('The stream is not in a state that permits enqueue');\n    }\n\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  error(e) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    ReadableStreamDefaultControllerError(this, e);\n  }\n\n  [CancelSteps](reason) {\n    ResetQueue(this);\n    const result = this._cancelAlgorithm(reason);\n    ReadableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  [PullSteps](forAuthorCode) {\n    const stream = this._controlledReadableStream;\n\n    if (this._queue.length > 0) {\n      const chunk = DequeueValue(this);\n\n      if (this._closeRequested === true && this._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        ReadableStreamClose(stream);\n      } else {\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n      }\n\n      return Promise.resolve(ReadableStreamCreateReadResult(chunk, false, forAuthorCode));\n    }\n\n    const pendingPromise = ReadableStreamAddReadRequest(stream, forAuthorCode);\n    ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    return pendingPromise;\n  }\n}\n\n// Abstract operations for the ReadableStreamDefaultController.\n\nfunction IsReadableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  assert(controller._pullAgain === false);\n\n  controller._pulling = true;\n\n  const pullPromise = controller._pullAlgorithm();\n  pullPromise.then(\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        return ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n      return undefined;\n    },\n    e => {\n      ReadableStreamDefaultControllerError(controller, e);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableStream;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller) {\n  controller._pullAlgorithm = undefined;\n  controller._cancelAlgorithm = undefined;\n  controller._strategySizeAlgorithm = undefined;\n}\n\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction ReadableStreamDefaultControllerClose(controller) {\n  const stream = controller._controlledReadableStream;\n\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\n\n  controller._closeRequested = true;\n\n  if (controller._queue.length === 0) {\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n  }\n}\n\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableStream;\n\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    let chunkSize;\n    try {\n      chunkSize = controller._strategySizeAlgorithm(chunk);\n    } catch (chunkSizeE) {\n      ReadableStreamDefaultControllerError(controller, chunkSizeE);\n      throw chunkSizeE;\n    }\n\n    try {\n      EnqueueValueWithSize(controller, chunk, chunkSize);\n    } catch (enqueueE) {\n      ReadableStreamDefaultControllerError(controller, enqueueE);\n      throw enqueueE;\n    }\n  }\n\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerError(controller, e) {\n  const stream = controller._controlledReadableStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ResetQueue(controller);\n\n  ReadableStreamDefaultControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n  const stream = controller._controlledReadableStream;\n  const state = stream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\n// This is used in the implementation of TransformStream.\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\n  if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n  const state = controller._controlledReadableStream._state;\n\n  if (controller._closeRequested === false && state === 'readable') {\n    return true;\n  }\n\n  return false;\n}\n\nfunction SetUpReadableStreamDefaultController(\n  stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n  assert(stream._readableStreamController === undefined);\n\n  controller._controlledReadableStream = stream;\n\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._started = false;\n  controller._closeRequested = false;\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  Promise.resolve(startResult).then(\n    () => {\n      controller._started = true;\n\n      assert(controller._pulling === false);\n      assert(controller._pullAgain === false);\n\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    },\n    r => {\n      ReadableStreamDefaultControllerError(controller, r);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark,\n                                                                  sizeAlgorithm) {\n  assert(underlyingSource !== undefined);\n\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingSource, 'start', [controller]);\n  }\n\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'pull', 0, [controller]);\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'cancel', 1, []);\n\n  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\n                                       highWaterMark, sizeAlgorithm);\n}\n\nclass ReadableStreamBYOBRequest {\n  constructor() {\n    throw new TypeError('ReadableStreamBYOBRequest cannot be used directly');\n  }\n\n  get view() {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('view');\n    }\n\n    return this._view;\n  }\n\n  respond(bytesWritten) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(this._view.buffer) === true) {\n      throw new TypeError('The BYOB request\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  }\n\n  respondWithNewView(view) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      throw new TypeError('You can only respond with array buffer views');\n    }\n\n    if (IsDetachedBuffer(view.buffer) === true) {\n      throw new TypeError('The supplied view\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  }\n}\n\nclass ReadableByteStreamController {\n  constructor() {\n    throw new TypeError('ReadableByteStreamController constructor cannot be used directly');\n  }\n\n  get byobRequest() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('byobRequest');\n    }\n\n    if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos[0];\n      const view = new Uint8Array(firstDescriptor.buffer,\n                                  firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\n                                  firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n\n      const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n      SetUpReadableStreamBYOBRequest(byobRequest, this, view);\n      this._byobRequest = byobRequest;\n    }\n\n    return this._byobRequest;\n  }\n\n  get desiredSize() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableByteStreamControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('close');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n    }\n\n    ReadableByteStreamControllerClose(this);\n  }\n\n  enqueue(chunk) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('enqueue');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n    }\n\n    if (!ArrayBuffer.isView(chunk)) {\n      throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');\n    }\n\n    if (IsDetachedBuffer(chunk.buffer) === true) {\n      throw new TypeError('Cannot enqueue a view onto a detached ArrayBuffer');\n    }\n\n    ReadableByteStreamControllerEnqueue(this, chunk);\n  }\n\n  error(e) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('error');\n    }\n\n    ReadableByteStreamControllerError(this, e);\n  }\n\n  [CancelSteps](reason) {\n    if (this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos[0];\n      firstDescriptor.bytesFilled = 0;\n    }\n\n    ResetQueue(this);\n\n    const result = this._cancelAlgorithm(reason);\n    ReadableByteStreamControllerClearAlgorithms(this);\n    return result;\n  }\n\n  [PullSteps](forAuthorCode) {\n    const stream = this._controlledReadableByteStream;\n    assert(ReadableStreamHasDefaultReader(stream) === true);\n\n    if (this._queueTotalSize > 0) {\n      assert(ReadableStreamGetNumReadRequests(stream) === 0);\n\n      const entry = this._queue.shift();\n      this._queueTotalSize -= entry.byteLength;\n\n      ReadableByteStreamControllerHandleQueueDrain(this);\n\n      let view;\n      try {\n        view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n      } catch (viewE) {\n        return Promise.reject(viewE);\n      }\n\n      return Promise.resolve(ReadableStreamCreateReadResult(view, false, forAuthorCode));\n    }\n\n    const autoAllocateChunkSize = this._autoAllocateChunkSize;\n    if (autoAllocateChunkSize !== undefined) {\n      let buffer;\n      try {\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\n      } catch (bufferE) {\n        return Promise.reject(bufferE);\n      }\n\n      const pullIntoDescriptor = {\n        buffer,\n        byteOffset: 0,\n        byteLength: autoAllocateChunkSize,\n        bytesFilled: 0,\n        elementSize: 1,\n        ctor: Uint8Array,\n        readerType: 'default'\n      };\n\n      this._pendingPullIntos.push(pullIntoDescriptor);\n    }\n\n    const promise = ReadableStreamAddReadRequest(stream, forAuthorCode);\n\n    ReadableByteStreamControllerCallPullIfNeeded(this);\n\n    return promise;\n  }\n}\n\n// Abstract operations for the ReadableByteStreamController.\n\nfunction IsReadableByteStreamController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamBYOBRequest(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  assert(controller._pullAgain === false);\n\n  controller._pulling = true;\n\n  // TODO: Test controller argument\n  const pullPromise = controller._pullAlgorithm();\n  pullPromise.then(\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n    },\n    e => {\n      ReadableByteStreamControllerError(controller, e);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n\n  return undefined;\n}\n\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = [];\n}\n\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n  assert(stream._state !== 'errored');\n\n  let done = false;\n  if (stream._state === 'closed') {\n    assert(pullIntoDescriptor.bytesFilled === 0);\n    done = true;\n  }\n\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n  if (pullIntoDescriptor.readerType === 'default') {\n    ReadableStreamFulfillReadRequest(stream, filledView, done);\n  } else {\n    assert(pullIntoDescriptor.readerType === 'byob');\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\n\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\n  assert(bytesFilled % elementSize === 0);\n\n  return new pullIntoDescriptor.ctor(\n      pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n}\n\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n  controller._queue.push({ buffer, byteOffset, byteLength });\n  controller._queueTotalSize += byteLength;\n}\n\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n\n  const maxBytesToCopy = Math.min(controller._queueTotalSize,\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n  const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  if (maxAlignedBytes > currentAlignedBytes) {\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n    ready = true;\n  }\n\n  const queue = controller._queue;\n\n  while (totalBytesToCopyRemaining > 0) {\n    const headOfQueue = queue[0];\n\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n\n    if (headOfQueue.byteLength === bytesToCopy) {\n      queue.shift();\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller._queueTotalSize -= bytesToCopy;\n\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  if (ready === false) {\n    assert(controller._queueTotalSize === 0);\n    assert(pullIntoDescriptor.bytesFilled > 0);\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);\n  }\n\n  return ready;\n}\n\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos[0] === pullIntoDescriptor);\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  pullIntoDescriptor.bytesFilled += size;\n}\n\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n  assert(controller._controlledReadableByteStream._state === 'readable');\n\n  if (controller._queueTotalSize === 0 && controller._closeRequested === true) {\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(controller._controlledReadableByteStream);\n  } else {\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n}\n\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n  if (controller._byobRequest === undefined) {\n    return;\n  }\n\n  controller._byobRequest._associatedReadableByteStreamController = undefined;\n  controller._byobRequest._view = undefined;\n  controller._byobRequest = undefined;\n}\n\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n  assert(controller._closeRequested === false);\n\n  while (controller._pendingPullIntos.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n\n    const pullIntoDescriptor = controller._pendingPullIntos[0];\n\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\n        controller._controlledReadableByteStream,\n        pullIntoDescriptor\n      );\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerPullInto(controller, view, forAuthorCode) {\n  const stream = controller._controlledReadableByteStream;\n\n  let elementSize = 1;\n  if (view.constructor !== DataView) {\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\n  }\n\n  const ctor = view.constructor;\n\n  const buffer = TransferArrayBuffer(view.buffer);\n  const pullIntoDescriptor = {\n    buffer,\n    byteOffset: view.byteOffset,\n    byteLength: view.byteLength,\n    bytesFilled: 0,\n    elementSize,\n    ctor,\n    readerType: 'byob'\n  };\n\n  if (controller._pendingPullIntos.length > 0) {\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n    // - No change happens on desiredSize\n    // - The source has already been notified of that there's at least 1 pending read(view)\n\n    return ReadableStreamAddReadIntoRequest(stream, forAuthorCode);\n  }\n\n  if (stream._state === 'closed') {\n    const emptyView = new view.constructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n    return Promise.resolve(ReadableStreamCreateReadResult(emptyView, true, forAuthorCode));\n  }\n\n  if (controller._queueTotalSize > 0) {\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n\n      ReadableByteStreamControllerHandleQueueDrain(controller);\n\n      return Promise.resolve(ReadableStreamCreateReadResult(filledView, false, forAuthorCode));\n    }\n\n    if (controller._closeRequested === true) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      return Promise.reject(e);\n    }\n  }\n\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n\n  const promise = ReadableStreamAddReadIntoRequest(stream, forAuthorCode);\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n\n  return promise;\n}\n\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n\n  assert(firstDescriptor.bytesFilled === 0);\n\n  const stream = controller._controlledReadableByteStream;\n  if (ReadableStreamHasBYOBReader(stream) === true) {\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n      const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\n    throw new RangeError('bytesWritten out of range');\n  }\n\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n    // TODO: Figure out whether we should detach the buffer or not here.\n    return;\n  }\n\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n  if (remainderSize > 0) {\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n  }\n\n  pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n  const firstDescriptor = controller._pendingPullIntos[0];\n\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state === 'closed') {\n    if (bytesWritten !== 0) {\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n    }\n\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n    assert(stream._state === 'readable');\n\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n  const descriptor = controller._pendingPullIntos.shift();\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  return descriptor;\n}\n\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return false;\n  }\n\n  if (controller._closeRequested === true) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableByteStreamControllerClearAlgorithms(controller) {\n  controller._pullAlgorithm = undefined;\n  controller._cancelAlgorithm = undefined;\n}\n\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\n\nfunction ReadableByteStreamControllerClose(controller) {\n  const stream = controller._controlledReadableByteStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  if (controller._queueTotalSize > 0) {\n    controller._closeRequested = true;\n\n    return;\n  }\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos[0];\n    if (firstPendingPullInto.bytesFilled > 0) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      throw e;\n    }\n  }\n\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamClose(stream);\n}\n\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableByteStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  const buffer = chunk.buffer;\n  const byteOffset = chunk.byteOffset;\n  const byteLength = chunk.byteLength;\n  const transferredBuffer = TransferArrayBuffer(buffer);\n\n  if (ReadableStreamHasDefaultReader(stream) === true) {\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    } else {\n      assert(controller._queue.length === 0);\n\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n      ReadableStreamFulfillReadRequest(stream, transferredView, false);\n    }\n  } else if (ReadableStreamHasBYOBReader(stream) === true) {\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n    assert(IsReadableStreamLocked(stream) === false);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerError(controller, e) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  ResetQueue(controller);\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n  const stream = controller._controlledReadableByteStream;\n  const state = stream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n  bytesWritten = Number(bytesWritten);\n  if (IsFiniteNonNegativeNumber(bytesWritten) === false) {\n    throw new RangeError('bytesWritten must be a finite');\n  }\n\n  assert(controller._pendingPullIntos.length > 0);\n\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\n\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n  assert(controller._pendingPullIntos.length > 0);\n\n  const firstDescriptor = controller._pendingPullIntos[0];\n\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n    throw new RangeError('The region specified by view does not match byobRequest');\n  }\n  if (firstDescriptor.byteLength !== view.byteLength) {\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n\n  firstDescriptor.buffer = view.buffer;\n\n  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n}\n\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\n                                           highWaterMark, autoAllocateChunkSize) {\n  assert(stream._readableStreamController === undefined);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  controller._controlledReadableByteStream = stream;\n\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._closeRequested = false;\n  controller._started = false;\n\n  controller._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\n\n  controller._pendingPullIntos = [];\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  Promise.resolve(startResult).then(\n      () => {\n        controller._started = true;\n\n        assert(controller._pulling === false);\n        assert(controller._pullAgain === false);\n\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      },\n      r => {\n        ReadableByteStreamControllerError(controller, r);\n      }\n  )\n      .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n  assert(underlyingByteSource !== undefined);\n\n  const controller = Object.create(ReadableByteStreamController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingByteSource, 'start', [controller]);\n  }\n\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'pull', 0, [controller]);\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'cancel', 1, []);\n\n  let autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n  if (autoAllocateChunkSize !== undefined) {\n    autoAllocateChunkSize = Number(autoAllocateChunkSize);\n    if (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {\n      throw new RangeError('autoAllocateChunkSize must be a positive integer');\n    }\n  }\n\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\n                                    autoAllocateChunkSize);\n}\n\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\n  assert(IsReadableByteStreamController(controller) === true);\n  assert(typeof view === 'object');\n  assert(ArrayBuffer.isView(view) === true);\n  assert(IsDetachedBuffer(view.buffer) === false);\n  request._associatedReadableByteStreamController = controller;\n  request._view = view;\n}\n\n// Helper functions for the ReadableStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n\n// Helper functions for the readers.\n\nfunction readerLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction defaultReaderBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n\nfunction defaultReaderClosedPromiseInitialize(reader) {\n  reader._closedPromise = new Promise((resolve, reject) => {\n    reader._closedPromise_resolve = resolve;\n    reader._closedPromise_reject = reject;\n  });\n}\n\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n  reader._closedPromise = Promise.reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\n  reader._closedPromise = Promise.resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseReject(reader, reason) {\n  assert(reader._closedPromise_resolve !== undefined);\n  assert(reader._closedPromise_reject !== undefined);\n\n  reader._closedPromise_reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\n  assert(reader._closedPromise_resolve === undefined);\n  assert(reader._closedPromise_reject === undefined);\n\n  reader._closedPromise = Promise.reject(reason);\n}\n\nfunction defaultReaderClosedPromiseResolve(reader) {\n  assert(reader._closedPromise_resolve !== undefined);\n  assert(reader._closedPromise_reject !== undefined);\n\n  reader._closedPromise_resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction byobReaderBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n\n// Helper functions for the ReadableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n\n// Helper functions for the ReadableStreamBYOBRequest.\n\nfunction byobRequestBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n\n// Helper functions for the ReadableByteStreamController.\n\nfunction byteStreamControllerBrandCheckException(name) {\n  return new TypeError(\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n\n// Helper function for ReadableStream pipeThrough\n\nfunction ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise) {\n  try {\n    // This relies on the brand-check that is enforced by Promise.prototype.then(). As with the rest of the reference\n    // implementation, it doesn't attempt to do the right thing if someone has modified the global environment.\n    Promise.prototype.then.call(promise, undefined, () => {});\n  } catch (e) {\n    // The brand check failed, therefore the internal slot is not present and there's nothing further to do.\n  }\n}\n","'use strict';\nconst { createDataProperty } = require('./helpers.js');\n\nmodule.exports = class ByteLengthQueuingStrategy {\n  constructor({ highWaterMark }) {\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  size(chunk) {\n    return chunk.byteLength;\n  }\n};\n","'use strict';\nconst { createDataProperty } = require('./helpers.js');\n\nmodule.exports = class CountQueuingStrategy {\n  constructor({ highWaterMark }) {\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  size() {\n    return 1;\n  }\n};\n","'use strict';\nconst assert = require('better-assert');\n\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\n// and do not appear in the standard text.\nconst verbose = require('debug')('streams:transform-stream:verbose');\nconst { InvokeOrNoop, CreateAlgorithmFromUnderlyingMethod, PromiseCall, typeIsObject,\n        ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction } = require('./helpers.js');\nconst { CreateReadableStream, ReadableStreamDefaultControllerClose, ReadableStreamDefaultControllerEnqueue,\n        ReadableStreamDefaultControllerError, ReadableStreamDefaultControllerGetDesiredSize,\n        ReadableStreamDefaultControllerHasBackpressure,\n        ReadableStreamDefaultControllerCanCloseOrEnqueue } = require('./readable-stream.js');\nconst { CreateWritableStream, WritableStreamDefaultControllerErrorIfNeeded } = require('./writable-stream.js');\n\n// Class TransformStream\n\nclass TransformStream {\n  constructor(transformer = {}, writableStrategy = {}, readableStrategy = {}) {\n    const writableSizeFunction = writableStrategy.size;\n    let writableHighWaterMark = writableStrategy.highWaterMark;\n    const readableSizeFunction = readableStrategy.size;\n    let readableHighWaterMark = readableStrategy.highWaterMark;\n\n    const writableType = transformer.writableType;\n\n    if (writableType !== undefined) {\n      throw new RangeError('Invalid writable type specified');\n    }\n\n    const writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(writableSizeFunction);\n    if (writableHighWaterMark === undefined) {\n      writableHighWaterMark = 1;\n    }\n    writableHighWaterMark = ValidateAndNormalizeHighWaterMark(writableHighWaterMark);\n\n    const readableType = transformer.readableType;\n\n    if (readableType !== undefined) {\n      throw new RangeError('Invalid readable type specified');\n    }\n\n    const readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(readableSizeFunction);\n    if (readableHighWaterMark === undefined) {\n      readableHighWaterMark = 0;\n    }\n    readableHighWaterMark = ValidateAndNormalizeHighWaterMark(readableHighWaterMark);\n\n    let startPromise_resolve;\n    const startPromise = new Promise(resolve => {\n      startPromise_resolve = resolve;\n    });\n\n    InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                              readableSizeAlgorithm);\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n\n    const startResult = InvokeOrNoop(transformer, 'start', [this._transformStreamController]);\n    startPromise_resolve(startResult);\n  }\n\n  get readable() {\n    if (IsTransformStream(this) === false) {\n      throw streamBrandCheckException('readable');\n    }\n\n    return this._readable;\n  }\n\n  get writable() {\n    if (IsTransformStream(this) === false) {\n      throw streamBrandCheckException('writable');\n    }\n\n    return this._writable;\n  }\n}\n\n// Transform Stream Abstract Operations\n\nfunction CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm, writableHighWaterMark = 1,\n                               writableSizeAlgorithm = () => 1, readableHighWaterMark = 0,\n                               readableSizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(writableHighWaterMark));\n  assert(IsNonNegativeNumber(readableHighWaterMark));\n\n  const stream = Object.create(TransformStream.prototype);\n\n  let startPromise_resolve;\n  const startPromise = new Promise(resolve => {\n    startPromise_resolve = resolve;\n  });\n\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                            readableSizeAlgorithm);\n\n  const controller = Object.create(TransformStreamDefaultController.prototype);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n\n  const startResult = startAlgorithm();\n  startPromise_resolve(startResult);\n  return stream;\n}\n\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm,\n                                   readableHighWaterMark, readableSizeAlgorithm) {\n  function startAlgorithm() {\n    return startPromise;\n  }\n\n  function writeAlgorithm(chunk) {\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  }\n\n  function abortAlgorithm(reason) {\n    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n  }\n\n  function closeAlgorithm() {\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  }\n\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm,\n                                          writableHighWaterMark, writableSizeAlgorithm);\n\n  function pullAlgorithm() {\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\n  }\n\n  function cancelAlgorithm(reason) {\n    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n    return Promise.resolve();\n  }\n\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark,\n                                          readableSizeAlgorithm);\n\n  // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n  stream._backpressure = undefined;\n  stream._backpressureChangePromise = undefined;\n  stream._backpressureChangePromise_resolve = undefined;\n  TransformStreamSetBackpressure(stream, true);\n\n  // Used by IsWritableStream() which is called by SetUpTransformStreamDefaultController().\n  stream._transformStreamController = undefined;\n}\n\nfunction IsTransformStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream, e) {\n  verbose('TransformStreamError()');\n\n  ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\n\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n  if (stream._backpressure === true) {\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n    // _backpressure is set.\n    TransformStreamSetBackpressure(stream, false);\n  }\n}\n\nfunction TransformStreamSetBackpressure(stream, backpressure) {\n  verbose(`TransformStreamSetBackpressure() [backpressure = ${backpressure}]`);\n\n  // Passes also when called during construction.\n  assert(stream._backpressure !== backpressure);\n\n  if (stream._backpressureChangePromise !== undefined) {\n    stream._backpressureChangePromise_resolve();\n  }\n\n  stream._backpressureChangePromise = new Promise(resolve => {\n    stream._backpressureChangePromise_resolve = resolve;\n  });\n\n  stream._backpressure = backpressure;\n}\n\n// Class TransformStreamDefaultController\n\nclass TransformStreamDefaultController {\n  constructor() {\n    throw new TypeError('TransformStreamDefaultController instances cannot be created directly');\n  }\n\n  get desiredSize() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    const readableController = this._controlledTransformStream._readable._readableStreamController;\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n  }\n\n  enqueue(chunk) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    TransformStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  error(reason) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    TransformStreamDefaultControllerError(this, reason);\n  }\n\n  terminate() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('terminate');\n    }\n\n    TransformStreamDefaultControllerTerminate(this);\n  }\n}\n\n// Transform Stream Default Controller Abstract Operations\n\nfunction IsTransformStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n  assert(IsTransformStream(stream) === true);\n  assert(stream._transformStreamController === undefined);\n\n  controller._controlledTransformStream = stream;\n  stream._transformStreamController = controller;\n\n  controller._transformAlgorithm = transformAlgorithm;\n  controller._flushAlgorithm = flushAlgorithm;\n}\n\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n  assert(transformer !== undefined);\n\n  const controller = Object.create(TransformStreamDefaultController.prototype);\n\n  let transformAlgorithm = chunk => {\n    try {\n      TransformStreamDefaultControllerEnqueue(controller, chunk);\n      return Promise.resolve();\n    } catch (transformResultE) {\n      return Promise.reject(transformResultE);\n    }\n  };\n  const transformMethod = transformer.transform;\n  if (transformMethod !== undefined) {\n    if (typeof transformMethod !== 'function') {\n      throw new TypeError('transform is not a method');\n    }\n    transformAlgorithm = chunk => PromiseCall(transformMethod, transformer, [chunk, controller]);\n  }\n\n  const flushAlgorithm = CreateAlgorithmFromUnderlyingMethod(transformer, 'flush', 0, [controller]);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\n\nfunction TransformStreamDefaultControllerClearAlgorithms(controller) {\n  controller._transformAlgorithm = undefined;\n  controller._flushAlgorithm = undefined;\n}\n\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\n  verbose('TransformStreamDefaultControllerEnqueue()');\n\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === false) {\n    throw new TypeError('Readable side is not in a state that permits enqueue');\n  }\n\n  // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n  // accept TransformStreamDefaultControllerEnqueue() calls.\n\n  try {\n    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  } catch (e) {\n    // This happens when readableStrategy.size() throws.\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n\n    throw stream._readable._storedError;\n  }\n\n  const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n  if (backpressure !== stream._backpressure) {\n    assert(backpressure === true);\n    TransformStreamSetBackpressure(stream, true);\n  }\n}\n\nfunction TransformStreamDefaultControllerError(controller, e) {\n  TransformStreamError(controller._controlledTransformStream, e);\n}\n\nfunction TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n  const transformPromise = controller._transformAlgorithm(chunk);\n  return transformPromise.catch(r => {\n    TransformStreamError(controller._controlledTransformStream, r);\n    throw r;\n  });\n}\n\nfunction TransformStreamDefaultControllerTerminate(controller) {\n  verbose('TransformStreamDefaultControllerTerminate()');\n\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n    ReadableStreamDefaultControllerClose(readableController);\n  }\n\n  const error = new TypeError('TransformStream terminated');\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n\n// TransformStreamDefaultSink Algorithms\n\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n  verbose('TransformStreamDefaultSinkWriteAlgorithm()');\n\n  assert(stream._writable._state === 'writable');\n\n  const controller = stream._transformStreamController;\n\n  if (stream._backpressure === true) {\n    const backpressureChangePromise = stream._backpressureChangePromise;\n    assert(backpressureChangePromise !== undefined);\n    return backpressureChangePromise\n        .then(() => {\n          const writable = stream._writable;\n          const state = writable._state;\n          if (state === 'erroring') {\n            throw writable._storedError;\n          }\n          assert(state === 'writable');\n          return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n        });\n  }\n\n  return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n}\n\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n  // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n  // errored.\n  TransformStreamError(stream, reason);\n  return Promise.resolve();\n}\n\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\n  verbose('TransformStreamDefaultSinkCloseAlgorithm()');\n\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  const readable = stream._readable;\n\n  const controller = stream._transformStreamController;\n  const flushPromise = controller._flushAlgorithm();\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n\n  // Return a promise that is fulfilled with undefined on success.\n  return flushPromise.then(() => {\n    if (readable._state === 'errored') {\n      throw readable._storedError;\n    }\n    const readableController = readable._readableStreamController;\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n      ReadableStreamDefaultControllerClose(readableController);\n    }\n  }).catch(r => {\n    TransformStreamError(stream, r);\n    throw readable._storedError;\n  });\n}\n\n// TransformStreamDefaultSource Algorithms\n\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\n  verbose('TransformStreamDefaultSourcePullAlgorithm()');\n\n  // Invariant. Enforced by the promises returned by start() and pull().\n  assert(stream._backpressure === true);\n\n  assert(stream._backpressureChangePromise !== undefined);\n\n  TransformStreamSetBackpressure(stream, false);\n\n  // Prevent the next pull() call until there is backpressure.\n  return stream._backpressureChangePromise;\n}\n\nmodule.exports = { CreateTransformStream, TransformStream };\n\n// Helper functions for the TransformStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name) {\n  return new TypeError(\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n\n// Helper functions for the TransformStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(\n    `TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n","import {\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy,\n  ReadableStream,\n  TransformStream,\n  WritableStream\n} from './ponyfill';\nimport { globals } from './utils';\n\n// Export\nexport * from './ponyfill';\n\nconst exports = {\n  ReadableStream,\n  WritableStream,\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy,\n  TransformStream\n};\n\n// Add classes to global scope\nif (typeof globals !== 'undefined') {\n  Object.assign(globals, exports);\n}\n"],"names":["NumberIsInteger","Number","isInteger","value","isFinite","Math","floor","SymbolPolyfill","Symbol","iterator","description","noop","globals","self","window","global","NumberIsNaN","isNaN","x","isFakeDetached","Call","F","V","args","TypeError","Function","prototype","apply","call","PromiseCall","Promise","resolve","reject","o","p","v","defineProperty","elements","slice","dest","destOffset","src","srcOffset","n","Uint8Array","set","exports","IsNonNegativeNumber","Infinity","Number.isNaN","underlyingObject","methodName","algoArgCount","extraArgs","method","undefined","fullArgs","arg","concat","O","P","transferredIshVersion","highWaterMark","RangeError","size","chunk","assert","AssertionError","e","IsFiniteNonNegativeNumber","require$$0","pair","container","_queue","shift","_queueTotalSize","push","CreateAlgorithmFromUnderlyingMethod","require$$1","InvokeOrNoop","ValidateAndNormalizeHighWaterMark","MakeSizeAlgorithmFromSizeFunction","typeIsObject","rethrowAssertionErrorRejection","require$$2","DequeueValue","require$$3","EnqueueValueWithSize","PeekQueueValue","ResetQueue","AbortSteps","ErrorSteps","WritableStream","underlyingSink","strategy","this","type","sizeAlgorithm","stream","controller","Object","create","WritableStreamDefaultController","writeAlgorithm","closeAlgorithm","abortAlgorithm","abort","reason","IsWritableStream","streamBrandCheckException","IsWritableStreamLocked","WritableStreamAbort","getWriter","AcquireWritableStreamDefaultWriter","startAlgorithm","writer","_ownerWritableStream","state","_state","WritableStreamCloseQueuedOrInFlight","_storedError","WritableStreamDefaultWriterClose","WritableStreamDefaultWriter","InitializeWritableStream","_writer","_writableStreamController","_writeRequests","_inFlightWriteRequest","_closeRequest","_inFlightCloseRequest","_pendingAbortRequest","_backpressure","hasOwnProperty","_promise","wasAlreadyErroring","promise","WritableStreamDealWithRejection","error","WritableStreamStartErroring","WritableStreamHasOperationMarkedInFlight","_started","WritableStreamFinishErroring","storedError","_reject","abortRequest","_wasAlreadyErroring","_reason","then","_resolve","WritableStreamFinishInFlightClose","_closedPromise_resolve","_closedPromise_reject","_closedPromiseState","WritableStreamRejectCloseAndClosedPromiseIfNeeded","_closedPromise","catch","WritableStreamUpdateBackpressure","backpressure","_readyPromise","_readyPromise_resolve","_readyPromise_reject","_readyPromiseState","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","defaultWriterLockException","WritableStreamDefaultWriterAbort","close","releaseLock","write","WritableStreamDefaultWriterWrite","WritableStreamDefaultControllerGetDesiredSize","WritableStreamDefaultWriterGetDesiredSize","closeRequest","WritableStreamDefaultWriterEnsureClosedPromiseRejected","WritableStreamDefaultWriterEnsureReadyPromiseRejected","WritableStreamDefaultWriterRelease","releasedError","chunkSize","_strategySizeAlgorithm","chunkSizeE","WritableStreamDefaultControllerGetChunkSize","writeRequest","WritableStreamAddWriteRequest","writeRecord","enqueueE","_controlledWritableStream","WritableStreamDefaultControllerGetBackpressure","IsWritableStreamDefaultController","result","_abortAlgorithm","SetUpWritableStreamDefaultController","_strategyHWM","_writeAlgorithm","_closeAlgorithm","startResult","r","WritableStreamDefaultControllerClearAlgorithms","WritableStreamDefaultControllerAdvanceQueueIfNeeded","length","sinkClosePromise","WritableStreamDefaultControllerErrorIfNeeded","WritableStreamDefaultControllerError","name","defaultWriterClosedPromiseInitialize","defaultWriterClosedPromiseReject","defaultWriterReadyPromiseInitializeAsRejected","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterReadyPromiseResolve","ArrayBufferCopy","IsDetachedBuffer","TransferArrayBuffer","createArrayFromList","WritableStreamDefaultWriterCloseWithErrorPropagation","CancelSteps","PullSteps","ReadableStream","underlyingSource","String","underlyingByteSource","ReadableByteStreamController","pullAlgorithm","cancelAlgorithm","autoAllocateChunkSize","Number.isInteger","ReadableStreamDefaultController","cancel","IsReadableStream","IsReadableStreamLocked","ReadableStreamCancel","getReader","mode","AcquireReadableStreamDefaultReader","ReadableStreamBYOBReader","AcquireReadableStreamBYOBReader","pipeThrough","options","writable","readable","pipeTo","preventClose","preventAbort","preventCancel","Boolean","reader","shuttingDown","currentWrite","_this","action","destClosed","waitForWritesToFinish","oldCurrentWrite","isOrBecomesErrored","shutdownWithAction","originalIsError","originalError","doTheRest","finalize","newError","shutdown","isError","pipeLoop","ReadableStreamDefaultReaderRead","done","err","tee","branches","cloneForBranch2","reason1","reason2","branch1","branch2","resolveCancelPromise","closedOrErrored","canceled1","canceled2","cancelPromise","_readableStreamController","value1","value2","CreateReadableStream","compositeReason","cancelResult","ReadableStreamTee","_disturbed","ReadableStreamDefaultControllerShouldCallPull","ReadableStreamDefaultReader","InitializeReadableStream","_reader","ReadableStreamAddReadIntoRequest","forAuthorCode","readIntoRequest","_readIntoRequests","ReadableStreamAddReadRequest","readRequest","_readRequests","ReadableStreamClose","IsReadableStreamDefaultReader","ReadableStreamCreateReadResult","_forAuthorCode","obj","ReadableStreamError","ReadableStreamFulfillReadRequest","ReadableStreamGetNumReadIntoRequests","ReadableStreamGetNumReadRequests","ReadableStreamHasBYOBReader","IsReadableStreamBYOBReader","ReadableStreamHasDefaultReader","defaultReaderBrandCheckException","_ownerReadableStream","readerLockException","ReadableStreamReaderGenericCancel","read","IsReadableByteStreamController","byobReaderBrandCheckException","view","ArrayBuffer","isView","buffer","byteLength","_controlledReadableByteStream","elementSize","constructor","DataView","BYTES_PER_ELEMENT","ctor","pullIntoDescriptor","byteOffset","_pendingPullIntos","emptyView","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","_closeRequested","ReadableByteStreamControllerPullInto","ReadableStreamBYOBReaderRead","ReadableStreamReaderGenericInitialize","ReadableStreamReaderGenericRelease","IsReadableStreamDefaultController","defaultControllerBrandCheckException","ReadableStreamDefaultControllerCanCloseOrEnqueue","enqueue","ReadableStreamDefaultControllerEnqueue","_cancelAlgorithm","_controlledReadableStream","pendingPromise","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerCallPullIfNeeded","_pulling","_pullAlgorithm","_pullAgain","ReadableStreamDefaultControllerClearAlgorithms","ReadableStreamDefaultControllerClose","ReadableStreamDefaultControllerError","SetUpReadableStreamDefaultController","ReadableStreamBYOBRequest","respond","bytesWritten","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","_associatedReadableByteStreamController","_view","respondWithNewView","firstDescriptor","bytesFilled","byteStreamControllerBrandCheckException","firstPendingPullInto","transferredBuffer","transferredView","entry","viewE","_autoAllocateChunkSize","bufferE","_byobRequest","byobRequest","request","ReadableByteStreamControllerGetDesiredSize","ReadableByteStreamControllerCallPullIfNeeded","ReadableByteStreamControllerShouldCallPull","ReadableByteStreamControllerClearPendingPullIntos","ReadableByteStreamControllerCommitPullIntoDescriptor","readerType","ReadableByteStreamControllerEnqueueChunkToQueue","currentAlignedBytes","maxBytesToCopy","min","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","ready","queue","headOfQueue","bytesToCopy","destStart","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableByteStreamControllerHandleQueueDrain","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","ReadableByteStreamControllerRespondInternal","ReadableByteStreamControllerShiftPendingPullInto","remainderSize","end","remainder","descriptor","ReadableByteStreamControllerClearAlgorithms","ReadableByteStreamControllerError","SetUpReadableByteStreamController","defaultReaderClosedPromiseReject","createDataProperty","ReadableStreamDefaultControllerHasBackpressure","CreateWritableStream","TransformStream","transformer","writableStrategy","readableStrategy","writableSizeFunction","writableHighWaterMark","readableSizeFunction","readableHighWaterMark","writableType","writableSizeAlgorithm","readableType","startPromise_resolve","readableSizeAlgorithm","TransformStreamDefaultController","transformAlgorithm","transformResultE","transformMethod","transform","flushAlgorithm","_transformStreamController","IsTransformStream","_readable","_writable","InitializeTransformStream","startPromise","backpressureChangePromise","_backpressureChangePromise","TransformStreamDefaultControllerPerformTransform","TransformStreamDefaultSinkWriteAlgorithm","flushPromise","_flushAlgorithm","readableController","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamDefaultSinkAbortAlgorithm","TransformStreamDefaultSourcePullAlgorithm","_backpressureChangePromise_resolve","TransformStreamError","TransformStreamErrorWritableAndUnblockWrite","TransformStreamSetBackpressure","IsTransformStreamDefaultController","_controlledTransformStream","terminate","SetUpTransformStreamDefaultController","_transformAlgorithm","TransformStreamDefaultControllerClearAlgorithms","TransformStreamDefaultControllerEnqueue"],"mappings":"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"}