{"version":3,"file":"ponyfill.es6.min.js","sources":["../src/stub/number-isinteger.js","../src/stub/symbol.js","../src/utils.js","../src/stub/number-isnan.js","../spec/reference-implementation/lib/helpers.js","../src/stub/assert.js","../spec/reference-implementation/lib/utils.js","../spec/reference-implementation/lib/queue-with-sizes.js","../spec/reference-implementation/lib/writable-stream.js","../spec/reference-implementation/lib/readable-stream.js","../spec/reference-implementation/lib/byte-length-queuing-strategy.js","../spec/reference-implementation/lib/count-queuing-strategy.js","../spec/reference-implementation/lib/transform-stream.js"],"sourcesContent":["// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger#Polyfill\nconst NumberIsInteger = Number.isInteger || function (value) {\n  return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\nexport default NumberIsInteger;\n","const SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n  Symbol :\n  description => `Symbol(${description})`;\n\nexport default SymbolPolyfill;\n","export function noop() {\n  // do nothing\n}\n\nfunction getGlobals() {\n  /* global self, window, global */\n  if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  }\n  return undefined;\n}\n\nexport const globals = getGlobals();\n","// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN = Number.isNaN || function (x) {\n  // eslint-disable-next-line no-self-compare\n  return x !== x;\n};\n\nexport default NumberIsNaN;\n","'use strict';\nconst assert = require('better-assert');\n\nconst isFakeDetached = Symbol('is \"detached\" for our purposes');\n\nfunction IsPropertyKey(argument) {\n  return typeof argument === 'string' || typeof argument === 'symbol';\n}\n\nexports.typeIsObject = x => (typeof x === 'object' && x !== null) || typeof x === 'function';\n\nexports.createDataProperty = (o, p, v) => {\n  assert(exports.typeIsObject(o));\n  Object.defineProperty(o, p, { value: v, writable: true, enumerable: true, configurable: true });\n};\n\nexports.createArrayFromList = elements => {\n  // We use arrays to represent lists, so this is basically a no-op.\n  // Do a slice though just in case we happen to depend on the unique-ness.\n  return elements.slice();\n};\n\nexports.ArrayBufferCopy = (dest, destOffset, src, srcOffset, n) => {\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n};\n\nexports.IsFiniteNonNegativeNumber = v => {\n  if (exports.IsNonNegativeNumber(v) === false) {\n    return false;\n  }\n\n  if (v === Infinity) {\n    return false;\n  }\n\n  return true;\n};\n\nexports.IsNonNegativeNumber = v => {\n  if (typeof v !== 'number') {\n    return false;\n  }\n\n  if (Number.isNaN(v)) {\n    return false;\n  }\n\n  if (v < 0) {\n    return false;\n  }\n\n  return true;\n};\n\nfunction Call(F, V, args) {\n  if (typeof F !== 'function') {\n    throw new TypeError('Argument is not a function');\n  }\n\n  return Function.prototype.apply.call(F, V, args);\n}\n\nexports.Call = Call;\n\nexports.CreateAlgorithmFromUnderlyingMethod = (underlyingObject, methodName, algoArgCount, extraArgs) => {\n  assert(underlyingObject !== undefined);\n  assert(IsPropertyKey(methodName));\n  assert(algoArgCount === 0 || algoArgCount === 1);\n  assert(Array.isArray(extraArgs));\n  const method = underlyingObject[methodName];\n  if (method !== undefined) {\n    if (typeof method !== 'function') {\n      throw new TypeError(`${method} is not a method`);\n    }\n    switch (algoArgCount) {\n      case 0: {\n        return () => {\n          return PromiseCall(method, underlyingObject, extraArgs);\n        };\n      }\n\n      case 1: {\n        return arg => {\n          const fullArgs = [arg].concat(extraArgs);\n          return PromiseCall(method, underlyingObject, fullArgs);\n        };\n      }\n    }\n  }\n  return () => Promise.resolve();\n};\n\nexports.InvokeOrNoop = (O, P, args) => {\n  assert(O !== undefined);\n  assert(IsPropertyKey(P));\n  assert(Array.isArray(args));\n\n  const method = O[P];\n  if (method === undefined) {\n    return undefined;\n  }\n\n  return Call(method, O, args);\n};\n\nfunction PromiseCall(F, V, args) {\n  assert(typeof F === 'function');\n  assert(V !== undefined);\n  assert(Array.isArray(args));\n  try {\n    return Promise.resolve(Call(F, V, args));\n  } catch (value) {\n    return Promise.reject(value);\n  }\n}\n\nexports.PromiseCall = PromiseCall;\n\n// Not implemented correctly\nexports.TransferArrayBuffer = O => {\n  assert(!exports.IsDetachedBuffer(O));\n  const transferredIshVersion = O.slice();\n\n  // This is specifically to fool tests that test \"is transferred\" by taking a non-zero-length\n  // ArrayBuffer and checking if its byteLength starts returning 0.\n  Object.defineProperty(O, 'byteLength', {\n    get() {\n      return 0;\n    }\n  });\n  O[isFakeDetached] = true;\n\n  return transferredIshVersion;\n};\n\n// Not implemented correctly\nexports.IsDetachedBuffer = O => {\n  return isFakeDetached in O;\n};\n\nexports.ValidateAndNormalizeHighWaterMark = highWaterMark => {\n  highWaterMark = Number(highWaterMark);\n  if (Number.isNaN(highWaterMark) || highWaterMark < 0) {\n    throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');\n  }\n\n  return highWaterMark;\n};\n\nexports.MakeSizeAlgorithmFromSizeFunction = size => {\n  if (size === undefined) {\n    return () => 1;\n  }\n  if (typeof size !== 'function') {\n    throw new TypeError('size property of a queuing strategy must be a function');\n  }\n  return chunk => size(chunk);\n};\n","import { noop } from '../utils';\n\nexport default function assert() {\n  // do nothing\n}\n\nassert.AssertionError = noop;\n","'use strict';\nconst assert = require('assert');\n\nexports.rethrowAssertionErrorRejection = e => {\n  // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\n  // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\n  // expect any errors, but assertion errors are always problematic.\n  if (e && e instanceof assert.AssertionError) {\n    setTimeout(() => {\n      throw e;\n    }, 0);\n  }\n};\n","'use strict';\nconst assert = require('better-assert');\nconst { IsFiniteNonNegativeNumber } = require('./helpers.js');\n\nexports.DequeueValue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.shift();\n  container._queueTotalSize -= pair.size;\n  if (container._queueTotalSize < 0) {\n    container._queueTotalSize = 0;\n  }\n\n  return pair.value;\n};\n\nexports.EnqueueValueWithSize = (container, value, size) => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  size = Number(size);\n  if (!IsFiniteNonNegativeNumber(size)) {\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n\n  container._queue.push({ value, size });\n  container._queueTotalSize += size;\n};\n\nexports.PeekQueueValue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue[0];\n  return pair.value;\n};\n\nexports.ResetQueue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  container._queue = [];\n  container._queueTotalSize = 0;\n};\n","'use strict';\nconst assert = require('better-assert');\n\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\n// and do not appear in the standard text.\nconst verbose = require('debug')('streams:writable-stream:verbose');\n\nconst { CreateAlgorithmFromUnderlyingMethod, InvokeOrNoop, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction, typeIsObject } = require('./helpers.js');\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\nconst { DequeueValue, EnqueueValueWithSize, PeekQueueValue, ResetQueue } = require('./queue-with-sizes.js');\n\nconst AbortSteps = Symbol('[[AbortSteps]]');\nconst ErrorSteps = Symbol('[[ErrorSteps]]');\n\nclass WritableStream {\n  constructor(underlyingSink = {}, strategy = {}) {\n    InitializeWritableStream(this);\n\n    const size = strategy.size;\n    let highWaterMark = strategy.highWaterMark;\n\n    const type = underlyingSink.type;\n\n    if (type !== undefined) {\n      throw new RangeError('Invalid type is specified');\n    }\n\n    const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n    if (highWaterMark === undefined) {\n      highWaterMark = 1;\n    }\n    highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n  }\n\n  get locked() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsWritableStreamLocked(this);\n  }\n\n  abort(reason) {\n    if (IsWritableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('abort'));\n    }\n\n    if (IsWritableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot abort a stream that already has a writer'));\n    }\n\n    return WritableStreamAbort(this, reason);\n  }\n\n  getWriter() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException('getWriter');\n    }\n\n    return AcquireWritableStreamDefaultWriter(this);\n  }\n}\n\nmodule.exports = {\n  AcquireWritableStreamDefaultWriter,\n  CreateWritableStream,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamDefaultControllerErrorIfNeeded,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite,\n  WritableStreamCloseQueuedOrInFlight\n};\n\n// Abstract operations for the WritableStream.\n\nfunction AcquireWritableStreamDefaultWriter(stream) {\n  return new WritableStreamDefaultWriter(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1,\n                              sizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n\n  const stream = Object.create(WritableStream.prototype);\n  InitializeWritableStream(stream);\n\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n}\n\nfunction InitializeWritableStream(stream) {\n  stream._state = 'writable';\n\n  // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n  // 'erroring' or 'errored'. May be set to an undefined value.\n  stream._storedError = undefined;\n\n  stream._writer = undefined;\n\n  // Initialize to undefined first because the constructor of the controller checks this\n  // variable to validate the caller.\n  stream._writableStreamController = undefined;\n\n  // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  // producer without waiting for the queued writes to finish.\n  stream._writeRequests = [];\n\n  // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  stream._inFlightWriteRequest = undefined;\n\n  // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  // has been detached.\n  stream._closeRequest = undefined;\n\n  // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n  stream._inFlightCloseRequest = undefined;\n\n  // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n  stream._pendingAbortRequest = undefined;\n\n  // The backpressure signal set by the controller.\n  stream._backpressure = false;\n}\n\nfunction IsWritableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsWritableStreamLocked(stream) {\n  assert(IsWritableStream(stream) === true);\n\n  if (stream._writer === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamAbort(stream, reason) {\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return Promise.resolve(undefined);\n  }\n  if (stream._pendingAbortRequest !== undefined) {\n    return stream._pendingAbortRequest._promise;\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  let wasAlreadyErroring = false;\n  if (state === 'erroring') {\n    wasAlreadyErroring = true;\n    // reason will not be used, so don't keep a reference to it.\n    reason = undefined;\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    stream._pendingAbortRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _reason: reason,\n      _wasAlreadyErroring: wasAlreadyErroring\n    };\n  });\n  stream._pendingAbortRequest._promise = promise;\n\n  if (wasAlreadyErroring === false) {\n    WritableStreamStartErroring(stream, reason);\n  }\n\n  return promise;\n}\n\n// WritableStream API exposed for controllers.\n\nfunction WritableStreamAddWriteRequest(stream) {\n  assert(IsWritableStreamLocked(stream) === true);\n  assert(stream._state === 'writable');\n\n  const promise = new Promise((resolve, reject) => {\n    const writeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._writeRequests.push(writeRequest);\n  });\n\n  return promise;\n}\n\nfunction WritableStreamDealWithRejection(stream, error) {\n  verbose('WritableStreamDealWithRejection(stream, %o)', error);\n  const state = stream._state;\n\n  if (state === 'writable') {\n    WritableStreamStartErroring(stream, error);\n    return;\n  }\n\n  assert(state === 'erroring');\n  WritableStreamFinishErroring(stream);\n}\n\nfunction WritableStreamStartErroring(stream, reason) {\n  verbose('WritableStreamStartErroring(stream, %o)', reason);\n  assert(stream._storedError === undefined);\n  assert(stream._state === 'writable');\n\n  const controller = stream._writableStreamController;\n  assert(controller !== undefined);\n\n  stream._state = 'erroring';\n  stream._storedError = reason;\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n\n  if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {\n    WritableStreamFinishErroring(stream);\n  }\n}\n\nfunction WritableStreamFinishErroring(stream) {\n  verbose('WritableStreamFinishErroring()');\n  assert(stream._state === 'erroring');\n  assert(WritableStreamHasOperationMarkedInFlight(stream) === false);\n  stream._state = 'errored';\n  stream._writableStreamController[ErrorSteps]();\n\n  const storedError = stream._storedError;\n  for (const writeRequest of stream._writeRequests) {\n    writeRequest._reject(storedError);\n  }\n  stream._writeRequests = [];\n\n  if (stream._pendingAbortRequest === undefined) {\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const abortRequest = stream._pendingAbortRequest;\n  stream._pendingAbortRequest = undefined;\n\n  if (abortRequest._wasAlreadyErroring === true) {\n    abortRequest._reject(storedError);\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n  promise.then(\n      () => {\n        abortRequest._resolve();\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      },\n      reason => {\n        abortRequest._reject(reason);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      });\n}\n\nfunction WritableStreamFinishInFlightWrite(stream) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest._resolve(undefined);\n  stream._inFlightWriteRequest = undefined;\n}\n\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest._reject(error);\n  stream._inFlightWriteRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  WritableStreamDealWithRejection(stream, error);\n}\n\nfunction WritableStreamFinishInFlightClose(stream) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest._resolve(undefined);\n  stream._inFlightCloseRequest = undefined;\n\n  const state = stream._state;\n\n  assert(state === 'writable' || state === 'erroring');\n\n  if (state === 'erroring') {\n    // The error was too late to do anything, so it is ignored.\n    stream._storedError = undefined;\n    if (stream._pendingAbortRequest !== undefined) {\n      stream._pendingAbortRequest._resolve();\n      stream._pendingAbortRequest = undefined;\n    }\n  }\n\n  stream._state = 'closed';\n\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseResolve(writer);\n  }\n\n  assert(stream._pendingAbortRequest === undefined);\n  assert(stream._storedError === undefined);\n}\n\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest._reject(error);\n  stream._inFlightCloseRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  // Never execute sink abort() after sink close().\n  if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._reject(error);\n    stream._pendingAbortRequest = undefined;\n  }\n  WritableStreamDealWithRejection(stream, error);\n}\n\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    verbose('WritableStreamHasOperationMarkedInFlight() is false');\n    return false;\n  }\n\n  verbose('WritableStreamHasOperationMarkedInFlight() is true');\n  return true;\n}\n\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\n  assert(stream._inFlightCloseRequest === undefined);\n  assert(stream._closeRequest !== undefined);\n  stream._inFlightCloseRequest = stream._closeRequest;\n  stream._closeRequest = undefined;\n}\n\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\n  assert(stream._inFlightWriteRequest === undefined);\n  assert(stream._writeRequests.length !== 0);\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\n\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n  verbose('WritableStreamRejectCloseAndClosedPromiseIfNeeded()');\n  assert(stream._state === 'errored');\n  if (stream._closeRequest !== undefined) {\n    assert(stream._inFlightCloseRequest === undefined);\n\n    stream._closeRequest._reject(stream._storedError);\n    stream._closeRequest = undefined;\n  }\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\n    writer._closedPromise.catch(() => {});\n  }\n}\n\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\n  assert(stream._state === 'writable');\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\n\n  const writer = stream._writer;\n  if (writer !== undefined && backpressure !== stream._backpressure) {\n    if (backpressure === true) {\n      defaultWriterReadyPromiseReset(writer);\n    } else {\n      assert(backpressure === false);\n\n      defaultWriterReadyPromiseResolve(writer);\n    }\n  }\n\n  stream._backpressure = backpressure;\n}\n\nclass WritableStreamDefaultWriter {\n  constructor(stream) {\n    if (IsWritableStream(stream) === false) {\n      throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');\n    }\n    if (IsWritableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n    }\n\n    this._ownerWritableStream = stream;\n    stream._writer = this;\n\n    const state = stream._state;\n\n    if (state === 'writable') {\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {\n        defaultWriterReadyPromiseInitialize(this);\n      } else {\n        defaultWriterReadyPromiseInitializeAsResolved(this);\n      }\n\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'erroring') {\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n      this._readyPromise.catch(() => {});\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'closed') {\n      defaultWriterReadyPromiseInitializeAsResolved(this);\n      defaultWriterClosedPromiseInitializeAsResolved(this);\n    } else {\n      assert(state === 'errored');\n\n      const storedError = stream._storedError;\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n      this._readyPromise.catch(() => {});\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n      this._closedPromise.catch(() => {});\n    }\n  }\n\n  get closed() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  get desiredSize() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException('desiredSize');\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      throw defaultWriterLockException('desiredSize');\n    }\n\n    return WritableStreamDefaultWriterGetDesiredSize(this);\n  }\n\n  get ready() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('ready'));\n    }\n\n    return this._readyPromise;\n  }\n\n  abort(reason) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('abort'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return Promise.reject(defaultWriterLockException('abort'));\n    }\n\n    return WritableStreamDefaultWriterAbort(this, reason);\n  }\n\n  close() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('close'));\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return Promise.reject(defaultWriterLockException('close'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true) {\n      return Promise.reject(new TypeError('cannot close an already-closing stream'));\n    }\n\n    return WritableStreamDefaultWriterClose(this);\n  }\n\n  releaseLock() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException('releaseLock');\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return;\n    }\n\n    assert(stream._writer !== undefined);\n\n    WritableStreamDefaultWriterRelease(this);\n  }\n\n  write(chunk) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('write'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return Promise.reject(defaultWriterLockException('write to'));\n    }\n\n    return WritableStreamDefaultWriterWrite(this, chunk);\n  }\n}\n\n// Abstract operations for the WritableStreamDefaultWriter.\n\nfunction IsWritableStreamDefaultWriter(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamAbort(stream, reason);\n}\n\nfunction WritableStreamDefaultWriterClose(writer) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return Promise.reject(new TypeError(\n      `The stream (in ${state} state) is not in the writable state and cannot be closed`));\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\n\n  const promise = new Promise((resolve, reject) => {\n    const closeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._closeRequest = closeRequest;\n  });\n\n  if (stream._backpressure === true && state === 'writable') {\n    defaultWriterReadyPromiseResolve(writer);\n  }\n\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n\n  return promise;\n}\n\n\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n    return Promise.resolve();\n  }\n\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  return WritableStreamDefaultWriterClose(writer);\n}\n\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n  if (writer._closedPromiseState === 'pending') {\n    defaultWriterClosedPromiseReject(writer, error);\n  } else {\n    defaultWriterClosedPromiseResetToRejected(writer, error);\n  }\n  writer._closedPromise.catch(() => {});\n}\n\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n  verbose('WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, %o)', error);\n  if (writer._readyPromiseState === 'pending') {\n    defaultWriterReadyPromiseReject(writer, error);\n  } else {\n    defaultWriterReadyPromiseResetToRejected(writer, error);\n  }\n  writer._readyPromise.catch(() => {});\n}\n\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\n  const stream = writer._ownerWritableStream;\n  const state = stream._state;\n\n  if (state === 'errored' || state === 'erroring') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\n\nfunction WritableStreamDefaultWriterRelease(writer) {\n  const stream = writer._ownerWritableStream;\n  assert(stream !== undefined);\n  assert(stream._writer === writer);\n\n  const releasedError = new TypeError(\n    'Writer was released and can no longer be used to monitor the stream\\'s closedness');\n\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n\n  // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  // rejected until afterwards. This means that simply testing state will not work.\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined;\n}\n\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const controller = stream._writableStreamController;\n\n  const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n\n  if (stream !== writer._ownerWritableStream) {\n    return Promise.reject(defaultWriterLockException('write to'));\n  }\n\n  const state = stream._state;\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n    return Promise.reject(new TypeError('The stream is closing or closed and cannot be written to'));\n  }\n  if (state === 'erroring') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(state === 'writable');\n\n  const promise = WritableStreamAddWriteRequest(stream);\n\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n\n  return promise;\n}\n\nclass WritableStreamDefaultController {\n  constructor() {\n    throw new TypeError('WritableStreamDefaultController cannot be constructed explicitly');\n  }\n\n  error(e) {\n    if (IsWritableStreamDefaultController(this) === false) {\n      throw new TypeError(\n        'WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\n    }\n    const state = this._controlledWritableStream._state;\n    if (state !== 'writable') {\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n      // just treat it as a no-op.\n      return;\n    }\n\n    WritableStreamDefaultControllerError(this, e);\n  }\n\n  [AbortSteps](reason) {\n    const result = this._abortAlgorithm(reason);\n    WritableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  [ErrorSteps]() {\n    ResetQueue(this);\n  }\n}\n\n// Abstract operations implementing interface required by the WritableStream.\n\nfunction IsWritableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                              abortAlgorithm, highWaterMark, sizeAlgorithm) {\n  assert(IsWritableStream(stream) === true);\n  assert(stream._writableStreamController === undefined);\n\n  controller._controlledWritableStream = stream;\n  stream._writableStreamController = controller;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._started = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._writeAlgorithm = writeAlgorithm;\n  controller._closeAlgorithm = closeAlgorithm;\n  controller._abortAlgorithm = abortAlgorithm;\n\n  const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n  WritableStreamUpdateBackpressure(stream, backpressure);\n\n  const startResult = startAlgorithm();\n  const startPromise = Promise.resolve(startResult);\n  startPromise.then(\n      () => {\n        assert(stream._state === 'writable' || stream._state === 'erroring');\n        controller._started = true;\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n      },\n      r => {\n        assert(stream._state === 'writable' || stream._state === 'erroring');\n        controller._started = true;\n        WritableStreamDealWithRejection(stream, r);\n      }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n  assert(underlyingSink !== undefined);\n\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingSink, 'start', [controller]);\n  }\n\n  const writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'write', 1, [controller]);\n  const closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'close', 0, []);\n  const abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'abort', 1, []);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n}\n\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller) {\n  controller._writeAlgorithm = undefined;\n  controller._closeAlgorithm = undefined;\n  controller._abortAlgorithm = undefined;\n  controller._strategySizeAlgorithm = undefined;\n}\n\nfunction WritableStreamDefaultControllerClose(controller) {\n  EnqueueValueWithSize(controller, 'close', 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n  try {\n    return controller._strategySizeAlgorithm(chunk);\n  } catch (chunkSizeE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n    return 1;\n  }\n}\n\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n  const writeRecord = { chunk };\n\n  try {\n    EnqueueValueWithSize(controller, writeRecord, chunkSize);\n  } catch (enqueueE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n    return;\n  }\n\n  const stream = controller._controlledWritableStream;\n  if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n  }\n\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\n// Abstract operations for the WritableStreamDefaultController.\n\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n  verbose('WritableStreamDefaultControllerAdvanceQueueIfNeeded()');\n  const stream = controller._controlledWritableStream;\n\n  if (controller._started === false) {\n    return;\n  }\n\n  if (stream._inFlightWriteRequest !== undefined) {\n    return;\n  }\n\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return;\n  }\n  if (state === 'erroring') {\n    WritableStreamFinishErroring(stream);\n    return;\n  }\n\n  if (controller._queue.length === 0) {\n    return;\n  }\n\n  const writeRecord = PeekQueueValue(controller);\n  if (writeRecord === 'close') {\n    WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n    WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);\n  }\n}\n\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n  if (controller._controlledWritableStream._state === 'writable') {\n    WritableStreamDefaultControllerError(controller, error);\n  }\n}\n\nfunction WritableStreamDefaultControllerProcessClose(controller) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkCloseRequestInFlight(stream);\n\n  DequeueValue(controller);\n  assert(controller._queue.length === 0);\n\n  const sinkClosePromise = controller._closeAlgorithm();\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  sinkClosePromise.then(\n    () => {\n      WritableStreamFinishInFlightClose(stream);\n    },\n    reason => {\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\n\n  const sinkWritePromise = controller._writeAlgorithm(chunk);\n  sinkWritePromise.then(\n    () => {\n      WritableStreamFinishInFlightWrite(stream);\n\n      const state = stream._state;\n      assert(state === 'writable' || state === 'erroring');\n\n      DequeueValue(controller);\n\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n      }\n\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    },\n    reason => {\n      if (stream._state === 'writable') {\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n      }\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n}\n\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultControllerError(controller, error) {\n  const stream = controller._controlledWritableStream;\n\n  assert(stream._state === 'writable');\n\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  WritableStreamStartErroring(stream, error);\n}\n\n// Helper functions for the WritableStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n\n// Helper functions for the WritableStreamDefaultWriter.\n\nfunction defaultWriterBrandCheckException(name) {\n  return new TypeError(\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\n\nfunction defaultWriterLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\n\nfunction defaultWriterClosedPromiseInitialize(writer) {\n  writer._closedPromise = new Promise((resolve, reject) => {\n    writer._closedPromise_resolve = resolve;\n    writer._closedPromise_reject = reject;\n    writer._closedPromiseState = 'pending';\n  });\n}\n\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n  writer._closedPromise = Promise.reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\n  writer._closedPromise = Promise.resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterClosedPromiseReject(writer, reason) {\n  assert(writer._closedPromise_resolve !== undefined);\n  assert(writer._closedPromise_reject !== undefined);\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\n  assert(writer._closedPromise_resolve === undefined);\n  assert(writer._closedPromise_reject === undefined);\n  assert(writer._closedPromiseState !== 'pending');\n\n  writer._closedPromise = Promise.reject(reason);\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResolve(writer) {\n  assert(writer._closedPromise_resolve !== undefined);\n  assert(writer._closedPromise_reject !== undefined);\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterReadyPromiseInitialize(writer) {\n  verbose('defaultWriterReadyPromiseInitialize()');\n  writer._readyPromise = new Promise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n  verbose('defaultWriterReadyPromiseInitializeAsRejected(writer, %o)', reason);\n  writer._readyPromise = Promise.reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\n  verbose('defaultWriterReadyPromiseInitializeAsResolved()');\n  writer._readyPromise = Promise.resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n\nfunction defaultWriterReadyPromiseReject(writer, reason) {\n  verbose('defaultWriterReadyPromiseReject(writer, %o)', reason);\n  assert(writer._readyPromise_resolve !== undefined);\n  assert(writer._readyPromise_reject !== undefined);\n\n  writer._readyPromise_reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseReset(writer) {\n  verbose('defaultWriterReadyPromiseReset()');\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  writer._readyPromise = new Promise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\n  verbose('defaultWriterReadyPromiseResetToRejected(writer, %o)', reason);\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  writer._readyPromise = Promise.reject(reason);\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseResolve(writer) {\n  verbose('defaultWriterReadyPromiseResolve()');\n  assert(writer._readyPromise_resolve !== undefined);\n  assert(writer._readyPromise_reject !== undefined);\n\n  writer._readyPromise_resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n","'use strict';\nconst assert = require('better-assert');\nconst { ArrayBufferCopy, CreateAlgorithmFromUnderlyingMethod, IsFiniteNonNegativeNumber, InvokeOrNoop,\n        IsDetachedBuffer, TransferArrayBuffer, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction, createArrayFromList, typeIsObject } = require('./helpers.js');\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\nconst { DequeueValue, EnqueueValueWithSize, ResetQueue } = require('./queue-with-sizes.js');\nconst { AcquireWritableStreamDefaultWriter, IsWritableStream, IsWritableStreamLocked,\n        WritableStreamAbort, WritableStreamDefaultWriterCloseWithErrorPropagation,\n        WritableStreamDefaultWriterRelease, WritableStreamDefaultWriterWrite, WritableStreamCloseQueuedOrInFlight } =\n      require('./writable-stream.js');\n\nconst CancelSteps = Symbol('[[CancelSteps]]');\nconst PullSteps = Symbol('[[PullSteps]]');\n\nclass ReadableStream {\n  constructor(underlyingSource = {}, strategy = {}) {\n    InitializeReadableStream(this);\n\n    const size = strategy.size;\n    let highWaterMark = strategy.highWaterMark;\n\n    const type = underlyingSource.type;\n    const typeString = String(type);\n    if (typeString === 'bytes') {\n      if (size !== undefined) {\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\n      }\n\n      if (highWaterMark === undefined) {\n        highWaterMark = 0;\n      }\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n      SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n    } else if (type === undefined) {\n      const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n\n      if (highWaterMark === undefined) {\n        highWaterMark = 1;\n      }\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n    } else {\n      throw new RangeError('Invalid type is specified');\n    }\n  }\n\n  get locked() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsReadableStreamLocked(this);\n  }\n\n  cancel(reason) {\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('cancel'));\n    }\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));\n    }\n\n    return ReadableStreamCancel(this, reason);\n  }\n\n  getReader({ mode } = {}) {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('getReader');\n    }\n\n    if (mode === undefined) {\n      return AcquireReadableStreamDefaultReader(this);\n    }\n\n    mode = String(mode);\n\n    if (mode === 'byob') {\n      return AcquireReadableStreamBYOBReader(this);\n    }\n\n    throw new RangeError('Invalid mode is specified');\n  }\n\n  pipeThrough({ writable, readable }, options) {\n    if (writable === undefined || readable === undefined) {\n      throw new TypeError('readable and writable arguments must be defined');\n    }\n\n    const promise = this.pipeTo(writable, options);\n\n    ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise);\n\n    return readable;\n  }\n\n  pipeTo(dest, { preventClose, preventAbort, preventCancel } = {}) {\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('pipeTo'));\n    }\n    if (IsWritableStream(dest) === false) {\n      return Promise.reject(\n        new TypeError('ReadableStream.prototype.pipeTo\\'s first argument must be a WritableStream'));\n    }\n\n    preventClose = Boolean(preventClose);\n    preventAbort = Boolean(preventAbort);\n    preventCancel = Boolean(preventCancel);\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n    }\n    if (IsWritableStreamLocked(dest) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n    }\n\n    const reader = AcquireReadableStreamDefaultReader(this);\n    const writer = AcquireWritableStreamDefaultWriter(dest);\n\n    let shuttingDown = false;\n\n    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n    let currentWrite = Promise.resolve();\n\n    return new Promise((resolve, reject) => {\n      // Using reader and writer, read all chunks from this and write them to dest\n      // - Backpressure must be enforced\n      // - Shutdown must stop all activity\n      function pipeLoop() {\n        if (shuttingDown === true) {\n          return Promise.resolve();\n        }\n\n        return writer._readyPromise.then(() => {\n          return ReadableStreamDefaultReaderRead(reader).then(({ value, done }) => {\n            if (done === true) {\n              return;\n            }\n\n            currentWrite = WritableStreamDefaultWriterWrite(writer, value).catch(() => {});\n          });\n        })\n        .then(pipeLoop);\n      }\n\n      // Errors must be propagated forward\n      isOrBecomesErrored(this, reader._closedPromise, storedError => {\n        if (preventAbort === false) {\n          shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n        } else {\n          shutdown(true, storedError);\n        }\n      });\n\n      // Errors must be propagated backward\n      isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n        if (preventCancel === false) {\n          shutdownWithAction(() => ReadableStreamCancel(this, storedError), true, storedError);\n        } else {\n          shutdown(true, storedError);\n        }\n      });\n\n      // Closing must be propagated forward\n      isOrBecomesClosed(this, reader._closedPromise, () => {\n        if (preventClose === false) {\n          shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n        } else {\n          shutdown();\n        }\n      });\n\n      // Closing must be propagated backward\n      if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === 'closed') {\n        const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n\n        if (preventCancel === false) {\n          shutdownWithAction(() => ReadableStreamCancel(this, destClosed), true, destClosed);\n        } else {\n          shutdown(true, destClosed);\n        }\n      }\n\n      pipeLoop().catch(err => {\n        currentWrite = Promise.resolve();\n        rethrowAssertionErrorRejection(err);\n      });\n\n      function waitForWritesToFinish() {\n        // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n        // for that too.\n        const oldCurrentWrite = currentWrite;\n        return currentWrite.then(() => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n      }\n\n      function isOrBecomesErrored(stream, promise, action) {\n        if (stream._state === 'errored') {\n          action(stream._storedError);\n        } else {\n          promise.catch(action).catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function isOrBecomesClosed(stream, promise, action) {\n        if (stream._state === 'closed') {\n          action();\n        } else {\n          promise.then(action).catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function shutdownWithAction(action, originalIsError, originalError) {\n        if (shuttingDown === true) {\n          return;\n        }\n        shuttingDown = true;\n\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n          waitForWritesToFinish().then(doTheRest);\n        } else {\n          doTheRest();\n        }\n\n        function doTheRest() {\n          action().then(\n            () => finalize(originalIsError, originalError),\n            newError => finalize(true, newError)\n          )\n          .catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function shutdown(isError, error) {\n        if (shuttingDown === true) {\n          return;\n        }\n        shuttingDown = true;\n\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n          waitForWritesToFinish().then(() => finalize(isError, error)).catch(rethrowAssertionErrorRejection);\n        } else {\n          finalize(isError, error);\n        }\n      }\n\n      function finalize(isError, error) {\n        WritableStreamDefaultWriterRelease(writer);\n        ReadableStreamReaderGenericRelease(reader);\n\n        if (isError) {\n          reject(error);\n        } else {\n          resolve(undefined);\n        }\n      }\n    });\n  }\n\n  tee() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('tee');\n    }\n\n    const branches = ReadableStreamTee(this, false);\n    return createArrayFromList(branches);\n  }\n}\n\nmodule.exports = {\n  CreateReadableByteStream,\n  CreateReadableStream,\n  ReadableStream,\n  IsReadableStreamDisturbed,\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError,\n  ReadableStreamDefaultControllerGetDesiredSize,\n  ReadableStreamDefaultControllerHasBackpressure,\n  ReadableStreamDefaultControllerCanCloseOrEnqueue\n};\n\n// Abstract operations for the ReadableStream.\n\nfunction AcquireReadableStreamBYOBReader(stream) {\n  return new ReadableStreamBYOBReader(stream);\n}\n\nfunction AcquireReadableStreamDefaultReader(stream) {\n  return new ReadableStreamDefaultReader(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1,\n                              sizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n\n  const stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\n\n  SetUpReadableStreamDefaultController(\n      stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n\n  return stream;\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 0,\n                                  autoAllocateChunkSize = undefined) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  const stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller = Object.create(ReadableByteStreamController.prototype);\n\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\n                                    autoAllocateChunkSize);\n\n  return stream;\n}\n\nfunction InitializeReadableStream(stream) {\n  stream._state = 'readable';\n  stream._reader = undefined;\n  stream._storedError = undefined;\n  stream._disturbed = false;\n}\n\nfunction IsReadableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDisturbed(stream) {\n  assert(IsReadableStream(stream) === true);\n\n  return stream._disturbed;\n}\n\nfunction IsReadableStreamLocked(stream) {\n  assert(IsReadableStream(stream) === true);\n\n  if (stream._reader === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamTee(stream, cloneForBranch2) {\n  assert(IsReadableStream(stream) === true);\n  assert(typeof cloneForBranch2 === 'boolean');\n\n  const reader = AcquireReadableStreamDefaultReader(stream);\n\n  let closedOrErrored = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1;\n  let reason2;\n  let branch1;\n  let branch2;\n\n  let resolveCancelPromise;\n  const cancelPromise = new Promise(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function pullAlgorithm() {\n    return ReadableStreamDefaultReaderRead(reader).then(result => {\n      assert(typeIsObject(result));\n      const value = result.value;\n      const done = result.done;\n      assert(typeof done === 'boolean');\n\n      if (done === true && closedOrErrored === false) {\n        if (canceled1 === false) {\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n        }\n        if (canceled2 === false) {\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n        }\n        closedOrErrored = true;\n      }\n\n      if (closedOrErrored === true) {\n        return;\n      }\n\n      const value1 = value;\n      const value2 = value;\n\n      // There is no way to access the cloning code right now in the reference implementation.\n      // If we add one then we'll need an implementation for serializable objects.\n      // if (canceled2 === false && cloneForBranch2 === true) {\n      //   value2 = StructuredDeserialize(StructuredSerialize(value2));\n      // }\n\n      if (canceled1 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\n      }\n\n      if (canceled2 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\n      }\n    });\n  }\n\n  function cancel1Algorithm(reason) {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2 === true) {\n      const compositeReason = createArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason) {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1 === true) {\n      const compositeReason = createArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm() {}\n\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n\n  reader._closedPromise.catch(r => {\n    if (closedOrErrored === true) {\n      return;\n    }\n\n    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n    closedOrErrored = true;\n  });\n\n  return [branch1, branch2];\n}\n\n// ReadableStream API exposed for controllers.\n\nfunction ReadableStreamAddReadIntoRequest(stream, forAuthorCode) {\n  assert(IsReadableStreamBYOBReader(stream._reader) === true);\n  assert(stream._state === 'readable' || stream._state === 'closed');\n\n  const promise = new Promise((resolve, reject) => {\n    const readIntoRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _forAuthorCode: forAuthorCode\n    };\n\n    stream._reader._readIntoRequests.push(readIntoRequest);\n  });\n\n  return promise;\n}\n\nfunction ReadableStreamAddReadRequest(stream, forAuthorCode) {\n  assert(IsReadableStreamDefaultReader(stream._reader) === true);\n  assert(stream._state === 'readable');\n\n  const promise = new Promise((resolve, reject) => {\n    const readRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _forAuthorCode: forAuthorCode\n    };\n\n    stream._reader._readRequests.push(readRequest);\n  });\n\n  return promise;\n}\n\nfunction ReadableStreamCancel(stream, reason) {\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(undefined);\n  }\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  ReadableStreamClose(stream);\n\n  const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n  return sourceCancelPromise.then(() => undefined);\n}\n\nfunction ReadableStreamClose(stream) {\n  assert(stream._state === 'readable');\n\n  stream._state = 'closed';\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (const { _resolve, _forAuthorCode } of reader._readRequests) {\n      _resolve(ReadableStreamCreateReadResult(undefined, true, _forAuthorCode));\n    }\n    reader._readRequests = [];\n  }\n\n  defaultReaderClosedPromiseResolve(reader);\n\n  return undefined;\n}\n\nfunction ReadableStreamCreateReadResult(value, done, forAuthorCode) {\n  let prototype = null;\n  if (forAuthorCode === true) {\n    prototype = Object.prototype;\n  }\n  assert(typeof done === 'boolean');\n  const obj = Object.create(prototype);\n  Object.defineProperty(obj, 'value', { value, enumerable: true, writable: true, configurable: true });\n  Object.defineProperty(obj, 'done', { value: done, enumerable: true, writable: true, configurable: true });\n  return obj;\n}\n\nfunction ReadableStreamError(stream, e) {\n  assert(IsReadableStream(stream) === true);\n  assert(stream._state === 'readable');\n\n  stream._state = 'errored';\n  stream._storedError = e;\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (const readRequest of reader._readRequests) {\n      readRequest._reject(e);\n    }\n\n    reader._readRequests = [];\n  } else {\n    assert(IsReadableStreamBYOBReader(reader));\n\n    for (const readIntoRequest of reader._readIntoRequests) {\n      readIntoRequest._reject(e);\n    }\n\n    reader._readIntoRequests = [];\n  }\n\n  defaultReaderClosedPromiseReject(reader, e);\n  reader._closedPromise.catch(() => {});\n}\n\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n  const reader = stream._reader;\n\n  assert(reader._readIntoRequests.length > 0);\n\n  const readIntoRequest = reader._readIntoRequests.shift();\n  readIntoRequest._resolve(ReadableStreamCreateReadResult(chunk, done, readIntoRequest._forAuthorCode));\n}\n\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n  const reader = stream._reader;\n\n  assert(reader._readRequests.length > 0);\n\n  const readRequest = reader._readRequests.shift();\n  readRequest._resolve(ReadableStreamCreateReadResult(chunk, done, readRequest._forAuthorCode));\n}\n\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n  return stream._reader._readIntoRequests.length;\n}\n\nfunction ReadableStreamGetNumReadRequests(stream) {\n  return stream._reader._readRequests.length;\n}\n\nfunction ReadableStreamHasBYOBReader(stream) {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamBYOBReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamHasDefaultReader(stream) {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nclass ReadableStreamDefaultReader {\n  constructor(stream) {\n    if (IsReadableStream(stream) === false) {\n      throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');\n    }\n    if (IsReadableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readRequests = [];\n  }\n\n  get closed() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  cancel(reason) {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  read() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    return ReadableStreamDefaultReaderRead(this, true);\n  }\n\n  releaseLock() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      throw defaultReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\nclass ReadableStreamBYOBReader {\n  constructor(stream) {\n    if (!IsReadableStream(stream)) {\n      throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' +\n          'byte source');\n    }\n    if (IsReadableByteStreamController(stream._readableStreamController) === false) {\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n          'source');\n    }\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readIntoRequests = [];\n  }\n\n  get closed() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  cancel(reason) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  read(view) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      return Promise.reject(new TypeError('view must be an array buffer view'));\n    }\n\n    if (IsDetachedBuffer(view.buffer) === true) {\n      return Promise.reject(new TypeError('Cannot read into a view onto a detached ArrayBuffer'));\n    }\n\n    if (view.byteLength === 0) {\n      return Promise.reject(new TypeError('view must have non-zero byteLength'));\n    }\n\n    return ReadableStreamBYOBReaderRead(this, view, true);\n  }\n\n  releaseLock() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      throw byobReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readIntoRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\n// Abstract operations for the readers.\n\nfunction IsReadableStreamBYOBReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDefaultReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === 'closed') {\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n    assert(stream._state === 'errored');\n\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n    reader._closedPromise.catch(() => {});\n  }\n}\n\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\n\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  return ReadableStreamCancel(stream, reason);\n}\n\nfunction ReadableStreamReaderGenericRelease(reader) {\n  assert(reader._ownerReadableStream !== undefined);\n  assert(reader._ownerReadableStream._reader === reader);\n\n  if (reader._ownerReadableStream._state === 'readable') {\n    defaultReaderClosedPromiseReject(\n        reader,\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  } else {\n    defaultReaderClosedPromiseResetToRejected(\n        reader,\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  }\n  reader._closedPromise.catch(() => {});\n\n  reader._ownerReadableStream._reader = undefined;\n  reader._ownerReadableStream = undefined;\n}\n\nfunction ReadableStreamBYOBReaderRead(reader, view, forAuthorCode = false) {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  // Controllers must implement this.\n  return ReadableByteStreamControllerPullInto(stream._readableStreamController, view, forAuthorCode);\n}\n\nfunction ReadableStreamDefaultReaderRead(reader, forAuthorCode = false) {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(ReadableStreamCreateReadResult(undefined, true, forAuthorCode));\n  }\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(stream._state === 'readable');\n\n  return stream._readableStreamController[PullSteps](forAuthorCode);\n}\n\n// Controllers\n\nclass ReadableStreamDefaultController {\n  constructor() {\n    throw new TypeError();\n  }\n\n  get desiredSize() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('close');\n    }\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError('The stream is not in a state that permits close');\n    }\n\n    ReadableStreamDefaultControllerClose(this);\n  }\n\n  enqueue(chunk) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError('The stream is not in a state that permits enqueue');\n    }\n\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  error(e) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    ReadableStreamDefaultControllerError(this, e);\n  }\n\n  [CancelSteps](reason) {\n    ResetQueue(this);\n    const result = this._cancelAlgorithm(reason);\n    ReadableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  [PullSteps](forAuthorCode) {\n    const stream = this._controlledReadableStream;\n\n    if (this._queue.length > 0) {\n      const chunk = DequeueValue(this);\n\n      if (this._closeRequested === true && this._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        ReadableStreamClose(stream);\n      } else {\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n      }\n\n      return Promise.resolve(ReadableStreamCreateReadResult(chunk, false, forAuthorCode));\n    }\n\n    const pendingPromise = ReadableStreamAddReadRequest(stream, forAuthorCode);\n    ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    return pendingPromise;\n  }\n}\n\n// Abstract operations for the ReadableStreamDefaultController.\n\nfunction IsReadableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  assert(controller._pullAgain === false);\n\n  controller._pulling = true;\n\n  const pullPromise = controller._pullAlgorithm();\n  pullPromise.then(\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        return ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n      return undefined;\n    },\n    e => {\n      ReadableStreamDefaultControllerError(controller, e);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableStream;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller) {\n  controller._pullAlgorithm = undefined;\n  controller._cancelAlgorithm = undefined;\n  controller._strategySizeAlgorithm = undefined;\n}\n\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction ReadableStreamDefaultControllerClose(controller) {\n  const stream = controller._controlledReadableStream;\n\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\n\n  controller._closeRequested = true;\n\n  if (controller._queue.length === 0) {\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n  }\n}\n\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableStream;\n\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    let chunkSize;\n    try {\n      chunkSize = controller._strategySizeAlgorithm(chunk);\n    } catch (chunkSizeE) {\n      ReadableStreamDefaultControllerError(controller, chunkSizeE);\n      throw chunkSizeE;\n    }\n\n    try {\n      EnqueueValueWithSize(controller, chunk, chunkSize);\n    } catch (enqueueE) {\n      ReadableStreamDefaultControllerError(controller, enqueueE);\n      throw enqueueE;\n    }\n  }\n\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerError(controller, e) {\n  const stream = controller._controlledReadableStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ResetQueue(controller);\n\n  ReadableStreamDefaultControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n  const stream = controller._controlledReadableStream;\n  const state = stream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\n// This is used in the implementation of TransformStream.\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\n  if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n  const state = controller._controlledReadableStream._state;\n\n  if (controller._closeRequested === false && state === 'readable') {\n    return true;\n  }\n\n  return false;\n}\n\nfunction SetUpReadableStreamDefaultController(\n  stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n  assert(stream._readableStreamController === undefined);\n\n  controller._controlledReadableStream = stream;\n\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._started = false;\n  controller._closeRequested = false;\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  Promise.resolve(startResult).then(\n    () => {\n      controller._started = true;\n\n      assert(controller._pulling === false);\n      assert(controller._pullAgain === false);\n\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    },\n    r => {\n      ReadableStreamDefaultControllerError(controller, r);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark,\n                                                                  sizeAlgorithm) {\n  assert(underlyingSource !== undefined);\n\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingSource, 'start', [controller]);\n  }\n\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'pull', 0, [controller]);\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'cancel', 1, []);\n\n  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\n                                       highWaterMark, sizeAlgorithm);\n}\n\nclass ReadableStreamBYOBRequest {\n  constructor() {\n    throw new TypeError('ReadableStreamBYOBRequest cannot be used directly');\n  }\n\n  get view() {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('view');\n    }\n\n    return this._view;\n  }\n\n  respond(bytesWritten) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(this._view.buffer) === true) {\n      throw new TypeError('The BYOB request\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  }\n\n  respondWithNewView(view) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      throw new TypeError('You can only respond with array buffer views');\n    }\n\n    if (IsDetachedBuffer(view.buffer) === true) {\n      throw new TypeError('The supplied view\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  }\n}\n\nclass ReadableByteStreamController {\n  constructor() {\n    throw new TypeError('ReadableByteStreamController constructor cannot be used directly');\n  }\n\n  get byobRequest() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('byobRequest');\n    }\n\n    if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos[0];\n      const view = new Uint8Array(firstDescriptor.buffer,\n                                  firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\n                                  firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n\n      const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n      SetUpReadableStreamBYOBRequest(byobRequest, this, view);\n      this._byobRequest = byobRequest;\n    }\n\n    return this._byobRequest;\n  }\n\n  get desiredSize() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableByteStreamControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('close');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n    }\n\n    ReadableByteStreamControllerClose(this);\n  }\n\n  enqueue(chunk) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('enqueue');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n    }\n\n    if (!ArrayBuffer.isView(chunk)) {\n      throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');\n    }\n\n    if (IsDetachedBuffer(chunk.buffer) === true) {\n      throw new TypeError('Cannot enqueue a view onto a detached ArrayBuffer');\n    }\n\n    ReadableByteStreamControllerEnqueue(this, chunk);\n  }\n\n  error(e) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('error');\n    }\n\n    ReadableByteStreamControllerError(this, e);\n  }\n\n  [CancelSteps](reason) {\n    if (this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos[0];\n      firstDescriptor.bytesFilled = 0;\n    }\n\n    ResetQueue(this);\n\n    const result = this._cancelAlgorithm(reason);\n    ReadableByteStreamControllerClearAlgorithms(this);\n    return result;\n  }\n\n  [PullSteps](forAuthorCode) {\n    const stream = this._controlledReadableByteStream;\n    assert(ReadableStreamHasDefaultReader(stream) === true);\n\n    if (this._queueTotalSize > 0) {\n      assert(ReadableStreamGetNumReadRequests(stream) === 0);\n\n      const entry = this._queue.shift();\n      this._queueTotalSize -= entry.byteLength;\n\n      ReadableByteStreamControllerHandleQueueDrain(this);\n\n      let view;\n      try {\n        view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n      } catch (viewE) {\n        return Promise.reject(viewE);\n      }\n\n      return Promise.resolve(ReadableStreamCreateReadResult(view, false, forAuthorCode));\n    }\n\n    const autoAllocateChunkSize = this._autoAllocateChunkSize;\n    if (autoAllocateChunkSize !== undefined) {\n      let buffer;\n      try {\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\n      } catch (bufferE) {\n        return Promise.reject(bufferE);\n      }\n\n      const pullIntoDescriptor = {\n        buffer,\n        byteOffset: 0,\n        byteLength: autoAllocateChunkSize,\n        bytesFilled: 0,\n        elementSize: 1,\n        ctor: Uint8Array,\n        readerType: 'default'\n      };\n\n      this._pendingPullIntos.push(pullIntoDescriptor);\n    }\n\n    const promise = ReadableStreamAddReadRequest(stream, forAuthorCode);\n\n    ReadableByteStreamControllerCallPullIfNeeded(this);\n\n    return promise;\n  }\n}\n\n// Abstract operations for the ReadableByteStreamController.\n\nfunction IsReadableByteStreamController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamBYOBRequest(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  assert(controller._pullAgain === false);\n\n  controller._pulling = true;\n\n  // TODO: Test controller argument\n  const pullPromise = controller._pullAlgorithm();\n  pullPromise.then(\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n    },\n    e => {\n      ReadableByteStreamControllerError(controller, e);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n\n  return undefined;\n}\n\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = [];\n}\n\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n  assert(stream._state !== 'errored');\n\n  let done = false;\n  if (stream._state === 'closed') {\n    assert(pullIntoDescriptor.bytesFilled === 0);\n    done = true;\n  }\n\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n  if (pullIntoDescriptor.readerType === 'default') {\n    ReadableStreamFulfillReadRequest(stream, filledView, done);\n  } else {\n    assert(pullIntoDescriptor.readerType === 'byob');\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\n\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\n  assert(bytesFilled % elementSize === 0);\n\n  return new pullIntoDescriptor.ctor(\n      pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n}\n\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n  controller._queue.push({ buffer, byteOffset, byteLength });\n  controller._queueTotalSize += byteLength;\n}\n\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n\n  const maxBytesToCopy = Math.min(controller._queueTotalSize,\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n  const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  if (maxAlignedBytes > currentAlignedBytes) {\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n    ready = true;\n  }\n\n  const queue = controller._queue;\n\n  while (totalBytesToCopyRemaining > 0) {\n    const headOfQueue = queue[0];\n\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n\n    if (headOfQueue.byteLength === bytesToCopy) {\n      queue.shift();\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller._queueTotalSize -= bytesToCopy;\n\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  if (ready === false) {\n    assert(controller._queueTotalSize === 0);\n    assert(pullIntoDescriptor.bytesFilled > 0);\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);\n  }\n\n  return ready;\n}\n\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos[0] === pullIntoDescriptor);\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  pullIntoDescriptor.bytesFilled += size;\n}\n\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n  assert(controller._controlledReadableByteStream._state === 'readable');\n\n  if (controller._queueTotalSize === 0 && controller._closeRequested === true) {\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(controller._controlledReadableByteStream);\n  } else {\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n}\n\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n  if (controller._byobRequest === undefined) {\n    return;\n  }\n\n  controller._byobRequest._associatedReadableByteStreamController = undefined;\n  controller._byobRequest._view = undefined;\n  controller._byobRequest = undefined;\n}\n\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n  assert(controller._closeRequested === false);\n\n  while (controller._pendingPullIntos.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n\n    const pullIntoDescriptor = controller._pendingPullIntos[0];\n\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\n        controller._controlledReadableByteStream,\n        pullIntoDescriptor\n      );\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerPullInto(controller, view, forAuthorCode) {\n  const stream = controller._controlledReadableByteStream;\n\n  let elementSize = 1;\n  if (view.constructor !== DataView) {\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\n  }\n\n  const ctor = view.constructor;\n\n  const buffer = TransferArrayBuffer(view.buffer);\n  const pullIntoDescriptor = {\n    buffer,\n    byteOffset: view.byteOffset,\n    byteLength: view.byteLength,\n    bytesFilled: 0,\n    elementSize,\n    ctor,\n    readerType: 'byob'\n  };\n\n  if (controller._pendingPullIntos.length > 0) {\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n    // - No change happens on desiredSize\n    // - The source has already been notified of that there's at least 1 pending read(view)\n\n    return ReadableStreamAddReadIntoRequest(stream, forAuthorCode);\n  }\n\n  if (stream._state === 'closed') {\n    const emptyView = new view.constructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n    return Promise.resolve(ReadableStreamCreateReadResult(emptyView, true, forAuthorCode));\n  }\n\n  if (controller._queueTotalSize > 0) {\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n\n      ReadableByteStreamControllerHandleQueueDrain(controller);\n\n      return Promise.resolve(ReadableStreamCreateReadResult(filledView, false, forAuthorCode));\n    }\n\n    if (controller._closeRequested === true) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      return Promise.reject(e);\n    }\n  }\n\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n\n  const promise = ReadableStreamAddReadIntoRequest(stream, forAuthorCode);\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n\n  return promise;\n}\n\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n\n  assert(firstDescriptor.bytesFilled === 0);\n\n  const stream = controller._controlledReadableByteStream;\n  if (ReadableStreamHasBYOBReader(stream) === true) {\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n      const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\n    throw new RangeError('bytesWritten out of range');\n  }\n\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n    // TODO: Figure out whether we should detach the buffer or not here.\n    return;\n  }\n\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n  if (remainderSize > 0) {\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n  }\n\n  pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n  const firstDescriptor = controller._pendingPullIntos[0];\n\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state === 'closed') {\n    if (bytesWritten !== 0) {\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n    }\n\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n    assert(stream._state === 'readable');\n\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n  const descriptor = controller._pendingPullIntos.shift();\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  return descriptor;\n}\n\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return false;\n  }\n\n  if (controller._closeRequested === true) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableByteStreamControllerClearAlgorithms(controller) {\n  controller._pullAlgorithm = undefined;\n  controller._cancelAlgorithm = undefined;\n}\n\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\n\nfunction ReadableByteStreamControllerClose(controller) {\n  const stream = controller._controlledReadableByteStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  if (controller._queueTotalSize > 0) {\n    controller._closeRequested = true;\n\n    return;\n  }\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos[0];\n    if (firstPendingPullInto.bytesFilled > 0) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      throw e;\n    }\n  }\n\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamClose(stream);\n}\n\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableByteStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  const buffer = chunk.buffer;\n  const byteOffset = chunk.byteOffset;\n  const byteLength = chunk.byteLength;\n  const transferredBuffer = TransferArrayBuffer(buffer);\n\n  if (ReadableStreamHasDefaultReader(stream) === true) {\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    } else {\n      assert(controller._queue.length === 0);\n\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n      ReadableStreamFulfillReadRequest(stream, transferredView, false);\n    }\n  } else if (ReadableStreamHasBYOBReader(stream) === true) {\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n    assert(IsReadableStreamLocked(stream) === false);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerError(controller, e) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  ResetQueue(controller);\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n  const stream = controller._controlledReadableByteStream;\n  const state = stream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n  bytesWritten = Number(bytesWritten);\n  if (IsFiniteNonNegativeNumber(bytesWritten) === false) {\n    throw new RangeError('bytesWritten must be a finite');\n  }\n\n  assert(controller._pendingPullIntos.length > 0);\n\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\n\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n  assert(controller._pendingPullIntos.length > 0);\n\n  const firstDescriptor = controller._pendingPullIntos[0];\n\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n    throw new RangeError('The region specified by view does not match byobRequest');\n  }\n  if (firstDescriptor.byteLength !== view.byteLength) {\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n\n  firstDescriptor.buffer = view.buffer;\n\n  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n}\n\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\n                                           highWaterMark, autoAllocateChunkSize) {\n  assert(stream._readableStreamController === undefined);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  controller._controlledReadableByteStream = stream;\n\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._closeRequested = false;\n  controller._started = false;\n\n  controller._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\n\n  controller._pendingPullIntos = [];\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  Promise.resolve(startResult).then(\n      () => {\n        controller._started = true;\n\n        assert(controller._pulling === false);\n        assert(controller._pullAgain === false);\n\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      },\n      r => {\n        ReadableByteStreamControllerError(controller, r);\n      }\n  )\n      .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n  assert(underlyingByteSource !== undefined);\n\n  const controller = Object.create(ReadableByteStreamController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingByteSource, 'start', [controller]);\n  }\n\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'pull', 0, [controller]);\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'cancel', 1, []);\n\n  let autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n  if (autoAllocateChunkSize !== undefined) {\n    autoAllocateChunkSize = Number(autoAllocateChunkSize);\n    if (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {\n      throw new RangeError('autoAllocateChunkSize must be a positive integer');\n    }\n  }\n\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\n                                    autoAllocateChunkSize);\n}\n\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\n  assert(IsReadableByteStreamController(controller) === true);\n  assert(typeof view === 'object');\n  assert(ArrayBuffer.isView(view) === true);\n  assert(IsDetachedBuffer(view.buffer) === false);\n  request._associatedReadableByteStreamController = controller;\n  request._view = view;\n}\n\n// Helper functions for the ReadableStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n\n// Helper functions for the readers.\n\nfunction readerLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction defaultReaderBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n\nfunction defaultReaderClosedPromiseInitialize(reader) {\n  reader._closedPromise = new Promise((resolve, reject) => {\n    reader._closedPromise_resolve = resolve;\n    reader._closedPromise_reject = reject;\n  });\n}\n\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n  reader._closedPromise = Promise.reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\n  reader._closedPromise = Promise.resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseReject(reader, reason) {\n  assert(reader._closedPromise_resolve !== undefined);\n  assert(reader._closedPromise_reject !== undefined);\n\n  reader._closedPromise_reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\n  assert(reader._closedPromise_resolve === undefined);\n  assert(reader._closedPromise_reject === undefined);\n\n  reader._closedPromise = Promise.reject(reason);\n}\n\nfunction defaultReaderClosedPromiseResolve(reader) {\n  assert(reader._closedPromise_resolve !== undefined);\n  assert(reader._closedPromise_reject !== undefined);\n\n  reader._closedPromise_resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction byobReaderBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n\n// Helper functions for the ReadableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n\n// Helper functions for the ReadableStreamBYOBRequest.\n\nfunction byobRequestBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n\n// Helper functions for the ReadableByteStreamController.\n\nfunction byteStreamControllerBrandCheckException(name) {\n  return new TypeError(\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n\n// Helper function for ReadableStream pipeThrough\n\nfunction ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise) {\n  try {\n    // This relies on the brand-check that is enforced by Promise.prototype.then(). As with the rest of the reference\n    // implementation, it doesn't attempt to do the right thing if someone has modified the global environment.\n    Promise.prototype.then.call(promise, undefined, () => {});\n  } catch (e) {\n    // The brand check failed, therefore the internal slot is not present and there's nothing further to do.\n  }\n}\n","'use strict';\nconst { createDataProperty } = require('./helpers.js');\n\nmodule.exports = class ByteLengthQueuingStrategy {\n  constructor({ highWaterMark }) {\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  size(chunk) {\n    return chunk.byteLength;\n  }\n};\n","'use strict';\nconst { createDataProperty } = require('./helpers.js');\n\nmodule.exports = class CountQueuingStrategy {\n  constructor({ highWaterMark }) {\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  size() {\n    return 1;\n  }\n};\n","'use strict';\nconst assert = require('better-assert');\n\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\n// and do not appear in the standard text.\nconst verbose = require('debug')('streams:transform-stream:verbose');\nconst { InvokeOrNoop, CreateAlgorithmFromUnderlyingMethod, PromiseCall, typeIsObject,\n        ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction } = require('./helpers.js');\nconst { CreateReadableStream, ReadableStreamDefaultControllerClose, ReadableStreamDefaultControllerEnqueue,\n        ReadableStreamDefaultControllerError, ReadableStreamDefaultControllerGetDesiredSize,\n        ReadableStreamDefaultControllerHasBackpressure,\n        ReadableStreamDefaultControllerCanCloseOrEnqueue } = require('./readable-stream.js');\nconst { CreateWritableStream, WritableStreamDefaultControllerErrorIfNeeded } = require('./writable-stream.js');\n\n// Class TransformStream\n\nclass TransformStream {\n  constructor(transformer = {}, writableStrategy = {}, readableStrategy = {}) {\n    const writableSizeFunction = writableStrategy.size;\n    let writableHighWaterMark = writableStrategy.highWaterMark;\n    const readableSizeFunction = readableStrategy.size;\n    let readableHighWaterMark = readableStrategy.highWaterMark;\n\n    const writableType = transformer.writableType;\n\n    if (writableType !== undefined) {\n      throw new RangeError('Invalid writable type specified');\n    }\n\n    const writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(writableSizeFunction);\n    if (writableHighWaterMark === undefined) {\n      writableHighWaterMark = 1;\n    }\n    writableHighWaterMark = ValidateAndNormalizeHighWaterMark(writableHighWaterMark);\n\n    const readableType = transformer.readableType;\n\n    if (readableType !== undefined) {\n      throw new RangeError('Invalid readable type specified');\n    }\n\n    const readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(readableSizeFunction);\n    if (readableHighWaterMark === undefined) {\n      readableHighWaterMark = 0;\n    }\n    readableHighWaterMark = ValidateAndNormalizeHighWaterMark(readableHighWaterMark);\n\n    let startPromise_resolve;\n    const startPromise = new Promise(resolve => {\n      startPromise_resolve = resolve;\n    });\n\n    InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                              readableSizeAlgorithm);\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n\n    const startResult = InvokeOrNoop(transformer, 'start', [this._transformStreamController]);\n    startPromise_resolve(startResult);\n  }\n\n  get readable() {\n    if (IsTransformStream(this) === false) {\n      throw streamBrandCheckException('readable');\n    }\n\n    return this._readable;\n  }\n\n  get writable() {\n    if (IsTransformStream(this) === false) {\n      throw streamBrandCheckException('writable');\n    }\n\n    return this._writable;\n  }\n}\n\n// Transform Stream Abstract Operations\n\nfunction CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm, writableHighWaterMark = 1,\n                               writableSizeAlgorithm = () => 1, readableHighWaterMark = 0,\n                               readableSizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(writableHighWaterMark));\n  assert(IsNonNegativeNumber(readableHighWaterMark));\n\n  const stream = Object.create(TransformStream.prototype);\n\n  let startPromise_resolve;\n  const startPromise = new Promise(resolve => {\n    startPromise_resolve = resolve;\n  });\n\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                            readableSizeAlgorithm);\n\n  const controller = Object.create(TransformStreamDefaultController.prototype);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n\n  const startResult = startAlgorithm();\n  startPromise_resolve(startResult);\n  return stream;\n}\n\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm,\n                                   readableHighWaterMark, readableSizeAlgorithm) {\n  function startAlgorithm() {\n    return startPromise;\n  }\n\n  function writeAlgorithm(chunk) {\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  }\n\n  function abortAlgorithm(reason) {\n    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n  }\n\n  function closeAlgorithm() {\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  }\n\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm,\n                                          writableHighWaterMark, writableSizeAlgorithm);\n\n  function pullAlgorithm() {\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\n  }\n\n  function cancelAlgorithm(reason) {\n    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n    return Promise.resolve();\n  }\n\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark,\n                                          readableSizeAlgorithm);\n\n  // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n  stream._backpressure = undefined;\n  stream._backpressureChangePromise = undefined;\n  stream._backpressureChangePromise_resolve = undefined;\n  TransformStreamSetBackpressure(stream, true);\n\n  // Used by IsWritableStream() which is called by SetUpTransformStreamDefaultController().\n  stream._transformStreamController = undefined;\n}\n\nfunction IsTransformStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream, e) {\n  verbose('TransformStreamError()');\n\n  ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\n\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n  if (stream._backpressure === true) {\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n    // _backpressure is set.\n    TransformStreamSetBackpressure(stream, false);\n  }\n}\n\nfunction TransformStreamSetBackpressure(stream, backpressure) {\n  verbose(`TransformStreamSetBackpressure() [backpressure = ${backpressure}]`);\n\n  // Passes also when called during construction.\n  assert(stream._backpressure !== backpressure);\n\n  if (stream._backpressureChangePromise !== undefined) {\n    stream._backpressureChangePromise_resolve();\n  }\n\n  stream._backpressureChangePromise = new Promise(resolve => {\n    stream._backpressureChangePromise_resolve = resolve;\n  });\n\n  stream._backpressure = backpressure;\n}\n\n// Class TransformStreamDefaultController\n\nclass TransformStreamDefaultController {\n  constructor() {\n    throw new TypeError('TransformStreamDefaultController instances cannot be created directly');\n  }\n\n  get desiredSize() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    const readableController = this._controlledTransformStream._readable._readableStreamController;\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n  }\n\n  enqueue(chunk) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    TransformStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  error(reason) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    TransformStreamDefaultControllerError(this, reason);\n  }\n\n  terminate() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('terminate');\n    }\n\n    TransformStreamDefaultControllerTerminate(this);\n  }\n}\n\n// Transform Stream Default Controller Abstract Operations\n\nfunction IsTransformStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n  assert(IsTransformStream(stream) === true);\n  assert(stream._transformStreamController === undefined);\n\n  controller._controlledTransformStream = stream;\n  stream._transformStreamController = controller;\n\n  controller._transformAlgorithm = transformAlgorithm;\n  controller._flushAlgorithm = flushAlgorithm;\n}\n\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n  assert(transformer !== undefined);\n\n  const controller = Object.create(TransformStreamDefaultController.prototype);\n\n  let transformAlgorithm = chunk => {\n    try {\n      TransformStreamDefaultControllerEnqueue(controller, chunk);\n      return Promise.resolve();\n    } catch (transformResultE) {\n      return Promise.reject(transformResultE);\n    }\n  };\n  const transformMethod = transformer.transform;\n  if (transformMethod !== undefined) {\n    if (typeof transformMethod !== 'function') {\n      throw new TypeError('transform is not a method');\n    }\n    transformAlgorithm = chunk => PromiseCall(transformMethod, transformer, [chunk, controller]);\n  }\n\n  const flushAlgorithm = CreateAlgorithmFromUnderlyingMethod(transformer, 'flush', 0, [controller]);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\n\nfunction TransformStreamDefaultControllerClearAlgorithms(controller) {\n  controller._transformAlgorithm = undefined;\n  controller._flushAlgorithm = undefined;\n}\n\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\n  verbose('TransformStreamDefaultControllerEnqueue()');\n\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === false) {\n    throw new TypeError('Readable side is not in a state that permits enqueue');\n  }\n\n  // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n  // accept TransformStreamDefaultControllerEnqueue() calls.\n\n  try {\n    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  } catch (e) {\n    // This happens when readableStrategy.size() throws.\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n\n    throw stream._readable._storedError;\n  }\n\n  const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n  if (backpressure !== stream._backpressure) {\n    assert(backpressure === true);\n    TransformStreamSetBackpressure(stream, true);\n  }\n}\n\nfunction TransformStreamDefaultControllerError(controller, e) {\n  TransformStreamError(controller._controlledTransformStream, e);\n}\n\nfunction TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n  const transformPromise = controller._transformAlgorithm(chunk);\n  return transformPromise.catch(r => {\n    TransformStreamError(controller._controlledTransformStream, r);\n    throw r;\n  });\n}\n\nfunction TransformStreamDefaultControllerTerminate(controller) {\n  verbose('TransformStreamDefaultControllerTerminate()');\n\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n    ReadableStreamDefaultControllerClose(readableController);\n  }\n\n  const error = new TypeError('TransformStream terminated');\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n\n// TransformStreamDefaultSink Algorithms\n\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n  verbose('TransformStreamDefaultSinkWriteAlgorithm()');\n\n  assert(stream._writable._state === 'writable');\n\n  const controller = stream._transformStreamController;\n\n  if (stream._backpressure === true) {\n    const backpressureChangePromise = stream._backpressureChangePromise;\n    assert(backpressureChangePromise !== undefined);\n    return backpressureChangePromise\n        .then(() => {\n          const writable = stream._writable;\n          const state = writable._state;\n          if (state === 'erroring') {\n            throw writable._storedError;\n          }\n          assert(state === 'writable');\n          return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n        });\n  }\n\n  return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n}\n\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n  // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n  // errored.\n  TransformStreamError(stream, reason);\n  return Promise.resolve();\n}\n\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\n  verbose('TransformStreamDefaultSinkCloseAlgorithm()');\n\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  const readable = stream._readable;\n\n  const controller = stream._transformStreamController;\n  const flushPromise = controller._flushAlgorithm();\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n\n  // Return a promise that is fulfilled with undefined on success.\n  return flushPromise.then(() => {\n    if (readable._state === 'errored') {\n      throw readable._storedError;\n    }\n    const readableController = readable._readableStreamController;\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n      ReadableStreamDefaultControllerClose(readableController);\n    }\n  }).catch(r => {\n    TransformStreamError(stream, r);\n    throw readable._storedError;\n  });\n}\n\n// TransformStreamDefaultSource Algorithms\n\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\n  verbose('TransformStreamDefaultSourcePullAlgorithm()');\n\n  // Invariant. Enforced by the promises returned by start() and pull().\n  assert(stream._backpressure === true);\n\n  assert(stream._backpressureChangePromise !== undefined);\n\n  TransformStreamSetBackpressure(stream, false);\n\n  // Prevent the next pull() call until there is backpressure.\n  return stream._backpressureChangePromise;\n}\n\nmodule.exports = { CreateTransformStream, TransformStream };\n\n// Helper functions for the TransformStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name) {\n  return new TypeError(\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n\n// Helper functions for the TransformStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(\n    `TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n"],"names":["NumberIsInteger","Number","isInteger","value","isFinite","Math","floor","SymbolPolyfill","Symbol","iterator","description","noop","NumberIsNaN","isNaN","x","isFakeDetached","Call","F","V","args","TypeError","Function","prototype","apply","call","PromiseCall","Promise","resolve","reject","exports","o","p","v","Object","defineProperty","writable","enumerable","configurable","elements","slice","dest","destOffset","src","srcOffset","n","Uint8Array","set","IsNonNegativeNumber","Infinity","Number.isNaN","underlyingObject","methodName","algoArgCount","extraArgs","method","undefined","arg","fullArgs","concat","O","P","transferredIshVersion","get","highWaterMark","RangeError","size","chunk","assert","AssertionError","e","setTimeout","IsFiniteNonNegativeNumber","require$$0","container","pair","_queue","shift","_queueTotalSize","push","CreateAlgorithmFromUnderlyingMethod","InvokeOrNoop","ValidateAndNormalizeHighWaterMark","MakeSizeAlgorithmFromSizeFunction","typeIsObject","require$$1","rethrowAssertionErrorRejection","require$$2","DequeueValue","EnqueueValueWithSize","PeekQueueValue","ResetQueue","require$$3","AbortSteps","ErrorSteps","WritableStream","[object Object]","underlyingSink","strategy","InitializeWritableStream","this","type","sizeAlgorithm","stream","controller","create","WritableStreamDefaultController","writeAlgorithm","closeAlgorithm","abortAlgorithm","SetUpWritableStreamDefaultController","SetUpWritableStreamDefaultControllerFromUnderlyingSink","locked","IsWritableStream","streamBrandCheckException","IsWritableStreamLocked","reason","WritableStreamAbort","AcquireWritableStreamDefaultWriter","CreateWritableStream","startAlgorithm","WritableStreamDefaultControllerErrorIfNeeded","WritableStreamDefaultWriterCloseWithErrorPropagation","writer","_ownerWritableStream","state","_state","WritableStreamCloseQueuedOrInFlight","_storedError","WritableStreamDefaultWriterClose","WritableStreamDefaultWriterRelease","WritableStreamDefaultWriterWrite","WritableStreamDefaultWriter","_writer","_writableStreamController","_writeRequests","_inFlightWriteRequest","_closeRequest","_inFlightCloseRequest","_pendingAbortRequest","_backpressure","hasOwnProperty","_promise","wasAlreadyErroring","promise","_resolve","_reject","_reason","_wasAlreadyErroring","WritableStreamStartErroring","WritableStreamDealWithRejection","error","WritableStreamFinishErroring","WritableStreamDefaultWriterEnsureReadyPromiseRejected","WritableStreamHasOperationMarkedInFlight","_started","storedError","writeRequest","WritableStreamRejectCloseAndClosedPromiseIfNeeded","abortRequest","then","WritableStreamFinishInFlightClose","_closedPromise_resolve","_closedPromise_reject","_closedPromiseState","defaultWriterClosedPromiseResolve","defaultWriterClosedPromiseReject","_closedPromise","catch","WritableStreamUpdateBackpressure","backpressure","_readyPromise","_readyPromise_resolve","_readyPromise_reject","_readyPromiseState","defaultWriterReadyPromiseReset","defaultWriterReadyPromiseResolve","defaultWriterReadyPromiseInitialize","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterClosedPromiseInitialize","defaultWriterReadyPromiseInitializeAsRejected","defaultWriterClosedPromiseInitializeAsResolved","defaultWriterClosedPromiseInitializeAsRejected","closed","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","desiredSize","defaultWriterLockException","WritableStreamDefaultControllerGetDesiredSize","WritableStreamDefaultWriterGetDesiredSize","ready","WritableStreamDefaultWriterAbort","closeRequest","WritableStreamDefaultControllerAdvanceQueueIfNeeded","WritableStreamDefaultControllerClose","WritableStreamDefaultWriterEnsureClosedPromiseRejected","defaultWriterClosedPromiseResetToRejected","defaultWriterReadyPromiseReject","defaultWriterReadyPromiseResetToRejected","releasedError","chunkSize","_strategySizeAlgorithm","chunkSizeE","WritableStreamDefaultControllerGetChunkSize","WritableStreamAddWriteRequest","writeRecord","enqueueE","_controlledWritableStream","WritableStreamDefaultControllerGetBackpressure","WritableStreamDefaultControllerWrite","IsWritableStreamDefaultController","WritableStreamDefaultControllerError","result","_abortAlgorithm","WritableStreamDefaultControllerClearAlgorithms","_strategyHWM","_writeAlgorithm","_closeAlgorithm","startResult","r","length","WritableStreamMarkCloseRequestInFlight","sinkClosePromise","WritableStreamFinishInFlightCloseWithError","WritableStreamDefaultControllerProcessClose","WritableStreamMarkFirstWriteRequestInFlight","WritableStreamFinishInFlightWrite","WritableStreamFinishInFlightWriteWithError","WritableStreamDefaultControllerProcessWrite","name","ArrayBufferCopy","IsDetachedBuffer","TransferArrayBuffer","createArrayFromList","CancelSteps","PullSteps","ReadableStream","underlyingSource","InitializeReadableStream","String","underlyingByteSource","ReadableByteStreamController","pullAlgorithm","cancelAlgorithm","autoAllocateChunkSize","Number.isInteger","SetUpReadableByteStreamController","SetUpReadableByteStreamControllerFromUnderlyingSource","ReadableStreamDefaultController","SetUpReadableStreamDefaultController","SetUpReadableStreamDefaultControllerFromUnderlyingSource","IsReadableStream","IsReadableStreamLocked","ReadableStreamCancel","mode","AcquireReadableStreamDefaultReader","ReadableStreamBYOBReader","AcquireReadableStreamBYOBReader","readable","options","ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue","pipeTo","preventClose","preventAbort","preventCancel","Boolean","reader","shuttingDown","currentWrite","isOrBecomesErrored","shutdownWithAction","shutdown","action","isOrBecomesClosed","destClosed","waitForWritesToFinish","oldCurrentWrite","originalIsError","originalError","doTheRest","finalize","newError","isError","ReadableStreamReaderGenericRelease","pipeLoop","ReadableStreamDefaultReaderRead","done","err","branches","cloneForBranch2","reason1","reason2","branch1","branch2","resolveCancelPromise","closedOrErrored","canceled1","canceled2","cancelPromise","ReadableStreamDefaultControllerClose","_readableStreamController","value1","value2","ReadableStreamDefaultControllerEnqueue","CreateReadableStream","compositeReason","cancelResult","ReadableStreamDefaultControllerError","ReadableStreamTee","CreateReadableByteStream","IsReadableStreamDisturbed","_disturbed","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerHasBackpressure","ReadableStreamDefaultControllerShouldCallPull","ReadableStreamDefaultControllerCanCloseOrEnqueue","ReadableStreamDefaultReader","_reader","ReadableStreamAddReadIntoRequest","forAuthorCode","readIntoRequest","_forAuthorCode","_readIntoRequests","ReadableStreamAddReadRequest","readRequest","_readRequests","ReadableStreamClose","IsReadableStreamDefaultReader","ReadableStreamCreateReadResult","defaultReaderClosedPromiseResolve","obj","ReadableStreamError","defaultReaderClosedPromiseReject","ReadableStreamFulfillReadRequest","ReadableStreamGetNumReadIntoRequests","ReadableStreamGetNumReadRequests","ReadableStreamHasBYOBReader","IsReadableStreamBYOBReader","ReadableStreamHasDefaultReader","ReadableStreamReaderGenericInitialize","defaultReaderBrandCheckException","_ownerReadableStream","readerLockException","ReadableStreamReaderGenericCancel","IsReadableByteStreamController","byobReaderBrandCheckException","view","ArrayBuffer","isView","buffer","byteLength","_controlledReadableByteStream","elementSize","constructor","DataView","BYTES_PER_ELEMENT","ctor","pullIntoDescriptor","byteOffset","bytesFilled","readerType","_pendingPullIntos","emptyView","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","ReadableByteStreamControllerHandleQueueDrain","_closeRequested","ReadableByteStreamControllerError","ReadableByteStreamControllerCallPullIfNeeded","ReadableByteStreamControllerPullInto","ReadableStreamBYOBReaderRead","defaultReaderClosedPromiseInitialize","defaultReaderClosedPromiseInitializeAsResolved","defaultReaderClosedPromiseInitializeAsRejected","defaultReaderClosedPromiseResetToRejected","IsReadableStreamDefaultController","defaultControllerBrandCheckException","_cancelAlgorithm","ReadableStreamDefaultControllerClearAlgorithms","_controlledReadableStream","ReadableStreamDefaultControllerCallPullIfNeeded","pendingPromise","_pulling","_pullAlgorithm","_pullAgain","ReadableStreamBYOBRequest","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","_view","bytesWritten","_associatedReadableByteStreamController","ReadableByteStreamControllerRespondInternal","ReadableByteStreamControllerRespond","firstDescriptor","ReadableByteStreamControllerRespondWithNewView","byobRequest","byteStreamControllerBrandCheckException","_byobRequest","request","SetUpReadableStreamBYOBRequest","ReadableByteStreamControllerGetDesiredSize","firstPendingPullInto","ReadableByteStreamControllerClearAlgorithms","ReadableByteStreamControllerClose","transferredBuffer","ReadableByteStreamControllerEnqueueChunkToQueue","transferredView","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","ReadableByteStreamControllerEnqueue","entry","viewE","_autoAllocateChunkSize","bufferE","ReadableByteStreamControllerShouldCallPull","ReadableByteStreamControllerClearPendingPullIntos","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerCommitPullIntoDescriptor","ReadableStreamFulfillReadIntoRequest","currentAlignedBytes","maxBytesToCopy","min","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","queue","headOfQueue","bytesToCopy","destStart","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableByteStreamControllerShiftPendingPullInto","ReadableByteStreamControllerRespondInClosedState","remainderSize","end","remainder","ReadableByteStreamControllerRespondInReadableState","descriptor","createDataProperty","TransformStream","transformer","writableStrategy","readableStrategy","writableSizeFunction","writableHighWaterMark","readableSizeFunction","readableHighWaterMark","writableType","writableSizeAlgorithm","readableType","readableSizeAlgorithm","startPromise_resolve","InitializeTransformStream","TransformStreamDefaultController","transformAlgorithm","TransformStreamDefaultControllerEnqueue","transformResultE","transformMethod","transform","flushAlgorithm","SetUpTransformStreamDefaultController","SetUpTransformStreamDefaultControllerFromTransformer","_transformStreamController","IsTransformStream","_readable","_writable","startPromise","backpressureChangePromise","_backpressureChangePromise","TransformStreamDefaultControllerPerformTransform","TransformStreamDefaultSinkWriteAlgorithm","flushPromise","_flushAlgorithm","TransformStreamDefaultControllerClearAlgorithms","readableController","TransformStreamError","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamDefaultSinkAbortAlgorithm","TransformStreamSetBackpressure","TransformStreamDefaultSourcePullAlgorithm","TransformStreamErrorWritableAndUnblockWrite","_backpressureChangePromise_resolve","IsTransformStreamDefaultController","_controlledTransformStream","TransformStreamDefaultControllerError","TransformStreamDefaultControllerTerminate","_transformAlgorithm","CreateTransformStream","ByteLengthQueuingStrategy","CountQueuingStrategy"],"mappings":"qMACA,MAAMA,EAAkBC,OAAOC,WAAa,SAAUC,GACpD,MAAwB,iBAAVA,GACZC,SAASD,IACTE,KAAKC,MAAMH,KAAWA,GCJpBI,EAAmC,mBAAXC,QAAoD,iBAApBA,OAAOC,SACnED,OACAE,aAAyBA,KCFpB,SAASC,KCChB,MAAMC,EAAcX,OAAOY,OAAS,SAAUC,GAE5C,OAAOA,GAAMA,mFCAf,MAAMC,EAAiBP,EAAO,kCAmD9B,SAASQ,EAAKC,EAAGC,EAAGC,GAClB,GAAiB,mBAANF,EACT,MAAM,IAAIG,UAAU,8BAGtB,OAAOC,SAASC,UAAUC,MAAMC,KAAKP,EAAGC,EAAGC,GA8C7C,SAASM,EAAYR,EAAGC,EAAGC,GAIzB,IACE,OAAOO,QAAQC,QAAQX,EAAKC,EAAGC,EAAGC,IAClC,MAAOhB,GACP,OAAOuB,QAAQE,OAAOzB,IAvG1B0B,eAAuBf,CAAAA,GAAmB,iBAANA,GAAwB,OAANA,GAA4B,mBAANA,GAE5Ee,qBAA6B,EAACC,EAAGC,EAAGC,KAElCC,OAAOC,eAAeJ,EAAGC,GAAK5B,MAAO6B,EAAGG,UAAU,EAAMC,YAAY,EAAMC,cAAc,MAG1FR,sBAA8BS,CAAAA,GAGrBA,EAASC,SAGlBV,kBAA0B,EAACW,EAAMC,EAAYC,EAAKC,EAAWC,KAC3D,IAAIC,WAAWL,GAAMM,IAAI,IAAID,WAAWH,EAAKC,EAAWC,GAAIH,KAG9DZ,4BAAoCG,CAAAA,IACK,IAAnCH,EAAQkB,oBAAoBf,IAI5BA,IAAMgB,EAAAA,GAOZnB,sBAA8BG,CAAAA,GACX,iBAANA,KAIPiB,EAAajB,MAIbA,EAAI,KAeVH,OAAeb,EAEfa,sCAA8C,EAACqB,EAAkBC,EAAYC,EAAcC,KAKzF,MAAMC,EAASJ,EAAiBC,GAChC,QAAeI,IAAXD,EAAsB,CACxB,GAAsB,mBAAXA,EACT,MAAM,IAAIlC,aAAakC,qBAEzB,OAAQF,GACN,KAAK,EACH,MAAO,IACE3B,EAAY6B,EAAQJ,EAAkBG,GAIjD,KAAK,EACH,OAAOG,IACL,MAAMC,GAAYD,GAAKE,OAAOL,GAC9B,OAAO5B,EAAY6B,EAAQJ,EAAkBO,KAKrD,MAAO,IAAM/B,QAAQC,YAGvBE,eAAuB,EAAC8B,EAAGC,EAAGzC,KAK5B,MAAMmC,EAASK,EAAEC,GACjB,QAAeL,IAAXD,EAIJ,OAAOtC,EAAKsC,EAAQK,EAAGxC,KAczBU,cAAsBJ,EAGtBI,sBAA8B8B,CAAAA,IAE5B,MAAME,EAAwBF,EAAEpB,QAWhC,OAPAN,OAAOC,eAAeyB,EAAG,cACvBG,IAAG,IACM,IAGXH,EAAE5C,IAAkB,EAEb8C,IAIThC,mBAA2B8B,CAAAA,GAClB5C,KAAkB4C,GAG3B9B,oCAA4CkC,CAAAA,IAE1C,GADAA,EAAgB9D,OAAO8D,GACnBd,EAAac,IAAkBA,EAAgB,EACjD,MAAM,IAAIC,WAAW,iFAGvB,OAAOD,IAGTlC,oCAA4CoC,CAAAA,IAC1C,QAAaV,IAATU,EACF,MAAO,IAAM,EAEf,GAAoB,mBAATA,EACT,MAAM,IAAI7C,UAAU,0DAEtB,OAAO8C,GAASD,EAAKC,6nBC1JR,SAASC,KAIxBA,EAAOC,eAAiBzD,gCCHiB0D,IAInCA,GAAKA,aAAaF,EAAOC,gBAC3BE,WAAW,KACT,MAAMD,GACL,oHCRP,MAAME,0BAAEA,GAA8BC,EAEtC,MAAuBC,IAIrB,MAAMC,EAAOD,EAAUE,OAAOC,QAM9B,OALAH,EAAUI,iBAAmBH,EAAKT,KAC9BQ,EAAUI,gBAAkB,IAC9BJ,EAAUI,gBAAkB,GAGvBH,EAAKvE,SAGiB,CAACsE,EAAWtE,EAAO8D,KAIhD,GADAA,EAAOhE,OAAOgE,IACTM,EAA0BN,GAC7B,MAAM,IAAID,WAAW,wDAGvBS,EAAUE,OAAOG,MAAO3E,MAAAA,EAAO8D,KAAAA,IAC/BQ,EAAUI,iBAAmBZ,KAGNQ,IAKvB,OADaA,EAAUE,OAAO,GAClBxE,SAGOsE,IAGnBA,EAAUE,UACVF,EAAUI,gBAAkB,2NCpC9B,MAEME,oCAAEA,EAAmCC,aAAEA,EAAYC,kCAAEA,EAAiClC,oBAAEA,EAAmBmC,kCACzGA,EAAiCC,aAAEA,GAAiBC,kCACpDC,GAAmCC,gBACnCC,uBAAcC,iBAAsBC,aAAgBC,GAAeC,EAErEC,GAPUpB,EAAiB,mCAOdhE,EAAO,mBACpBqF,EAAarF,EAAO,wBAEpBsF,eACJC,YAAYC,KAAqBC,MAC/BC,EAAyBC,MAEzB,MAAMlC,EAAOgC,EAAShC,KACtB,IAAIF,EAAgBkC,EAASlC,cAI7B,QAAaR,IAFAyC,EAAeI,KAG1B,MAAM,IAAIpC,WAAW,6BAGvB,MAAMqC,EAAgBnB,EAAkCjB,QAClCV,IAAlBQ,IACFA,EAAgB,GAmvBtB,SAAgEuC,EAAQN,EAAgBjC,EAAesC,GAGrG,MAAME,EAAatE,OAAOuE,OAAOC,gCAAgCnF,WAMjE,MAAMoF,EAAiB3B,EAAoCiB,EAAgB,QAAS,GAAIO,IAClFI,EAAiB5B,EAAoCiB,EAAgB,QAAS,MAC9EY,EAAiB7B,EAAoCiB,EAAgB,QAAS,MAEpFa,GAAqCP,EAAQC,EAR7C,WACE,OAAOvB,EAAagB,EAAgB,SAAUO,KAOyBG,EAAgBC,EACpDC,EAAgB7C,EAAesC,GA7vBlES,CAAuDX,KAAMH,EAF7DjC,EAAgBkB,EAAkClB,GAE0CsC,GAG9FU,aACE,IAA+B,IAA3BC,EAAiBb,MACnB,MAAMc,GAA0B,UAGlC,OAAOC,EAAuBf,MAGhCJ,MAAMoB,GACJ,OAA+B,IAA3BH,EAAiBb,MACZzE,QAAQE,OAAOqF,GAA0B,WAGb,IAAjCC,EAAuBf,MAClBzE,QAAQE,OAAO,IAAIR,UAAU,oDAG/BgG,EAAoBjB,KAAMgB,GAGnCpB,YACE,IAA+B,IAA3BiB,EAAiBb,MACnB,MAAMc,GAA0B,aAGlC,OAAOI,EAAmClB,OAI9C,OACEkB,mCAAAA,EACAC,qBAmBF,SAA8BC,EAAgBb,EAAgBC,EAAgBC,EAAgB7C,EAAgB,EAChFsC,EAAgB,KAAM,IAGlD,MAAMC,EAASrE,OAAOuE,OAAOV,eAAexE,WAC5C4E,EAAyBI,GAEzB,MAAMC,EAAatE,OAAOuE,OAAOC,gCAAgCnF,WAIjE,OAFAuF,GAAqCP,EAAQC,EAAYgB,EAAgBb,EAAgBC,EACpDC,EAAgB7C,EAAesC,GAC7DC,GA7BPU,iBAAAA,EACAE,uBAAAA,EACApB,eAAAA,eACAsB,oBAAAA,EACAI,6CAAAA,GACAC,qDAwgBF,SAA8DC,GAC5D,MAAMpB,EAASoB,EAAOC,qBAIhBC,EAAQtB,EAAOuB,OACrB,IAAoD,IAAhDC,EAAoCxB,IAA8B,WAAVsB,EAC1D,OAAOlG,QAAQC,UAGjB,GAAc,YAAViG,EACF,OAAOlG,QAAQE,OAAO0E,EAAOyB,cAK/B,OAAOC,EAAiCN,IAvhBxCO,mCAAAA,GACAC,iCAAAA,GACAJ,oCAAAA,GAKF,SAAST,EAAmCf,GAC1C,OAAO,IAAI6B,4BAA4B7B,GAkBzC,SAASJ,EAAyBI,GAChCA,EAAOuB,OAAS,WAIhBvB,EAAOyB,kBAAexE,EAEtB+C,EAAO8B,aAAU7E,EAIjB+C,EAAO+B,+BAA4B9E,EAInC+C,EAAOgC,kBAIPhC,EAAOiC,2BAAwBhF,EAI/B+C,EAAOkC,mBAAgBjF,EAIvB+C,EAAOmC,2BAAwBlF,EAG/B+C,EAAOoC,0BAAuBnF,EAG9B+C,EAAOqC,eAAgB,EAGzB,SAAS3B,EAAiBlG,GACxB,QAAKqE,EAAarE,MAIbmB,OAAOX,UAAUsH,eAAepH,KAAKV,EAAG,6BAO/C,SAASoG,EAAuBZ,GAG9B,YAAuB/C,IAAnB+C,EAAO8B,QAOb,SAAShB,EAAoBd,EAAQa,GACnC,MAAMS,EAAQtB,EAAOuB,OACrB,GAAc,WAAVD,GAAgC,YAAVA,EACxB,OAAOlG,QAAQC,aAAQ4B,GAEzB,QAAoCA,IAAhC+C,EAAOoC,qBACT,OAAOpC,EAAOoC,qBAAqBG,SAKrC,IAAIC,GAAqB,EACX,aAAVlB,IACFkB,GAAqB,EAErB3B,OAAS5D,GAGX,MAAMwF,EAAU,IAAIrH,QAAQ,CAACC,EAASC,KACpC0E,EAAOoC,sBACLM,SAAUrH,EACVsH,QAASrH,EACTsH,QAAS/B,EACTgC,oBAAqBL,KASzB,OANAxC,EAAOoC,qBAAqBG,SAAWE,GAEZ,IAAvBD,GACFM,EAA4B9C,EAAQa,GAG/B4B,EAqBT,SAASM,EAAgC/C,EAAQgD,GAIjC,aAFAhD,EAAOuB,OAQrB0B,EAA6BjD,GAL3B8C,EAA4B9C,EAAQgD,GAQxC,SAASF,EAA4B9C,EAAQa,GAK3C,MAAMZ,EAAaD,EAAO+B,0BAG1B/B,EAAOuB,OAAS,WAChBvB,EAAOyB,aAAeZ,EACtB,MAAMO,EAASpB,EAAO8B,aACP7E,IAAXmE,GACF8B,GAAsD9B,EAAQP,IAGP,IAiH3D,SAAkDb,GAChD,QAAqC/C,IAAjC+C,EAAOiC,4BAAwEhF,IAAjC+C,EAAOmC,sBAEvD,OAAO,EAIT,OAAO,EAxHHgB,CAAyCnD,KAA6C,IAAxBC,EAAWmD,UAC3EH,EAA6BjD,GAIjC,SAASiD,EAA6BjD,GAIpCA,EAAOuB,OAAS,UAChBvB,EAAO+B,0BAA0BxC,KAEjC,MAAM8D,EAAcrD,EAAOyB,aAC3B,IAAK,MAAM6B,KAAgBtD,EAAOgC,eAChCsB,EAAaX,QAAQU,GAIvB,GAFArD,EAAOgC,uBAE6B/E,IAAhC+C,EAAOoC,qBAET,YADAmB,EAAkDvD,GAIpD,MAAMwD,EAAexD,EAAOoC,qBAG5B,GAFApC,EAAOoC,0BAAuBnF,GAEW,IAArCuG,EAAaX,oBAGf,OAFAW,EAAab,QAAQU,QACrBE,EAAkDvD,GAIpCA,EAAO+B,0BAA0BzC,GAAYkE,EAAaZ,SAClEa,KACJ,KACED,EAAad,WACba,EAAkDvD,IAEpDa,IACE2C,EAAab,QAAQ9B,GACrB0C,EAAkDvD,KAoB1D,SAAS0D,EAAkC1D,GAEzCA,EAAOmC,sBAAsBO,cAASzF,GACtC+C,EAAOmC,2BAAwBlF,EAMjB,aAJA+C,EAAOuB,SAMnBvB,EAAOyB,kBAAexE,OACcA,IAAhC+C,EAAOoC,uBACTpC,EAAOoC,qBAAqBM,WAC5B1C,EAAOoC,0BAAuBnF,IAIlC+C,EAAOuB,OAAS,SAEhB,MAAMH,EAASpB,EAAO8B,aACP7E,IAAXmE,GAurBN,SAA2CA,GAKzCA,EAAOuC,4BAAuB1G,GAC9BmE,EAAOuC,4BAAyB1G,EAChCmE,EAAOwC,2BAAwB3G,EAC/BmE,EAAOyC,oBAAsB,WA9rB3BC,CAAkC1C,GAuBtC,SAASI,EAAoCxB,GAC3C,YAA6B/C,IAAzB+C,EAAOkC,oBAAgEjF,IAAjC+C,EAAOmC,sBA8BnD,SAASoB,EAAkDvD,QAG5B/C,IAAzB+C,EAAOkC,gBAGTlC,EAAOkC,cAAcS,QAAQ3C,EAAOyB,cACpCzB,EAAOkC,mBAAgBjF,GAEzB,MAAMmE,EAASpB,EAAO8B,aACP7E,IAAXmE,IACF2C,GAAiC3C,EAAQpB,EAAOyB,cAChDL,EAAO4C,eAAeC,MAAM,SAIhC,SAASC,EAAiClE,EAAQmE,GAIhD,MAAM/C,EAASpB,EAAO8B,aACP7E,IAAXmE,GAAwB+C,IAAiBnE,EAAOqC,iBAC7B,IAAjB8B,EAypBR,SAAwC/C,GAKtCA,EAAOgD,cAAgB,IAAIhJ,QAAQ,CAACC,EAASC,KAC3C8F,EAAOiD,sBAAwBhJ,EAC/B+F,EAAOkD,qBAAuBhJ,IAEhC8F,EAAOmD,mBAAqB,UAjqBxBC,CAA+BpD,GAI/BqD,GAAiCrD,IAIrCpB,EAAOqC,cAAgB8B,QAGnBtC,4BACJpC,YAAYO,GACV,IAAiC,IAA7BU,EAAiBV,GACnB,MAAM,IAAIlF,UAAU,sFAEtB,IAAuC,IAAnC8F,EAAuBZ,GACzB,MAAM,IAAIlF,UAAU,+EAGtB+E,KAAKwB,qBAAuBrB,EAC5BA,EAAO8B,QAAUjC,KAEjB,MAAMyB,EAAQtB,EAAOuB,OAErB,GAAc,aAAVD,GACkD,IAAhDE,EAAoCxB,KAA8C,IAAzBA,EAAOqC,cA0lB1E,SAA6CjB,GAE3CA,EAAOgD,cAAgB,IAAIhJ,QAAQ,CAACC,EAASC,KAC3C8F,EAAOiD,sBAAwBhJ,EAC/B+F,EAAOkD,qBAAuBhJ,IAEhC8F,EAAOmD,mBAAqB,UA/lBtBG,CAAoC7E,MAEpC8E,GAA8C9E,MAGhD+E,GAAqC/E,WAChC,GAAc,aAAVyB,EACTuD,GAA8ChF,KAAMG,EAAOyB,cAC3D5B,KAAKuE,cAAcH,MAAM,QACzBW,GAAqC/E,WAChC,GAAc,WAAVyB,EACTqD,GAA8C9E,MAwiBpD,SAAwDuB,GACtDA,EAAO4C,eAAiB5I,QAAQC,aAAQ4B,GACxCmE,EAAOuC,4BAAyB1G,EAChCmE,EAAOwC,2BAAwB3G,EAC/BmE,EAAOyC,oBAAsB,WA3iBzBiB,CAA+CjF,UAC1C,CAGL,MAAMwD,EAAcrD,EAAOyB,aAC3BoD,GAA8ChF,KAAMwD,GACpDxD,KAAKuE,cAAcH,MAAM,QA0hB/B,SAAwD7C,EAAQP,GAC9DO,EAAO4C,eAAiB5I,QAAQE,OAAOuF,GACvCO,EAAOuC,4BAAyB1G,EAChCmE,EAAOwC,2BAAwB3G,EAC/BmE,EAAOyC,oBAAsB,WA7hBzBkB,CAA+ClF,KAAMwD,GACrDxD,KAAKmE,eAAeC,MAAM,SAI9Be,aACE,OAA4C,IAAxCC,EAA8BpF,MACzBzE,QAAQE,OAAO4J,GAAiC,WAGlDrF,KAAKmE,eAGdmB,kBACE,IAA4C,IAAxCF,EAA8BpF,MAChC,MAAMqF,GAAiC,eAGzC,QAAkCjI,IAA9B4C,KAAKwB,qBACP,MAAM+D,GAA2B,eAGnC,OAqKJ,SAAmDhE,GACjD,MAAMpB,EAASoB,EAAOC,qBAChBC,EAAQtB,EAAOuB,OAErB,GAAc,YAAVD,GAAiC,aAAVA,EACzB,OAAO,KAGT,GAAc,WAAVA,EACF,OAAO,EAGT,OAAO+D,GAA8CrF,EAAO+B,2BAjLnDuD,CAA0CzF,MAGnD0F,YACE,OAA4C,IAAxCN,EAA8BpF,MACzBzE,QAAQE,OAAO4J,GAAiC,UAGlDrF,KAAKuE,cAGd3E,MAAMoB,GACJ,OAA4C,IAAxCoE,EAA8BpF,MACzBzE,QAAQE,OAAO4J,GAAiC,eAGvBjI,IAA9B4C,KAAKwB,qBACAjG,QAAQE,OAAO8J,GAA2B,UAqEvD,SAA0ChE,EAAQP,GAKhD,OAAOC,EAJQM,EAAOC,qBAIaR,GAvE1B2E,CAAiC3F,KAAMgB,GAGhDpB,QACE,IAA4C,IAAxCwF,EAA8BpF,MAChC,OAAOzE,QAAQE,OAAO4J,GAAiC,UAGzD,MAAMlF,EAASH,KAAKwB,qBAEpB,YAAepE,IAAX+C,EACK5E,QAAQE,OAAO8J,GAA2B,WAGC,IAAhD5D,EAAoCxB,GAC/B5E,QAAQE,OAAO,IAAIR,UAAU,2CAG/B4G,EAAiC7B,MAG1CJ,cACE,IAA4C,IAAxCwF,EAA8BpF,MAChC,MAAMqF,GAAiC,oBAK1BjI,IAFA4C,KAAKwB,sBAQpBM,GAAmC9B,MAGrCJ,MAAM7B,GACJ,OAA4C,IAAxCqH,EAA8BpF,MACzBzE,QAAQE,OAAO4J,GAAiC,eAGvBjI,IAA9B4C,KAAKwB,qBACAjG,QAAQE,OAAO8J,GAA2B,aAG5CxD,GAAiC/B,KAAMjC,IAMlD,SAASqH,EAA8BzK,GACrC,QAAKqE,EAAarE,MAIbmB,OAAOX,UAAUsH,eAAepH,KAAKV,EAAG,wBAiB/C,SAASkH,EAAiCN,GACxC,MAAMpB,EAASoB,EAAOC,qBAIhBC,EAAQtB,EAAOuB,OACrB,GAAc,WAAVD,GAAgC,YAAVA,EACxB,OAAOlG,QAAQE,OAAO,IAAIR,4BACNwG,+DAMtB,MAAMmB,EAAU,IAAIrH,QAAQ,CAACC,EAASC,KACpC,MAAMmK,GACJ/C,SAAUrH,EACVsH,QAASrH,GAGX0E,EAAOkC,cAAgBuD,IASzB,OAN6B,IAAzBzF,EAAOqC,eAAoC,aAAVf,GACnCmD,GAAiCrD,GAiOrC,SAA8CnB,GAC5Cf,EAAqBe,EAAY,QAAS,GAC1CyF,GAAoDzF,GAhOpD0F,CAAqC3F,EAAO+B,2BAErCU,EAuBT,SAASmD,EAAuDxE,EAAQ4B,GACnC,YAA/B5B,EAAOyC,oBACTE,GAAiC3C,EAAQ4B,GAwY7C,SAAmD5B,EAAQP,GAKzDO,EAAO4C,eAAiB5I,QAAQE,OAAOuF,GACvCO,EAAOyC,oBAAsB,WA5Y3BgC,CAA0CzE,EAAQ4B,GAEpD5B,EAAO4C,eAAeC,MAAM,QAG9B,SAASf,GAAsD9B,EAAQ4B,GAEnC,YAA9B5B,EAAOmD,mBA4ab,SAAyCnD,EAAQP,GAK/CO,EAAOkD,qBAAqBzD,GAC5BO,EAAOiD,2BAAwBpH,EAC/BmE,EAAOkD,0BAAuBrH,EAC9BmE,EAAOmD,mBAAqB,WAnb1BuB,CAAgC1E,EAAQ4B,GAkc5C,SAAkD5B,EAAQP,GAKxDO,EAAOgD,cAAgBhJ,QAAQE,OAAOuF,GACtCO,EAAOmD,mBAAqB,WAtc1BwB,CAAyC3E,EAAQ4B,GAEnD5B,EAAOgD,cAAcH,MAAM,QAkB7B,SAAStC,GAAmCP,GAC1C,MAAMpB,EAASoB,EAAOC,qBAIhB2E,EAAgB,IAAIlL,UACxB,oFAEFoI,GAAsD9B,EAAQ4E,GAI9DJ,EAAuDxE,EAAQ4E,GAE/DhG,EAAO8B,aAAU7E,EACjBmE,EAAOC,0BAAuBpE,EAGhC,SAAS2E,GAAiCR,EAAQxD,GAChD,MAAMoC,EAASoB,EAAOC,qBAIhBpB,EAAaD,EAAO+B,0BAEpBkE,EA+IR,SAAqDhG,EAAYrC,GAC/D,IACE,OAAOqC,EAAWiG,uBAAuBtI,GACzC,MAAOuI,GAEP,OADAjF,GAA6CjB,EAAYkG,GAClD,GApJSC,CAA4CnG,EAAYrC,GAE1E,GAAIoC,IAAWoB,EAAOC,qBACpB,OAAOjG,QAAQE,OAAO8J,GAA2B,aAGnD,MAAM9D,EAAQtB,EAAOuB,OACrB,GAAc,YAAVD,EACF,OAAOlG,QAAQE,OAAO0E,EAAOyB,cAE/B,IAAoD,IAAhDD,EAAoCxB,IAA8B,WAAVsB,EAC1D,OAAOlG,QAAQE,OAAO,IAAIR,UAAU,6DAEtC,GAAc,aAAVwG,EACF,OAAOlG,QAAQE,OAAO0E,EAAOyB,cAK/B,MAAMgB,EA/eR,SAAuCzC,GAarC,OATgB,IAAI5E,QAAQ,CAACC,EAASC,KACpC,MAAMgI,GACJZ,SAAUrH,EACVsH,QAASrH,GAGX0E,EAAOgC,eAAexD,KAAK8E,KAqeb+C,CAA8BrG,GAI9C,OAqIF,SAA8CC,EAAYrC,EAAOqI,GAC/D,MAAMK,GAAgB1I,MAAAA,GAEtB,IACEsB,EAAqBe,EAAYqG,EAAaL,GAC9C,MAAOM,GAEP,YADArF,GAA6CjB,EAAYsG,GAI3D,MAAMvG,EAASC,EAAWuG,0BAC1B,IAAoD,IAAhDhF,EAAoCxB,IAAuC,aAAlBA,EAAOuB,OAAuB,CACzF,MAAM4C,EAAesC,GAA+CxG,GACpEiE,EAAiClE,EAAQmE,GAG3CuB,GAAoDzF,GAvJpDyG,CAAqCzG,EAAYrC,EAAOqI,GAEjDxD,QAGHtC,gCACJV,cACE,MAAM,IAAI3E,UAAU,oEAGtB2E,MAAM1B,GACJ,IAAgD,IA2BpD,SAA2CvD,GACzC,IAAKqE,EAAarE,GAChB,OAAO,EAGT,IAAKmB,OAAOX,UAAUsH,eAAepH,KAAKV,EAAG,6BAC3C,OAAO,EAGT,OAAO,EApCDmM,CAAkC9G,MACpC,MAAM,IAAI/E,UACR,yGAGU,aADA+E,KAAK2G,0BAA0BjF,QAO7CqF,GAAqC/G,KAAM9B,GAG7C0B,CAACH,GAAYuB,GACX,MAAMgG,EAAShH,KAAKiH,gBAAgBjG,GAEpC,OADAkG,GAA+ClH,MACxCgH,EAGTpH,CAACF,KACCH,EAAWS,OAkBf,SAASU,GAAqCP,EAAQC,EAAYgB,EAAgBb,EAAgBC,EACpDC,EAAgB7C,EAAesC,GAI3EE,EAAWuG,0BAA4BxG,EACvCA,EAAO+B,0BAA4B9B,EAGnCA,EAAW5B,YAASpB,EACpBgD,EAAW1B,qBAAkBtB,EAC7BmC,EAAWa,GAEXA,EAAWmD,UAAW,EAEtBnD,EAAWiG,uBAAyBnG,EACpCE,EAAW+G,aAAevJ,EAE1BwC,EAAWgH,gBAAkB7G,EAC7BH,EAAWiH,gBAAkB7G,EAC7BJ,EAAW6G,gBAAkBxG,EAE7B,MAAM6D,EAAesC,GAA+CxG,GACpEiE,EAAiClE,EAAQmE,GAEzC,MAAMgD,EAAclG,IACC7F,QAAQC,QAAQ8L,GACxB1D,KACT,KAEExD,EAAWmD,UAAW,EACtBsC,GAAoDzF,IAEtDmH,IAEEnH,EAAWmD,UAAW,EACtBL,EAAgC/C,EAAQoH,KAG7CnD,MAAMlF,GAqBT,SAASgI,GAA+C9G,GACtDA,EAAWgH,qBAAkBhK,EAC7BgD,EAAWiH,qBAAkBjK,EAC7BgD,EAAW6G,qBAAkB7J,EAC7BgD,EAAWiG,4BAAyBjJ,EAiBtC,SAASoI,GAA8CpF,GACrD,OAAOA,EAAW+G,aAAe/G,EAAW1B,gBAwB9C,SAASmH,GAAoDzF,GAE3D,MAAMD,EAASC,EAAWuG,0BAE1B,IAA4B,IAAxBvG,EAAWmD,SACb,OAGF,QAAqCnG,IAAjC+C,EAAOiC,sBACT,OAGF,MAAMX,EAAQtB,EAAOuB,OACrB,GAAc,WAAVD,GAAgC,YAAVA,EACxB,OAEF,GAAc,aAAVA,EAEF,YADA2B,EAA6BjD,GAI/B,GAAiC,IAA7BC,EAAW5B,OAAOgJ,OACpB,OAGF,MAAMf,EAAcnH,EAAec,GACf,UAAhBqG,EAaN,SAAqDrG,GACnD,MAAMD,EAASC,EAAWuG,2BA9gB5B,SAAgDxG,GAG9CA,EAAOmC,sBAAwBnC,EAAOkC,cACtClC,EAAOkC,mBAAgBjF,GA4gBvBqK,CAAuCtH,GAEvCf,EAAagB,GAGb,MAAMsH,EAAmBtH,EAAWiH,kBACpCH,GAA+C9G,GAC/CsH,EAAiB9D,KACf,KACEC,EAAkC1D,IAEpCa,KA7jBJ,SAAoDb,EAAQgD,GAE1DhD,EAAOmC,sBAAsBQ,QAAQK,GACrChD,EAAOmC,2BAAwBlF,OAKKA,IAAhC+C,EAAOoC,uBACTpC,EAAOoC,qBAAqBO,QAAQK,GACpChD,EAAOoC,0BAAuBnF,GAEhC8F,EAAgC/C,EAAQgD,GAkjBpCwE,CAA2CxH,EAAQa,KAGtDoD,MAAMlF,GA9BL0I,CAA4CxH,GAiChD,SAAqDA,EAAYrC,GAC/D,MAAMoC,EAASC,EAAWuG,2BA5hB5B,SAAqDxG,GAGnDA,EAAOiC,sBAAwBjC,EAAOgC,eAAe1D,SA2hBrDoJ,CAA4C1H,GAEnBC,EAAWgH,gBAAgBrJ,GACnC6F,KACf,MAxnBJ,SAA2CzD,GAEzCA,EAAOiC,sBAAsBS,cAASzF,GACtC+C,EAAOiC,2BAAwBhF,EAsnB3B0K,CAAkC3H,GAElC,MAAMsB,EAAQtB,EAAOuB,OAKrB,GAFAtC,EAAagB,IAEuC,IAAhDuB,EAAoCxB,IAA+B,aAAVsB,EAAsB,CACjF,MAAM6C,EAAesC,GAA+CxG,GACpEiE,EAAiClE,EAAQmE,GAG3CuB,GAAoDzF,IAEtDY,IACwB,aAAlBb,EAAOuB,QACTwF,GAA+C9G,GAnoBvD,SAAoDD,EAAQgD,GAE1DhD,EAAOiC,sBAAsBU,QAAQK,GACrChD,EAAOiC,2BAAwBhF,EAI/B8F,EAAgC/C,EAAQgD,GA8nBpC4E,CAA2C5H,EAAQa,KAGtDoD,MAAMlF,GA5DL8I,CAA4C5H,EAAYqG,EAAY1I,OAIxE,SAASsD,GAA6CjB,EAAY+C,GACZ,aAAhD/C,EAAWuG,0BAA0BjF,QACvCqF,GAAqC3G,EAAY+C,GAyDrD,SAASyD,GAA+CxG,GAEtD,OADoBoF,GAA8CpF,IAC5C,EAKxB,SAAS2G,GAAqC3G,EAAY+C,GACxD,MAAMhD,EAASC,EAAWuG,0BAI1BO,GAA+C9G,GAC/C6C,EAA4B9C,EAAQgD,GAKtC,SAASrC,GAA0BmH,GACjC,OAAO,IAAIhN,sCAAsCgN,0CAKnD,SAAS5C,GAAiC4C,GACxC,OAAO,IAAIhN,mDACgCgN,uDAG7C,SAAS1C,GAA2B0C,GAClC,OAAO,IAAIhN,UAAU,UAAYgN,EAAO,qCAG1C,SAASlD,GAAqCxD,GAC5CA,EAAO4C,eAAiB,IAAI5I,QAAQ,CAACC,EAASC,KAC5C8F,EAAOuC,uBAAyBtI,EAChC+F,EAAOwC,sBAAwBtI,EAC/B8F,EAAOyC,oBAAsB,YAkBjC,SAASE,GAAiC3C,EAAQP,GAKhDO,EAAOwC,sBAAsB/C,GAC7BO,EAAOuC,4BAAyB1G,EAChCmE,EAAOwC,2BAAwB3G,EAC/BmE,EAAOyC,oBAAsB,WAgC/B,SAASgB,GAA8CzD,EAAQP,GAE7DO,EAAOgD,cAAgBhJ,QAAQE,OAAOuF,GACtCO,EAAOiD,2BAAwBpH,EAC/BmE,EAAOkD,0BAAuBrH,EAC9BmE,EAAOmD,mBAAqB,WAG9B,SAASI,GAA8CvD,GAErDA,EAAOgD,cAAgBhJ,QAAQC,aAAQ4B,GACvCmE,EAAOiD,2BAAwBpH,EAC/BmE,EAAOkD,0BAAuBrH,EAC9BmE,EAAOmD,mBAAqB,YAmC9B,SAASE,GAAiCrD,GAKxCA,EAAOiD,2BAAsBpH,GAC7BmE,EAAOiD,2BAAwBpH,EAC/BmE,EAAOkD,0BAAuBrH,EAC9BmE,EAAOmD,mBAAqB,oCClkC9B,MAAMwD,gBAAEA,uCAAiBtJ,6BAAqCR,gBAA2BS,GAAYsJ,iBAC7FA,GAAgBC,oBAAEA,qCAAqBtJ,uBAAmClC,qCAC1EmC,GAAiCsJ,oBAAEA,gBAAqBrJ,IAAiBX,kCACzEa,IAAmCD,gBACnCG,wBAAcC,cAAsBE,IAAeJ,sCACnD+B,oBAAoCL,0BAAkBE,uBACtDE,wDAAqBK,sCACrBQ,oCAAoCC,uCAAkCJ,IACxEnC,EAEA8I,GAAcjO,EAAO,mBACrBkO,GAAYlO,EAAO,uBAEnBmO,eACJ5I,YAAY6I,KAAuB3I,MACjC4I,GAAyB1I,MAEzB,MAAMlC,EAAOgC,EAAShC,KACtB,IAAIF,EAAgBkC,EAASlC,cAE7B,MAAMqC,EAAOwI,EAAiBxI,KAE9B,GAAmB,UADA0I,OAAO1I,GACE,CAC1B,QAAa7C,IAATU,EACF,MAAM,IAAID,WAAW,mEAGDT,IAAlBQ,IACFA,EAAgB,GAi2DxB,SAA+DuC,EAAQyI,EAAsBhL,GAG3F,MAAMwC,EAAatE,OAAOuE,OAAOwI,6BAA6B1N,WAM9D,MAAM2N,EAAgBlK,GAAoCgK,EAAsB,OAAQ,GAAIxI,IACtF2I,EAAkBnK,GAAoCgK,EAAsB,SAAU,MAE5F,IAAII,EAAwBJ,EAAqBI,sBACjD,QAA8B5L,IAA1B4L,IACFA,EAAwBlP,OAAOkP,IACiB,IAA5CC,EAAiBD,IAAoCA,GAAyB,GAChF,MAAM,IAAInL,WAAW,oDAIzBqL,GAAkC/I,EAAQC,EAf1C,WACE,OAAOvB,GAAa+J,EAAsB,SAAUxI,KAcgB0I,EAAeC,EAAiBnL,EACpEoL,GAl3D9BG,CAAsDnJ,KAAMyI,EAF5D7K,EAAgBkB,GAAkClB,QAG7C,CAAA,QAAaR,IAAT6C,EAUT,MAAM,IAAIpC,WAAW,6BAVQ,CAC7B,MAAMqC,EAAgBnB,GAAkCjB,QAElCV,IAAlBQ,IACFA,EAAgB,GA+mCxB,SAAkEuC,EAAQsI,EAAkB7K,EAC1BsC,GAGhE,MAAME,EAAatE,OAAOuE,OAAO+I,gCAAgCjO,WAMjE,MAAM2N,EAAgBlK,GAAoC6J,EAAkB,OAAQ,GAAIrI,IAClF2I,EAAkBnK,GAAoC6J,EAAkB,SAAU,MAExFY,GAAqClJ,EAAQC,EAP7C,WACE,OAAOvB,GAAa4J,EAAkB,SAAUrI,KAMuB0I,EAAeC,EACnDnL,EAAesC,GAznChDoJ,CAAyDtJ,KAAMyI,EAF/D7K,EAAgBkB,GAAkClB,GAE8CsC,KAMpGU,aACE,IAA+B,IAA3B2I,GAAiBvJ,MACnB,MAAMc,GAA0B,UAGlC,OAAO0I,GAAuBxJ,MAGhCJ,OAAOoB,GACL,OAA+B,IAA3BuI,GAAiBvJ,MACZzE,QAAQE,OAAOqF,GAA0B,YAGb,IAAjC0I,GAAuBxJ,MAClBzE,QAAQE,OAAO,IAAIR,UAAU,qDAG/BwO,GAAqBzJ,KAAMgB,GAGpCpB,WAAU8J,KAAEA,OACV,IAA+B,IAA3BH,GAAiBvJ,MACnB,MAAMc,GAA0B,aAGlC,QAAa1D,IAATsM,EACF,OAAOC,GAAmC3J,MAK5C,GAAa,UAFb0J,EAAOf,OAAOe,IAGZ,OA6MN,SAAyCvJ,GACvC,OAAO,IAAIyJ,yBAAyBzJ,GA9MzB0J,CAAgC7J,MAGzC,MAAM,IAAInC,WAAW,6BAGvB+B,aAAY5D,SAAEA,EAAQ8N,SAAEA,GAAYC,GAClC,QAAiB3M,IAAbpB,QAAuCoB,IAAb0M,EAC5B,MAAM,IAAI7O,UAAU,mDAOtB,OA65DJ,SAAgF2H,GAC9E,IAGErH,QAAQJ,UAAUyI,KAAKvI,KAAKuH,OAASxF,EAAW,QAChD,MAAOc,KAp6DP8L,CAFgBhK,KAAKiK,OAAOjO,EAAU+N,IAI/BD,EAGTlK,OAAOvD,GAAM6N,aAAEA,EAAYC,aAAEA,EAAYC,cAAEA,OACzC,IAA+B,IAA3Bb,GAAiBvJ,MACnB,OAAOzE,QAAQE,OAAOqF,GAA0B,WAElD,IAA+B,IAA3BD,GAAiBxE,GACnB,OAAOd,QAAQE,OACb,IAAIR,UAAU,8EAOlB,GAJAiP,EAAeG,QAAQH,GACvBC,EAAeE,QAAQF,GACvBC,EAAgBC,QAAQD,IAEa,IAAjCZ,GAAuBxJ,MACzB,OAAOzE,QAAQE,OAAO,IAAIR,UAAU,8EAEtC,IAAqC,IAAjC8F,GAAuB1E,GACzB,OAAOd,QAAQE,OAAO,IAAIR,UAAU,8EAGtC,MAAMqP,EAASX,GAAmC3J,MAC5CuB,EAASL,GAAmC7E,GAElD,IAAIkO,GAAe,EAGfC,EAAejP,QAAQC,UAE3B,OAAO,IAAID,QAAQ,CAACC,EAASC,KAiD3B,GA3BAgP,EAAmBzK,KAAMsK,EAAOnG,eAAgBX,KACzB,IAAjB2G,EACFO,EAAmB,IAAMzJ,GAAoB5E,EAAMmH,IAAc,EAAMA,GAEvEmH,GAAS,EAAMnH,KAKnBiH,EAAmBpO,EAAMkF,EAAO4C,eAAgBX,KACxB,IAAlB4G,EACFM,EAAmB,IAAMjB,GAAqBzJ,KAAMwD,IAAc,EAAMA,GAExEmH,GAAS,EAAMnH,KA4CnB,SAA2BrD,EAAQyC,EAASgI,GACpB,WAAlBzK,EAAOuB,OACTkJ,IAEAhI,EAAQgB,KAAKgH,GAAQxG,MAAMlF,IA3C/B2L,CAAkB7K,KAAMsK,EAAOnG,eAAgB,MACxB,IAAjB+F,EACFQ,EAAmB,IAAMpJ,GAAqDC,IAE9EoJ,OAK8C,IAA9ChJ,GAAoCtF,IAAkC,WAAhBA,EAAKqF,OAAqB,CAClF,MAAMoJ,EAAa,IAAI7P,UAAU,gFAEX,IAAlBmP,EACFM,EAAmB,IAAMjB,GAAqBzJ,KAAM8K,IAAa,EAAMA,GAEvEH,GAAS,EAAMG,GASnB,SAASC,IAGP,MAAMC,EAAkBR,EACxB,OAAOA,EAAa5G,KAAK,IAAMoH,IAAoBR,EAAeO,SAA0B3N,GAG9F,SAASqN,EAAmBtK,EAAQyC,EAASgI,GACrB,YAAlBzK,EAAOuB,OACTkJ,EAAOzK,EAAOyB,cAEdgB,EAAQwB,MAAMwG,GAAQxG,MAAMlF,IAYhC,SAASwL,EAAmBE,EAAQK,EAAiBC,GAYnD,SAASC,IACPP,IAAShH,KACP,IAAMwH,EAASH,EAAiBC,GAChCG,GAAYD,GAAS,EAAMC,IAE5BjH,MAAMlF,KAhBY,IAAjBqL,IAGJA,GAAe,EAEK,aAAhBlO,EAAKqF,SAAuE,IAA9CC,GAAoCtF,GACpE0O,IAAwBnH,KAAKuH,GAE7BA,KAYJ,SAASR,EAASW,EAASnI,IACJ,IAAjBoH,IAGJA,GAAe,EAEK,aAAhBlO,EAAKqF,SAAuE,IAA9CC,GAAoCtF,GACpE0O,IAAwBnH,KAAK,IAAMwH,EAASE,EAASnI,IAAQiB,MAAMlF,IAEnEkM,EAASE,EAASnI,IAItB,SAASiI,EAASE,EAASnI,GACzBrB,GAAmCP,GACnCgK,GAAmCjB,GAE/BgB,EACF7P,EAAO0H,GAEP3H,OAAQ4B,IA5HZ,SAASoO,IACP,OAAqB,IAAjBjB,EACKhP,QAAQC,UAGV+F,EAAOgD,cAAcX,KAAK,IACxB6H,GAAgCnB,GAAQ1G,KAAK,EAAG5J,MAAAA,EAAO0R,KAAAA,OAC/C,IAATA,IAIJlB,EAAezI,GAAiCR,EAAQvH,GAAOoK,MAAM,YAGxER,KAAK4H,IAyCRA,GAAWpH,MAAMuH,IACfnB,EAAejP,QAAQC,UACvB0D,GAA+ByM,OAyErC/L,MACE,IAA+B,IAA3B2J,GAAiBvJ,MACnB,MAAMc,GAA0B,OAGlC,MAAM8K,EAoGV,SAA2BzL,EAAQ0L,GAIjC,MAAMvB,EAASX,GAAmCxJ,GAElD,IAGI2L,EACAC,EACAC,EACAC,EAEAC,EARAC,GAAkB,EAClBC,GAAY,EACZC,GAAY,EAOhB,MAAMC,EAAgB,IAAI/Q,QAAQC,IAChC0Q,EAAuB1Q,IAGzB,SAASsN,IACP,OAAO2C,GAAgCnB,GAAQ1G,KAAKoD,IAElD,MAAMhN,EAAQgN,EAAOhN,MACf0R,EAAO1E,EAAO0E,KAapB,IAVa,IAATA,IAAqC,IAApBS,KACD,IAAdC,GACFG,GAAqCP,EAAQQ,4BAE7B,IAAdH,GACFE,GAAqCN,EAAQO,2BAE/CL,GAAkB,IAGI,IAApBA,EACF,OAGF,MAAMM,EAASzS,EACT0S,EAAS1S,GAQG,IAAdoS,GACFO,GAAuCX,EAAQQ,0BAA2BC,IAG1D,IAAdJ,GACFM,GAAuCV,EAAQO,0BAA2BE,KA2BhF,SAAStL,KAeT,OAbA4K,EAAUY,GAAqBxL,EAAgB0H,EAxB/C,SAA0B9H,GAGxB,GAFAoL,GAAY,EACZN,EAAU9K,GACQ,IAAdqL,EAAoB,CACtB,MAAMQ,EAAkBxE,IAAqByD,EAASC,IAChDe,EAAerD,GAAqBtJ,EAAQ0M,GAClDX,EAAqBY,GAEvB,OAAOR,IAiBTL,EAAUW,GAAqBxL,EAAgB0H,EAd/C,SAA0B9H,GAGxB,GAFAqL,GAAY,EACZN,EAAU/K,GACQ,IAAdoL,EAAoB,CACtB,MAAMS,EAAkBxE,IAAqByD,EAASC,IAChDe,EAAerD,GAAqBtJ,EAAQ0M,GAClDX,EAAqBY,GAEvB,OAAOR,IAQThC,EAAOnG,eAAeC,MAAMmD,KACF,IAApB4E,IAIJY,GAAqCf,EAAQQ,0BAA2BjF,GACxEwF,GAAqCd,EAAQO,0BAA2BjF,GACxE4E,GAAkB,MAGZH,EAASC,GApMEe,CAAkBhN,MACnC,OAAOqI,GAAoBuD,IAI/B,QACEqB,yBAwCF,SAAkC7L,EAAgB0H,EAAeC,EAAiBnL,EAAgB,EAChEoL,GAOhC,MAAM7I,EAASrE,OAAOuE,OAAOmI,eAAerN,WAC5CuN,GAAyBvI,GAEzB,MAAMC,EAAatE,OAAOuE,OAAOwI,6BAA6B1N,WAK9D,OAHA+N,GAAkC/I,EAAQC,EAAYgB,EAAgB0H,EAAeC,EAAiBnL,EACpEoL,GAE3B7I,GAvDPyM,qBAAAA,GACApE,eAAAA,eACA0E,0BA2EF,SAAmC/M,GAGjC,OAAOA,EAAOgN,YA7EdZ,qCAAAA,GACAI,uCAAAA,GACAI,qCAAAA,GACAK,8CAAAA,GACAC,+CAo0BF,SAAwDjN,GACtD,IAAkE,IAA9DkN,GAA8ClN,GAChD,OAAO,EAGT,OAAO,GAx0BPmN,iDAAAA,IASF,SAAS5D,GAAmCxJ,GAC1C,OAAO,IAAIqN,4BAA4BrN,GAIzC,SAASyM,GAAqBxL,EAAgB0H,EAAeC,EAAiBnL,EAAgB,EAChEsC,EAAgB,KAAM,IAGlD,MAAMC,EAASrE,OAAOuE,OAAOmI,eAAerN,WAS5C,OARAuN,GAAyBvI,GAIzBkJ,GACIlJ,EAHerE,OAAOuE,OAAO+I,gCAAgCjO,WAGzCiG,EAAgB0H,EAAeC,EAAiBnL,EAAesC,GAGhFC,EAuBT,SAASuI,GAAyBvI,GAChCA,EAAOuB,OAAS,WAChBvB,EAAOsN,aAAUrQ,EACjB+C,EAAOyB,kBAAexE,EACtB+C,EAAOgN,YAAa,EAGtB,SAAS5D,GAAiB5O,GACxB,QAAKqE,GAAarE,MAIbmB,OAAOX,UAAUsH,eAAepH,KAAKV,EAAG,6BAa/C,SAAS6O,GAAuBrJ,GAG9B,YAAuB/C,IAAnB+C,EAAOsN,QA4Gb,SAASC,GAAiCvN,EAAQwN,GAchD,OAVgB,IAAIpS,QAAQ,CAACC,EAASC,KACpC,MAAMmS,GACJ/K,SAAUrH,EACVsH,QAASrH,EACToS,eAAgBF,GAGlBxN,EAAOsN,QAAQK,kBAAkBnP,KAAKiP,KAM1C,SAASG,GAA6B5N,EAAQwN,GAc5C,OAVgB,IAAIpS,QAAQ,CAACC,EAASC,KACpC,MAAMuS,GACJnL,SAAUrH,EACVsH,QAASrH,EACToS,eAAgBF,GAGlBxN,EAAOsN,QAAQQ,cAActP,KAAKqP,KAMtC,SAASvE,GAAqBtJ,EAAQa,GAGpC,GAFAb,EAAOgN,YAAa,EAEE,WAAlBhN,EAAOuB,OACT,OAAOnG,QAAQC,aAAQ4B,GAEzB,GAAsB,YAAlB+C,EAAOuB,OACT,OAAOnG,QAAQE,OAAO0E,EAAOyB,cAM/B,OAHAsM,GAAoB/N,GAEQA,EAAOqM,0BAA0BlE,IAAatH,GAC/C4C,KAAK,SAAMxG,GAGxC,SAAS8Q,GAAoB/N,GAG3BA,EAAOuB,OAAS,SAEhB,MAAM4I,EAASnK,EAAOsN,QAEtB,QAAerQ,IAAXkN,EAAJ,CAIA,IAA8C,IAA1C6D,GAA8B7D,GAAkB,CAClD,IAAK,MAAMzH,SAAEA,EAAQgL,eAAEA,KAAoBvD,EAAO2D,cAChDpL,EAASuL,QAA+BhR,GAAW,EAAMyQ,IAE3DvD,EAAO2D,kBAk8CX,SAA2C3D,GAIzCA,EAAOxG,4BAAuB1G,GAC9BkN,EAAOxG,4BAAyB1G,EAChCkN,EAAOvG,2BAAwB3G,EAr8C/BiR,CAAkC/D,IAKpC,SAAS8D,GAA+BpU,EAAO0R,EAAMiC,GACnD,IAAIxS,EAAY,MACM,IAAlBwS,IACFxS,EAAYW,OAAOX,WAGrB,MAAMmT,EAAMxS,OAAOuE,OAAOlF,GAG1B,OAFAW,OAAOC,eAAeuS,EAAK,SAAWtU,MAAAA,EAAOiC,YAAY,EAAMD,UAAU,EAAME,cAAc,IAC7FJ,OAAOC,eAAeuS,EAAK,QAAUtU,MAAO0R,EAAMzP,YAAY,EAAMD,UAAU,EAAME,cAAc,IAC3FoS,EAGT,SAASC,GAAoBpO,EAAQjC,GAInCiC,EAAOuB,OAAS,UAChBvB,EAAOyB,aAAe1D,EAEtB,MAAMoM,EAASnK,EAAOsN,QAEtB,QAAerQ,IAAXkN,EAAJ,CAIA,IAA8C,IAA1C6D,GAA8B7D,GAAkB,CAClD,IAAK,MAAM0D,KAAe1D,EAAO2D,cAC/BD,EAAYlL,QAAQ5E,GAGtBoM,EAAO2D,qBACF,CAGL,IAAK,MAAML,KAAmBtD,EAAOwD,kBACnCF,EAAgB9K,QAAQ5E,GAG1BoM,EAAOwD,qBAGTU,GAAiClE,EAAQpM,GACzCoM,EAAOnG,eAAeC,MAAM,SAY9B,SAASqK,GAAiCtO,EAAQpC,EAAO2N,GACvD,MAIMsC,EAJS7N,EAAOsN,QAIKQ,cAAcxP,QACzCuP,EAAYnL,SAASuL,GAA+BrQ,EAAO2N,EAAMsC,EAAYH,iBAG/E,SAASa,GAAqCvO,GAC5C,OAAOA,EAAOsN,QAAQK,kBAAkBtG,OAG1C,SAASmH,GAAiCxO,GACxC,OAAOA,EAAOsN,QAAQQ,cAAczG,OAGtC,SAASoH,GAA4BzO,GACnC,MAAMmK,EAASnK,EAAOsN,QAEtB,YAAerQ,IAAXkN,IAIuC,IAAvCuE,GAA2BvE,GAOjC,SAASwE,GAA+B3O,GACtC,MAAMmK,EAASnK,EAAOsN,QAEtB,YAAerQ,IAAXkN,IAI0C,IAA1C6D,GAA8B7D,SAS9BkD,4BACJ5N,YAAYO,GACV,IAAiC,IAA7BoJ,GAAiBpJ,GACnB,MAAM,IAAIlF,UAAU,sFAEtB,IAAuC,IAAnCuO,GAAuBrJ,GACzB,MAAM,IAAIlF,UAAU,+EAGtB8T,GAAsC/O,KAAMG,GAE5CH,KAAKiO,iBAGP9I,aACE,OAA4C,IAAxCgJ,GAA8BnO,MACzBzE,QAAQE,OAAOuT,GAAiC,WAGlDhP,KAAKmE,eAGdvE,OAAOoB,GACL,OAA4C,IAAxCmN,GAA8BnO,MACzBzE,QAAQE,OAAOuT,GAAiC,gBAGvB5R,IAA9B4C,KAAKiP,qBACA1T,QAAQE,OAAOyT,GAAoB,WAGrCC,GAAkCnP,KAAMgB,GAGjDpB,OACE,OAA4C,IAAxCuO,GAA8BnO,MACzBzE,QAAQE,OAAOuT,GAAiC,cAGvB5R,IAA9B4C,KAAKiP,qBACA1T,QAAQE,OAAOyT,GAAoB,cAGrCzD,GAAgCzL,MAAM,GAG/CJ,cACE,IAA4C,IAAxCuO,GAA8BnO,MAChC,MAAMgP,GAAiC,eAGzC,QAAkC5R,IAA9B4C,KAAKiP,qBAAT,CAIA,GAAIjP,KAAKiO,cAAczG,OAAS,EAC9B,MAAM,IAAIvM,UAAU,uFAGtBsQ,GAAmCvL,cAIjC4J,yBACJhK,YAAYO,GACV,IAAKoJ,GAAiBpJ,GACpB,MAAM,IAAIlF,UAAU,uGAGtB,IAAyE,IAArEmU,GAA+BjP,EAAOqM,2BACxC,MAAM,IAAIvR,UAAU,+FAGtB,GAAIuO,GAAuBrJ,GACzB,MAAM,IAAIlF,UAAU,+EAGtB8T,GAAsC/O,KAAMG,GAE5CH,KAAK8N,qBAGP3I,aACE,OAAK0J,GAA2B7O,MAIzBA,KAAKmE,eAHH5I,QAAQE,OAAO4T,GAA8B,WAMxDzP,OAAOoB,GACL,OAAK6N,GAA2B7O,WAIE5C,IAA9B4C,KAAKiP,qBACA1T,QAAQE,OAAOyT,GAAoB,WAGrCC,GAAkCnP,KAAMgB,GAPtCzF,QAAQE,OAAO4T,GAA8B,WAUxDzP,KAAK0P,GACH,OAAKT,GAA2B7O,WAIE5C,IAA9B4C,KAAKiP,qBACA1T,QAAQE,OAAOyT,GAAoB,cAGvCK,YAAYC,OAAOF,IAIc,IAAlCnH,GAAiBmH,EAAKG,QACjBlU,QAAQE,OAAO,IAAIR,UAAU,wDAGd,IAApBqU,EAAKI,WACAnU,QAAQE,OAAO,IAAIR,UAAU,uCA6F1C,SAAsCqP,EAAQgF,EAAM3B,GAAgB,GAClE,MAAMxN,EAASmK,EAAO2E,qBAMtB,GAFA9O,EAAOgN,YAAa,EAEE,YAAlBhN,EAAOuB,OACT,OAAOnG,QAAQE,OAAO0E,EAAOyB,cAI/B,OAgtBF,SAA8CxB,EAAYkP,EAAM3B,GAC9D,MAAMxN,EAASC,EAAWuP,8BAE1B,IAAIC,EAAc,EACdN,EAAKO,cAAgBC,WACvBF,EAAcN,EAAKO,YAAYE,mBAGjC,MAAMC,EAAOV,EAAKO,YAGZI,GACJR,OAFarH,GAAoBkH,EAAKG,QAGtCS,WAAYZ,EAAKY,WACjBR,WAAYJ,EAAKI,WACjBS,YAAa,EACbP,YAAAA,EACAI,KAAAA,EACAI,WAAY,QAGd,GAAIhQ,EAAWiQ,kBAAkB7I,OAAS,EAOxC,OANApH,EAAWiQ,kBAAkB1R,KAAKsR,GAM3BvC,GAAiCvN,EAAQwN,GAGlD,GAAsB,WAAlBxN,EAAOuB,OAAqB,CAC9B,MAAM4O,EAAY,IAAIhB,EAAKO,YAAYI,EAAmBR,OAAQQ,EAAmBC,WAAY,GACjG,OAAO3U,QAAQC,QAAQ4S,GAA+BkC,GAAW,EAAM3C,IAGzE,GAAIvN,EAAW1B,gBAAkB,EAAG,CAClC,IAAoG,IAAhG6R,GAA4DnQ,EAAY6P,GAA8B,CACxG,MAAMO,EAAaC,GAAsDR,GAIzE,OAFAS,GAA6CtQ,GAEtC7E,QAAQC,QAAQ4S,GAA+BoC,GAAY,EAAO7C,IAG3E,IAAmC,IAA/BvN,EAAWuQ,gBAA0B,CACvC,MAAMzS,EAAI,IAAIjD,UAAU,2DAGxB,OAFA2V,GAAkCxQ,EAAYlC,GAEvC3C,QAAQE,OAAOyC,IAI1BkC,EAAWiQ,kBAAkB1R,KAAKsR,GAElC,MAAMrN,EAAU8K,GAAiCvN,EAAQwN,GAIzD,OAFAkD,GAA6CzQ,GAEtCwC,EA3wBAkO,CAAqC3Q,EAAOqM,0BAA2B8C,EAAM3B,GAtG3EoD,CAA6B/Q,KAAMsP,GAAM,GAXvC/T,QAAQE,OAAO,IAAIR,UAAU,sCAR7BM,QAAQE,OAAO4T,GAA8B,SAsBxDzP,cACE,IAAKiP,GAA2B7O,MAC9B,MAAMqP,GAA8B,eAGtC,QAAkCjS,IAA9B4C,KAAKiP,qBAAT,CAIA,GAAIjP,KAAK8N,kBAAkBtG,OAAS,EAClC,MAAM,IAAIvM,UAAU,uFAGtBsQ,GAAmCvL,QAMvC,SAAS6O,GAA2BlU,GAClC,QAAKqE,GAAarE,MAIbmB,OAAOX,UAAUsH,eAAepH,KAAKV,EAAG,qBAO/C,SAASwT,GAA8BxT,GACrC,QAAKqE,GAAarE,MAIbmB,OAAOX,UAAUsH,eAAepH,KAAKV,EAAG,iBAO/C,SAASoU,GAAsCzE,EAAQnK,GACrDmK,EAAO2E,qBAAuB9O,EAC9BA,EAAOsN,QAAUnD,EAEK,aAAlBnK,EAAOuB,OAqoCb,SAA8C4I,GAC5CA,EAAOnG,eAAiB,IAAI5I,QAAQ,CAACC,EAASC,KAC5C6O,EAAOxG,uBAAyBtI,EAChC8O,EAAOvG,sBAAwBtI,IAvoC/BuV,CAAqC1G,GACV,WAAlBnK,EAAOuB,OAgpCpB,SAAwD4I,GACtDA,EAAOnG,eAAiB5I,QAAQC,aAAQ4B,GACxCkN,EAAOxG,4BAAyB1G,EAChCkN,EAAOvG,2BAAwB3G,EAlpC7B6T,CAA+C3G,KAyoCnD,SAAwDA,EAAQtJ,GAC9DsJ,EAAOnG,eAAiB5I,QAAQE,OAAOuF,GACvCsJ,EAAOxG,4BAAyB1G,EAChCkN,EAAOvG,2BAAwB3G,EAxoC7B8T,CAA+C5G,EAAQnK,EAAOyB,cAC9D0I,EAAOnG,eAAeC,MAAM,SAOhC,SAAS+K,GAAkC7E,EAAQtJ,GAGjD,OAAOyI,GAFQa,EAAO2E,qBAEcjO,GAGtC,SAASuK,GAAmCjB,GAIC,aAAvCA,EAAO2E,qBAAqBvN,OAC9B8M,GACIlE,EACA,IAAIrP,UAAU,qFAqoCtB,SAAmDqP,EAAQtJ,GAIzDsJ,EAAOnG,eAAiB5I,QAAQE,OAAOuF,GAvoCrCmQ,CACI7G,EACA,IAAIrP,UAAU,qFAEpBqP,EAAOnG,eAAeC,MAAM,QAE5BkG,EAAO2E,qBAAqBxB,aAAUrQ,EACtCkN,EAAO2E,0BAAuB7R,EAkBhC,SAASqO,GAAgCnB,EAAQqD,GAAgB,GAC/D,MAAMxN,EAASmK,EAAO2E,qBAMtB,OAFA9O,EAAOgN,YAAa,EAEE,WAAlBhN,EAAOuB,OACFnG,QAAQC,QAAQ4S,QAA+BhR,GAAW,EAAMuQ,IAGnD,YAAlBxN,EAAOuB,OACFnG,QAAQE,OAAO0E,EAAOyB,cAKxBzB,EAAOqM,0BAA0BjE,IAAWoF,SAK/CvE,gCACJxJ,cACE,MAAM,IAAI3E,UAGZqK,kBACE,IAAgD,IAA5C8L,GAAkCpR,MACpC,MAAMqR,GAAqC,eAG7C,OAAOjE,GAA8CpN,MAGvDJ,QACE,IAAgD,IAA5CwR,GAAkCpR,MACpC,MAAMqR,GAAqC,SAG7C,IAA+D,IAA3D9D,GAAiDvN,MACnD,MAAM,IAAI/E,UAAU,mDAGtBsR,GAAqCvM,MAGvCJ,QAAQ7B,GACN,IAAgD,IAA5CqT,GAAkCpR,MACpC,MAAMqR,GAAqC,WAG7C,IAA+D,IAA3D9D,GAAiDvN,MACnD,MAAM,IAAI/E,UAAU,qDAGtB,OAAO0R,GAAuC3M,KAAMjC,GAGtD6B,MAAM1B,GACJ,IAAgD,IAA5CkT,GAAkCpR,MACpC,MAAMqR,GAAqC,SAG7CtE,GAAqC/M,KAAM9B,GAG7C0B,CAAC0I,IAAatH,GACZzB,GAAWS,MACX,MAAMgH,EAAShH,KAAKsR,iBAAiBtQ,GAErC,OADAuQ,GAA+CvR,MACxCgH,EAGTpH,CAAC2I,IAAWoF,GACV,MAAMxN,EAASH,KAAKwR,0BAEpB,GAAIxR,KAAKxB,OAAOgJ,OAAS,EAAG,CAC1B,MAAMzJ,EAAQqB,GAAaY,MAS3B,OAP6B,IAAzBA,KAAK2Q,iBAAmD,IAAvB3Q,KAAKxB,OAAOgJ,QAC/C+J,GAA+CvR,MAC/CkO,GAAoB/N,IAEpBsR,GAAgDzR,MAG3CzE,QAAQC,QAAQ4S,GAA+BrQ,GAAO,EAAO4P,IAGtE,MAAM+D,EAAiB3D,GAA6B5N,EAAQwN,GAE5D,OADA8D,GAAgDzR,MACzC0R,GAMX,SAASN,GAAkCzW,GACzC,QAAKqE,GAAarE,MAIbmB,OAAOX,UAAUsH,eAAepH,KAAKV,EAAG,6BAO/C,SAAS8W,GAAgDrR,IAEpC,IADAkN,GAA8ClN,MAKrC,IAAxBA,EAAWuR,UAOfvR,EAAWuR,UAAW,EAEFvR,EAAWwR,iBACnBhO,KACV,KAGE,GAFAxD,EAAWuR,UAAW,GAEQ,IAA1BvR,EAAWyR,WAEb,OADAzR,EAAWyR,YAAa,EACjBJ,GAAgDrR,IAI3DlC,IACE6O,GAAqC3M,EAAYlC,KAGpDkG,MAAMlF,KAvBLkB,EAAWyR,YAAa,GA4B5B,SAASvE,GAA8ClN,GACrD,MAAMD,EAASC,EAAWoR,0BAE1B,OAAqE,IAAjEjE,GAAiDnN,MAIzB,IAAxBA,EAAWmD,YAIwB,IAAnCiG,GAAuBrJ,IAAoBwO,GAAiCxO,GAAU,GAItEiN,GAA8ChN,GAEhD,IAOpB,SAASmR,GAA+CnR,GACtDA,EAAWwR,oBAAiBxU,EAC5BgD,EAAWkR,sBAAmBlU,EAC9BgD,EAAWiG,4BAAyBjJ,EAKtC,SAASmP,GAAqCnM,GAC5C,MAAMD,EAASC,EAAWoR,0BAI1BpR,EAAWuQ,iBAAkB,EAEI,IAA7BvQ,EAAW5B,OAAOgJ,SACpB+J,GAA+CnR,GAC/C8N,GAAoB/N,IAIxB,SAASwM,GAAuCvM,EAAYrC,GAC1D,MAAMoC,EAASC,EAAWoR,0BAI1B,IAAuC,IAAnChI,GAAuBrJ,IAAoBwO,GAAiCxO,GAAU,EACxFsO,GAAiCtO,EAAQpC,GAAO,OAC3C,CACL,IAAIqI,EACJ,IACEA,EAAYhG,EAAWiG,uBAAuBtI,GAC9C,MAAOuI,GAEP,MADAyG,GAAqC3M,EAAYkG,GAC3CA,EAGR,IACEjH,GAAqBe,EAAYrC,EAAOqI,GACxC,MAAOM,GAEP,MADAqG,GAAqC3M,EAAYsG,GAC3CA,GAIV+K,GAAgDrR,GAKlD,SAAS2M,GAAqC3M,EAAYlC,GACxD,MAAMiC,EAASC,EAAWoR,0BAEJ,aAAlBrR,EAAOuB,SAIXnC,GAAWa,GAEXmR,GAA+CnR,GAC/CmO,GAAoBpO,EAAQjC,IAG9B,SAASkP,GAA8ChN,GACrD,MACMqB,EADSrB,EAAWoR,0BACL9P,OAErB,MAAc,YAAVD,EACK,KAEK,WAAVA,EACK,EAGFrB,EAAW+G,aAAe/G,EAAW1B,gBAY9C,SAAS6O,GAAiDnN,GACxD,MAAMqB,EAAQrB,EAAWoR,0BAA0B9P,OAEnD,OAAmC,IAA/BtB,EAAWuQ,iBAAuC,aAAVlP,EAO9C,SAAS4H,GACPlJ,EAAQC,EAAYgB,EAAgB0H,EAAeC,EAAiBnL,EAAesC,GAGnFE,EAAWoR,0BAA4BrR,EAEvCC,EAAW5B,YAASpB,EACpBgD,EAAW1B,qBAAkBtB,EAC7BmC,GAAWa,GAEXA,EAAWmD,UAAW,EACtBnD,EAAWuQ,iBAAkB,EAC7BvQ,EAAWyR,YAAa,EACxBzR,EAAWuR,UAAW,EAEtBvR,EAAWiG,uBAAyBnG,EACpCE,EAAW+G,aAAevJ,EAE1BwC,EAAWwR,eAAiB9I,EAC5B1I,EAAWkR,iBAAmBvI,EAE9B5I,EAAOqM,0BAA4BpM,EAEnC,MAAMkH,EAAclG,IACpB7F,QAAQC,QAAQ8L,GAAa1D,KAC3B,KACExD,EAAWmD,UAAW,EAKtBkO,GAAgDrR,IAElDmH,IACEwF,GAAqC3M,EAAYmH,KAGpDnD,MAAMlF,UAoBH4S,0BACJlS,cACE,MAAM,IAAI3E,UAAU,qDAGtBqU,WACE,IAA0C,IAAtCyC,GAA4B/R,MAC9B,MAAMgS,GAA+B,QAGvC,OAAOhS,KAAKiS,MAGdrS,QAAQsS,GACN,IAA0C,IAAtCH,GAA4B/R,MAC9B,MAAMgS,GAA+B,WAGvC,QAAqD5U,IAAjD4C,KAAKmS,wCACP,MAAM,IAAIlX,UAAU,0CAGtB,IAA4C,IAAxCkN,GAAiBnI,KAAKiS,MAAMxC,QAC9B,MAAM,IAAIxU,UAAU,oFAmnB1B,SAA6CmF,EAAY8R,GAEvD,GADAA,EAAepY,OAAOoY,IAC0B,IAA5C9T,GAA0B8T,GAC5B,MAAM,IAAIrU,WAAW,iCAKvBuU,GAA4ChS,EAAY8R,GAxnBtDG,CAAoCrS,KAAKmS,wCAAyCD,GAGpFtS,mBAAmB0P,GACjB,IAA0C,IAAtCyC,GAA4B/R,MAC9B,MAAMgS,GAA+B,WAGvC,QAAqD5U,IAAjD4C,KAAKmS,wCACP,MAAM,IAAIlX,UAAU,0CAGtB,IAAKsU,YAAYC,OAAOF,GACtB,MAAM,IAAIrU,UAAU,gDAGtB,IAAsC,IAAlCkN,GAAiBmH,EAAKG,QACxB,MAAM,IAAIxU,UAAU,qFA0mB1B,SAAwDmF,EAAYkP,GAGlE,MAAMgD,EAAkBlS,EAAWiQ,kBAAkB,GAErD,GAAIiC,EAAgBpC,WAAaoC,EAAgBnC,cAAgBb,EAAKY,WACpE,MAAM,IAAIrS,WAAW,2DAEvB,GAAIyU,EAAgB5C,aAAeJ,EAAKI,WACtC,MAAM,IAAI7R,WAAW,8DAGvByU,EAAgB7C,OAASH,EAAKG,OAE9B2C,GAA4ChS,EAAYkP,EAAKI,YArnB3D6C,CAA+CvS,KAAKmS,wCAAyC7C,UAI3FzG,6BACJjJ,cACE,MAAM,IAAI3E,UAAU,oEAGtBuX,kBACE,IAA6C,IAAzCpD,GAA+BpP,MACjC,MAAMyS,GAAwC,eAGhD,QAA0BrV,IAAtB4C,KAAK0S,cAA8B1S,KAAKqQ,kBAAkB7I,OAAS,EAAG,CACxE,MAAM8K,EAAkBtS,KAAKqQ,kBAAkB,GACzCf,EAAO,IAAI5S,WAAW4V,EAAgB7C,OAChB6C,EAAgBpC,WAAaoC,EAAgBnC,YAC7CmC,EAAgB5C,WAAa4C,EAAgBnC,aAEnEqC,EAAc1W,OAAOuE,OAAOyR,0BAA0B3W,YA8qBlE,SAAwCwX,EAASvS,EAAYkP,GAK3DqD,EAAQR,wCAA0C/R,EAClDuS,EAAQV,MAAQ3C,EAnrBZsD,CAA+BJ,EAAaxS,KAAMsP,GAClDtP,KAAK0S,aAAeF,EAGtB,OAAOxS,KAAK0S,aAGdpN,kBACE,IAA6C,IAAzC8J,GAA+BpP,MACjC,MAAMyS,GAAwC,eAGhD,OAAOI,GAA2C7S,MAGpDJ,QACE,IAA6C,IAAzCwP,GAA+BpP,MACjC,MAAMyS,GAAwC,SAGhD,IAA6B,IAAzBzS,KAAK2Q,gBACP,MAAM,IAAI1V,UAAU,8DAGtB,MAAMwG,EAAQzB,KAAK2P,8BAA8BjO,OACjD,GAAc,aAAVD,EACF,MAAM,IAAIxG,4BAA4BwG,+DAud5C,SAA2CrB,GACzC,MAAMD,EAASC,EAAWuP,8BAK1B,GAAIvP,EAAW1B,gBAAkB,EAG/B,YAFA0B,EAAWuQ,iBAAkB,GAK/B,GAAIvQ,EAAWiQ,kBAAkB7I,OAAS,EAAG,CAC3C,MAAMsL,EAAuB1S,EAAWiQ,kBAAkB,GAC1D,GAAIyC,EAAqB3C,YAAc,EAAG,CACxC,MAAMjS,EAAI,IAAIjD,UAAU,2DAGxB,MAFA2V,GAAkCxQ,EAAYlC,GAExCA,GAIV6U,GAA4C3S,GAC5C8N,GAAoB/N,GA3elB6S,CAAkChT,MAGpCJ,QAAQ7B,GACN,IAA6C,IAAzCqR,GAA+BpP,MACjC,MAAMyS,GAAwC,WAGhD,IAA6B,IAAzBzS,KAAK2Q,gBACP,MAAM,IAAI1V,UAAU,gCAGtB,MAAMwG,EAAQzB,KAAK2P,8BAA8BjO,OACjD,GAAc,aAAVD,EACF,MAAM,IAAIxG,4BAA4BwG,mEAGxC,IAAK8N,YAAYC,OAAOzR,GACtB,MAAM,IAAI9C,UAAU,qFAGtB,IAAuC,IAAnCkN,GAAiBpK,EAAM0R,QACzB,MAAM,IAAIxU,UAAU,sDAwd1B,SAA6CmF,EAAYrC,GACvD,MAAMoC,EAASC,EAAWuP,8BAKpBF,EAAS1R,EAAM0R,OACfS,EAAanS,EAAMmS,WACnBR,EAAa3R,EAAM2R,WACnBuD,EAAoB7K,GAAoBqH,GAE9C,IAA+C,IAA3CX,GAA+B3O,GACjC,GAAiD,IAA7CwO,GAAiCxO,GACnC+S,GAAgD9S,EAAY6S,EAAmB/C,EAAYR,OACtF,CAGL,MAAMyD,EAAkB,IAAIzW,WAAWuW,EAAmB/C,EAAYR,GACtEjB,GAAiCtO,EAAQgT,GAAiB,QAEX,IAAxCvE,GAA4BzO,IAErC+S,GAAgD9S,EAAY6S,EAAmB/C,EAAYR,GAC3F0D,GAAiEhT,IAGjE8S,GAAgD9S,EAAY6S,EAAmB/C,EAAYR,GAG7FmB,GAA6CzQ,GAlf3CiT,CAAoCrT,KAAMjC,GAG5C6B,MAAM1B,GACJ,IAA6C,IAAzCkR,GAA+BpP,MACjC,MAAMyS,GAAwC,SAGhD7B,GAAkC5Q,KAAM9B,GAG1C0B,CAAC0I,IAAatH,GACZ,GAAIhB,KAAKqQ,kBAAkB7I,OAAS,EAAG,CACbxH,KAAKqQ,kBAAkB,GAC/BF,YAAc,EAGhC5Q,GAAWS,MAEX,MAAMgH,EAAShH,KAAKsR,iBAAiBtQ,GAErC,OADA+R,GAA4C/S,MACrCgH,EAGTpH,CAAC2I,IAAWoF,GACV,MAAMxN,EAASH,KAAK2P,8BAGpB,GAAI3P,KAAKtB,gBAAkB,EAAG,CAG5B,MAAM4U,EAAQtT,KAAKxB,OAAOC,QAK1B,IAAI6Q,EAJJtP,KAAKtB,iBAAmB4U,EAAM5D,WAE9BgB,GAA6C1Q,MAG7C,IACEsP,EAAO,IAAI5S,WAAW4W,EAAM7D,OAAQ6D,EAAMpD,WAAYoD,EAAM5D,YAC5D,MAAO6D,GACP,OAAOhY,QAAQE,OAAO8X,GAGxB,OAAOhY,QAAQC,QAAQ4S,GAA+BkB,GAAM,EAAO3B,IAGrE,MAAM3E,EAAwBhJ,KAAKwT,uBACnC,QAA8BpW,IAA1B4L,EAAqC,CACvC,IAAIyG,EACJ,IACEA,EAAS,IAAIF,YAAYvG,GACzB,MAAOyK,GACP,OAAOlY,QAAQE,OAAOgY,GAGxB,MAAMxD,GACJR,OAAAA,EACAS,WAAY,EACZR,WAAY1G,EACZmH,YAAa,EACbP,YAAa,EACbI,KAAMtT,WACN0T,WAAY,WAGdpQ,KAAKqQ,kBAAkB1R,KAAKsR,GAG9B,MAAMrN,EAAUmL,GAA6B5N,EAAQwN,GAIrD,OAFAkD,GAA6C7Q,MAEtC4C,GAMX,SAASwM,GAA+BzU,GACtC,QAAKqE,GAAarE,MAIbmB,OAAOX,UAAUsH,eAAepH,KAAKV,EAAG,iCAO/C,SAASoX,GAA4BpX,GACnC,QAAKqE,GAAarE,MAIbmB,OAAOX,UAAUsH,eAAepH,KAAKV,EAAG,2CAO/C,SAASkW,GAA6CzQ,IAEjC,IA4SrB,SAAoDA,GAClD,MAAMD,EAASC,EAAWuP,8BAE1B,GAAsB,aAAlBxP,EAAOuB,OACT,OAAO,EAGT,IAAmC,IAA/BtB,EAAWuQ,gBACb,OAAO,EAGT,IAA4B,IAAxBvQ,EAAWmD,SACb,OAAO,EAGT,IAA+C,IAA3CuL,GAA+B3O,IAAoBwO,GAAiCxO,GAAU,EAChG,OAAO,EAGT,IAA4C,IAAxCyO,GAA4BzO,IAAoBuO,GAAqCvO,GAAU,EACjG,OAAO,EAKT,GAFoB0S,GAA2CzS,GAE7C,EAChB,OAAO,EAGT,OAAO,EA1UYsT,CAA2CtT,MAKlC,IAAxBA,EAAWuR,UAOfvR,EAAWuR,UAAW,EAGFvR,EAAWwR,iBACnBhO,KACV,KACExD,EAAWuR,UAAW,GAEQ,IAA1BvR,EAAWyR,aACbzR,EAAWyR,YAAa,EACxBhB,GAA6CzQ,KAGjDlC,IACE0S,GAAkCxQ,EAAYlC,KAGjDkG,MAAMlF,KAvBLkB,EAAWyR,YAAa,GA4B5B,SAAS8B,GAAkDvT,GACzDwT,GAAkDxT,GAClDA,EAAWiQ,qBAGb,SAASwD,GAAqD1T,EAAQ8P,GAGpE,IAAIvE,GAAO,EACW,WAAlBvL,EAAOuB,SAETgK,GAAO,GAGT,MAAM8E,EAAaC,GAAsDR,GACnC,YAAlCA,EAAmBG,WACrB3B,GAAiCtO,EAAQqQ,EAAY9E,GAh3BzD,SAA8CvL,EAAQpC,EAAO2N,GAC3D,MAIMkC,EAJSzN,EAAOsN,QAISK,kBAAkBrP,QACjDmP,EAAgB/K,SAASuL,GAA+BrQ,EAAO2N,EAAMkC,EAAgBC,iBA62BnFiG,CAAqC3T,EAAQqQ,EAAY9E,GAI7D,SAAS+E,GAAsDR,GAC7D,MAAME,EAAcF,EAAmBE,YACjCP,EAAcK,EAAmBL,YAKvC,OAAO,IAAIK,EAAmBD,KAC1BC,EAAmBR,OAAQQ,EAAmBC,WAAYC,EAAcP,GAG9E,SAASsD,GAAgD9S,EAAYqP,EAAQS,EAAYR,GACvFtP,EAAW5B,OAAOG,MAAO8Q,OAAAA,EAAQS,WAAAA,EAAYR,WAAAA,IAC7CtP,EAAW1B,iBAAmBgR,EAGhC,SAASa,GAA4DnQ,EAAY6P,GAC/E,MAAML,EAAcK,EAAmBL,YAEjCmE,EAAsB9D,EAAmBE,YAAcF,EAAmBE,YAAcP,EAExFoE,EAAiB9Z,KAAK+Z,IAAI7T,EAAW1B,gBACXuR,EAAmBP,WAAaO,EAAmBE,aAC7E+D,EAAiBjE,EAAmBE,YAAc6D,EAClDG,EAAkBD,EAAiBA,EAAiBtE,EAE1D,IAAIwE,EAA4BJ,EAC5BtO,GAAQ,EACRyO,EAAkBJ,IACpBK,EAA4BD,EAAkBlE,EAAmBE,YACjEzK,GAAQ,GAGV,MAAM2O,EAAQjU,EAAW5B,OAEzB,KAAO4V,EAA4B,GAAG,CACpC,MAAME,EAAcD,EAAM,GAEpBE,EAAcra,KAAK+Z,IAAIG,EAA2BE,EAAY5E,YAE9D8E,EAAYvE,EAAmBC,WAAaD,EAAmBE,YACrEjI,GAAgB+H,EAAmBR,OAAQ+E,EAAWF,EAAY7E,OAAQ6E,EAAYpE,WAAYqE,GAE9FD,EAAY5E,aAAe6E,EAC7BF,EAAM5V,SAEN6V,EAAYpE,YAAcqE,EAC1BD,EAAY5E,YAAc6E,GAE5BnU,EAAW1B,iBAAmB6V,EAE9BE,GAAuDrU,EAAYmU,EAAatE,GAEhFmE,GAA6BG,EAS/B,OAAO7O,EAGT,SAAS+O,GAAuDrU,EAAYtC,EAAMmS,GAGhF2D,GAAkDxT,GAClD6P,EAAmBE,aAAerS,EAGpC,SAAS4S,GAA6CtQ,GAGjB,IAA/BA,EAAW1B,kBAAwD,IAA/B0B,EAAWuQ,iBACjDoC,GAA4C3S,GAC5C8N,GAAoB9N,EAAWuP,gCAE/BkB,GAA6CzQ,GAIjD,SAASwT,GAAkDxT,QACzBhD,IAA5BgD,EAAWsS,eAIftS,EAAWsS,aAAaP,6CAA0C/U,EAClEgD,EAAWsS,aAAaT,WAAQ7U,EAChCgD,EAAWsS,kBAAetV,GAG5B,SAASgW,GAAiEhT,GAGxE,KAAOA,EAAWiQ,kBAAkB7I,OAAS,GAAG,CAC9C,GAAmC,IAA/BpH,EAAW1B,gBACb,OAGF,MAAMuR,EAAqB7P,EAAWiQ,kBAAkB,IAE4C,IAAhGE,GAA4DnQ,EAAY6P,KAC1EyE,GAAiDtU,GAEjDyT,GACEzT,EAAWuP,8BACXM,KA8GR,SAASmC,GAA4ChS,EAAY8R,GAC/D,MAAMI,EAAkBlS,EAAWiQ,kBAAkB,GAIrD,GAAsB,WAFPjQ,EAAWuP,8BAEfjO,OAAqB,CAC9B,GAAqB,IAAjBwQ,EACF,MAAM,IAAIjX,UAAU,qEAjD1B,SAA0DmF,EAAYkS,GACpEA,EAAgB7C,OAASrH,GAAoBkK,EAAgB7C,QAI7D,MAAMtP,EAASC,EAAWuP,8BAC1B,IAA4C,IAAxCf,GAA4BzO,GAC9B,KAAOuO,GAAqCvO,GAAU,GAEpD0T,GAAqD1T,EAD1BuU,GAAiDtU,IA4C9EuU,CAAiDvU,EAAYkS,QAtCjE,SAA4DlS,EAAY8R,EAAcjC,GACpF,GAAIA,EAAmBE,YAAc+B,EAAejC,EAAmBP,WACrE,MAAM,IAAI7R,WAAW,6BAKvB,GAFA4W,GAAuDrU,EAAY8R,EAAcjC,GAE7EA,EAAmBE,YAAcF,EAAmBL,YAEtD,OAGF8E,GAAiDtU,GAEjD,MAAMwU,EAAgB3E,EAAmBE,YAAcF,EAAmBL,YAC1E,GAAIgF,EAAgB,EAAG,CACrB,MAAMC,EAAM5E,EAAmBC,WAAaD,EAAmBE,YACzD2E,EAAY7E,EAAmBR,OAAOrT,MAAMyY,EAAMD,EAAeC,GACvE3B,GAAgD9S,EAAY0U,EAAW,EAAGA,EAAUpF,YAGtFO,EAAmBR,OAASrH,GAAoB6H,EAAmBR,QACnEQ,EAAmBE,aAAeyE,EAClCf,GAAqDzT,EAAWuP,8BAA+BM,GAE/FmD,GAAiEhT,GAiB/D2U,CAAmD3U,EAAY8R,EAAcI,GAG/EzB,GAA6CzQ,GAG/C,SAASsU,GAAiDtU,GACxD,MAAM4U,EAAa5U,EAAWiQ,kBAAkB5R,QAEhD,OADAmV,GAAkDxT,GAC3C4U,EAmCT,SAASjC,GAA4C3S,GACnDA,EAAWwR,oBAAiBxU,EAC5BgD,EAAWkR,sBAAmBlU,EA+DhC,SAASwT,GAAkCxQ,EAAYlC,GACrD,MAAMiC,EAASC,EAAWuP,8BAEJ,aAAlBxP,EAAOuB,SAIXiS,GAAkDvT,GAElDb,GAAWa,GACX2S,GAA4C3S,GAC5CmO,GAAoBpO,EAAQjC,IAG9B,SAAS2U,GAA2CzS,GAClD,MACMqB,EADSrB,EAAWuP,8BACLjO,OAErB,MAAc,YAAVD,EACK,KAEK,WAAVA,EACK,EAGFrB,EAAW+G,aAAe/G,EAAW1B,gBA+B9C,SAASwK,GAAkC/I,EAAQC,EAAYgB,EAAgB0H,EAAeC,EACnDnL,EAAeoL,GAOxD5I,EAAWuP,8BAAgCxP,EAE3CC,EAAWyR,YAAa,EACxBzR,EAAWuR,UAAW,EAEtBgC,GAAkDvT,GAGlDA,EAAW5B,OAAS4B,EAAW1B,qBAAkBtB,EACjDmC,GAAWa,GAEXA,EAAWuQ,iBAAkB,EAC7BvQ,EAAWmD,UAAW,EAEtBnD,EAAW+G,aAAerI,GAAkClB,GAE5DwC,EAAWwR,eAAiB9I,EAC5B1I,EAAWkR,iBAAmBvI,EAE9B3I,EAAWoT,uBAAyBxK,EAEpC5I,EAAWiQ,qBAEXlQ,EAAOqM,0BAA4BpM,EAEnC,MAAMkH,EAAclG,IACpB7F,QAAQC,QAAQ8L,GAAa1D,KACzB,KACExD,EAAWmD,UAAW,EAKtBsN,GAA6CzQ,IAE/CmH,IACEqJ,GAAkCxQ,EAAYmH,KAG/CnD,MAAMlF,IAsCb,SAAS4B,GAA0BmH,GACjC,OAAO,IAAIhN,sCAAsCgN,0CAKnD,SAASiH,GAAoBjH,GAC3B,OAAO,IAAIhN,UAAU,UAAYgN,EAAO,qCAK1C,SAAS+G,GAAiC/G,GACxC,OAAO,IAAIhN,mDACgCgN,uDAsB7C,SAASuG,GAAiClE,EAAQtJ,GAIhDsJ,EAAOvG,sBAAsB/C,GAC7BsJ,EAAOxG,4BAAyB1G,EAChCkN,EAAOvG,2BAAwB3G,EAqBjC,SAASiS,GAA8BpH,GACrC,OAAO,IAAIhN,gDAC6BgN,oDAK1C,SAASoJ,GAAqCpJ,GAC5C,OAAO,IAAIhN,uDACoCgN,2DAKjD,SAAS+J,GAA+B/J,GACtC,OAAO,IAAIhN,iDAC8BgN,qDAK3C,SAASwK,GAAwCxK,GAC/C,OAAO,IAAIhN,oDACiCgN,iFCv/D9C,MAAMgN,mBAAEA,IAAuB5W,ECA/B,yBAAQ4W,IAAuB5W,ECI/B,mBACQQ,uCAAcD,GAAmCtD,YAAEA,gBAAa0D,qCAChEF,uBAAmClC,qCACnCmC,IAAsCE,wBACtC2N,wCAAsBL,0CAAsCI,wCAC5DI,iDAAsCK,kDACtCC,oDACAE,IAAqDpO,yBACrDgC,gDAAsBE,IAAiD7B,EAR/DnB,EAAiB,0CAY3B6W,gBACJtV,YAAYuV,KAAkBC,KAAuBC,MACnD,MAAMC,EAAuBF,EAAiBtX,KAC9C,IAAIyX,EAAwBH,EAAiBxX,cAC7C,MAAM4X,EAAuBH,EAAiBvX,KAC9C,IAAI2X,EAAwBJ,EAAiBzX,cAI7C,QAAqBR,IAFA+X,EAAYO,aAG/B,MAAM,IAAI7X,WAAW,mCAGvB,MAAM8X,EAAwB5W,GAAkCuW,GAQhE,QAP8BlY,IAA1BmY,IACFA,EAAwB,GAE1BA,EAAwBzW,GAAkCyW,QAIrCnY,IAFA+X,EAAYS,aAG/B,MAAM,IAAI/X,WAAW,mCAGvB,MAAMgY,EAAwB9W,GAAkCyW,GAMhE,IAAIM,OAL0B1Y,IAA1BqY,IACFA,EAAwB,GAE1BA,EAAwB3W,GAAkC2W,GAO1DM,GAA0B/V,KAJL,IAAIzE,QAAQC,IAC/Bsa,EAAuBta,IAGqB+Z,EAAuBI,EAAuBF,EAClEI,GAgN9B,SAA8D1V,EAAQgV,GAGpE,MAAM/U,EAAatE,OAAOuE,OAAO2V,iCAAiC7a,WAElE,IAAI8a,EAAqBlY,IACvB,IAEE,OADAmY,GAAwC9V,EAAYrC,GAC7CxC,QAAQC,UACf,MAAO2a,GACP,OAAO5a,QAAQE,OAAO0a,KAG1B,MAAMC,EAAkBjB,EAAYkB,UACpC,QAAwBjZ,IAApBgZ,EAA+B,CACjC,GAA+B,mBAApBA,EACT,MAAM,IAAInb,UAAU,6BAEtBgb,EAAqBlY,CAAAA,GAASzC,GAAY8a,EAAiBjB,GAAcpX,EAAOqC,KAGlF,MAAMkW,EAAiB1X,GAAoCuW,EAAa,QAAS,GAAI/U,IAErFmW,GAAsCpW,EAAQC,EAAY6V,EAAoBK,GAtO5EE,CAAqDxW,KAAMmV,GAE3D,MAAM7N,EAAczI,GAAasW,EAAa,SAAUnV,KAAKyW,6BAC7DX,EAAqBxO,GAGvBwC,eACE,IAAgC,IAA5B4M,GAAkB1W,MACpB,MAAMc,GAA0B,YAGlC,OAAOd,KAAK2W,UAGd3a,eACE,IAAgC,IAA5B0a,GAAkB1W,MACpB,MAAMc,GAA0B,YAGlC,OAAOd,KAAK4W,WA+BhB,SAASb,GAA0B5V,EAAQ0W,EAActB,EAAuBI,EAC7CF,EAAuBI,GACxD,SAASzU,IACP,OAAOyV,EAeT1W,EAAOyW,UAAYzV,GAAqBC,EAZxC,SAAwBrD,GACtB,OA6OJ,SAAkDoC,EAAQpC,GAKxD,MAAMqC,EAAaD,EAAOsW,2BAE1B,IAA6B,IAAzBtW,EAAOqC,cAAwB,CACjC,MAAMsU,EAA4B3W,EAAO4W,2BAEzC,OAAOD,EACFlT,KAAK,KACJ,MAAM5H,EAAWmE,EAAOyW,UAClBnV,EAAQzF,EAAS0F,OACvB,GAAc,aAAVD,EACF,MAAMzF,EAAS4F,aAGjB,OAAOoV,GAAiD5W,EAAYrC,KAI5E,OAAOiZ,GAAiD5W,EAAYrC,GAnQ3DkZ,CAAyC9W,EAAQpC,IAO1D,WACE,OAqQJ,SAAkDoC,GAIhD,MAAM2J,EAAW3J,EAAOwW,UAElBvW,EAAaD,EAAOsW,2BACpBS,EAAe9W,EAAW+W,kBAIhC,OAHAC,GAAgDhX,GAGzC8W,EAAatT,KAAK,KACvB,GAAwB,YAApBkG,EAASpI,OACX,MAAMoI,EAASlI,aAEjB,MAAMyV,EAAqBvN,EAAS0C,2BACyC,IAAzEe,GAAiD8J,IACnD9K,GAAqC8K,KAEtCjT,MAAMmD,IAEP,MADA+P,GAAqBnX,EAAQoH,GACvBuC,EAASlI,eA1RR2V,CAAyCpX,IALlD,SAAwBa,GACtB,OAkQJ,SAAkDb,EAAQa,GAIxD,OADAsW,GAAqBnX,EAAQa,GACtBzF,QAAQC,UAtQNgc,CAAyCrX,EAAQa,IAQlBuU,EAAuBI,GAW/DxV,EAAOwW,UAAY/J,GAAqBxL,EATxC,WACE,OAyRJ,SAAmDjB,GAWjD,OAHAsX,GAA+BtX,GAAQ,GAGhCA,EAAO4W,2BApSLW,CAA0CvX,IAGnD,SAAyBa,GAEvB,OADA2W,GAA4CxX,EAAQa,GAC7CzF,QAAQC,WAGuEia,EAChDI,GAGxC1V,EAAOqC,mBAAgBpF,EACvB+C,EAAO4W,gCAA6B3Z,EACpC+C,EAAOyX,wCAAqCxa,EAC5Cqa,GAA+BtX,GAAQ,GAGvCA,EAAOsW,gCAA6BrZ,EAGtC,SAASsZ,GAAkB/b,GACzB,QAAKqE,GAAarE,MAIbmB,OAAOX,UAAUsH,eAAepH,KAAKV,EAAG,8BAQ/C,SAAS2c,GAAqBnX,EAAQjC,GAGpC6O,GAAqC5M,EAAOwW,UAAUnK,0BAA2BtO,GACjFyZ,GAA4CxX,EAAQjC,GAGtD,SAASyZ,GAA4CxX,EAAQjC,GAC3DkZ,GAAgDjX,EAAOsW,4BACvDpV,GAA6ClB,EAAOyW,UAAU1U,0BAA2BhE,IAC5D,IAAzBiC,EAAOqC,eAITiV,GAA+BtX,GAAQ,GAI3C,SAASsX,GAA+BtX,EAAQmE,QAMJlH,IAAtC+C,EAAO4W,4BACT5W,EAAOyX,qCAGTzX,EAAO4W,2BAA6B,IAAIxb,QAAQC,IAC9C2E,EAAOyX,mCAAqCpc,IAG9C2E,EAAOqC,cAAgB8B,QAKnB0R,iCACJpW,cACE,MAAM,IAAI3E,UAAU,yEAGtBqK,kBACE,IAAiD,IAA7CuS,GAAmC7X,MACrC,MAAMqR,GAAqC,eAG7C,MAAMgG,EAAqBrX,KAAK8X,2BAA2BnB,UAAUnK,0BACrE,OAAOY,GAA8CiK,GAGvDzX,QAAQ7B,GACN,IAAiD,IAA7C8Z,GAAmC7X,MACrC,MAAMqR,GAAqC,WAG7C6E,GAAwClW,KAAMjC,GAGhD6B,MAAMoB,GACJ,IAAiD,IAA7C6W,GAAmC7X,MACrC,MAAMqR,GAAqC,UAmGjD,SAA+CjR,EAAYlC,GACzDoZ,GAAqBlX,EAAW0X,2BAA4B5Z,GAjG1D6Z,CAAsC/X,KAAMgB,GAG9CpB,YACE,IAAiD,IAA7CiY,GAAmC7X,MACrC,MAAMqR,GAAqC,cAuGjD,SAAmDjR,GAGjD,MAAMD,EAASC,EAAW0X,2BACpBT,EAAqBlX,EAAOwW,UAAUnK,2BAEiC,IAAzEe,GAAiD8J,IACnD9K,GAAqC8K,GAGvC,MAAMlU,EAAQ,IAAIlI,UAAU,8BAC5B0c,GAA4CxX,EAAQgD,GA/GlD6U,CAA0ChY,OAM9C,SAAS6X,GAAmCld,GAC1C,QAAKqE,GAAarE,MAIbmB,OAAOX,UAAUsH,eAAepH,KAAKV,EAAG,8BAO/C,SAAS4b,GAAsCpW,EAAQC,EAAY6V,EAAoBK,GAIrFlW,EAAW0X,2BAA6B3X,EACxCA,EAAOsW,2BAA6BrW,EAEpCA,EAAW6X,oBAAsBhC,EACjC7V,EAAW+W,gBAAkBb,EA6B/B,SAASc,GAAgDhX,GACvDA,EAAW6X,yBAAsB7a,EACjCgD,EAAW+W,qBAAkB/Z,EAG/B,SAAS8Y,GAAwC9V,EAAYrC,GAG3D,MAAMoC,EAASC,EAAW0X,2BACpBT,EAAqBlX,EAAOwW,UAAUnK,0BAC5C,IAA6E,IAAzEe,GAAiD8J,GACnD,MAAM,IAAIpc,UAAU,wDAMtB,IACE0R,GAAuC0K,EAAoBtZ,GAC3D,MAAOG,GAIP,MAFAyZ,GAA4CxX,EAAQjC,GAE9CiC,EAAOwW,UAAU/U,aAGJyL,GAA+CgK,KAC/ClX,EAAOqC,eAE1BiV,GAA+BtX,GAAQ,GAQ3C,SAAS6W,GAAiD5W,EAAYrC,GAEpE,OADyBqC,EAAW6X,oBAAoBla,GAChCqG,MAAMmD,IAE5B,MADA+P,GAAqBlX,EAAW0X,2BAA4BvQ,GACtDA,IAiGV,SAAS8J,GAAqCpJ,GAC5C,OAAO,IAAIhN,wDACqCgN,4DAKlD,SAASnH,GAA0BmH,GACjC,OAAO,IAAIhN,uCACoBgN,mDAbdiQ,sBAtVnB,SAA+B9W,EAAgB6U,EAAoBK,EAAgBf,EAAwB,EAC5EI,EAAwB,KAAM,GAAGF,EAAwB,EACzDI,EAAwB,KAAM,IAI3D,MAAM1V,EAASrE,OAAOuE,OAAO6U,gBAAgB/Z,WAE7C,IAAI2a,EAKJC,GAA0B5V,EAJL,IAAI5E,QAAQC,IAC/Bsa,EAAuBta,IAGuB+Z,EAAuBI,EAAuBF,EACpEI,GAI1BU,GAAsCpW,EAFnBrE,OAAOuE,OAAO2V,iCAAiC7a,WAER8a,EAAoBK,GAE9E,MAAMhP,EAAclG,IAEpB,OADA0U,EAAqBxO,GACdnH,GAgUiC+U,gBAAAA,2GFnanBiD,0BACrBvY,aAAYhC,cAAEA,IACZqX,GAAmBjV,KAAM,gBAAiBpC,GAG5CgC,KAAK7B,GACH,OAAOA,EAAM2R,0CCNM0I,qBACrBxY,aAAYhC,cAAEA,IACZqX,GAAmBjV,KAAM,gBAAiBpC,GAG5CgC,OACE,OAAO"}