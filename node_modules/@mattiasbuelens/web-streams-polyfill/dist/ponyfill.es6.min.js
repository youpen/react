!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r(e.WebStreamsPolyfill={})}(this,function(e){"use strict";const r=Number.isInteger||function(e){return"number"==typeof e&&isFinite(e)&&Math.floor(e)===e},t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?Symbol:e=>`Symbol(${e})`;function o(){}const n=Number.isNaN||function(e){return e!=e};var a=function(e,r){return e(r={exports:{}},r.exports),r.exports}(function(e,r){const o=t('is "detached" for our purposes');function a(e,r,t){if("function"!=typeof e)throw new TypeError("Argument is not a function");return Function.prototype.apply.call(e,r,t)}function i(e,r,t){try{return Promise.resolve(a(e,r,t))}catch(e){return Promise.reject(e)}}r.typeIsObject=(e=>"object"==typeof e&&null!==e||"function"==typeof e),r.createDataProperty=((e,r,t)=>{Object.defineProperty(e,r,{value:t,writable:!0,enumerable:!0,configurable:!0})}),r.createArrayFromList=(e=>e.slice()),r.ArrayBufferCopy=((e,r,t,o,n)=>{new Uint8Array(e).set(new Uint8Array(t,o,n),r)}),r.IsFiniteNonNegativeNumber=(e=>!1!==r.IsNonNegativeNumber(e)&&e!==1/0),r.IsNonNegativeNumber=(e=>"number"==typeof e&&(!n(e)&&!(e<0))),r.Call=a,r.CreateAlgorithmFromUnderlyingMethod=((e,r,t,o)=>{const n=e[r];if(void 0!==n){if("function"!=typeof n)throw new TypeError(`${n} is not a method`);switch(t){case 0:return()=>i(n,e,o);case 1:return r=>{const t=[r].concat(o);return i(n,e,t)}}}return()=>Promise.resolve()}),r.InvokeOrNoop=((e,r,t)=>{const o=e[r];if(void 0!==o)return a(o,e,t)}),r.PromiseCall=i,r.TransferArrayBuffer=(e=>{const r=e.slice();return Object.defineProperty(e,"byteLength",{get:()=>0}),e[o]=!0,r}),r.IsDetachedBuffer=(e=>o in e),r.ValidateAndNormalizeHighWaterMark=(e=>{if(e=Number(e),n(e)||e<0)throw new RangeError("highWaterMark property of a queuing strategy must be non-negative and non-NaN");return e}),r.MakeSizeAlgorithmFromSizeFunction=(e=>{if(void 0===e)return()=>1;if("function"!=typeof e)throw new TypeError("size property of a queuing strategy must be a function");return r=>e(r)})}),i={default:a,__moduleExports:a,typeIsObject:a.typeIsObject,createDataProperty:a.createDataProperty,createArrayFromList:a.createArrayFromList,ArrayBufferCopy:a.ArrayBufferCopy,IsFiniteNonNegativeNumber:a.IsFiniteNonNegativeNumber,IsNonNegativeNumber:a.IsNonNegativeNumber,Call:a.Call,CreateAlgorithmFromUnderlyingMethod:a.CreateAlgorithmFromUnderlyingMethod,InvokeOrNoop:a.InvokeOrNoop,PromiseCall:a.PromiseCall,TransferArrayBuffer:a.TransferArrayBuffer,IsDetachedBuffer:a.IsDetachedBuffer,ValidateAndNormalizeHighWaterMark:a.ValidateAndNormalizeHighWaterMark,MakeSizeAlgorithmFromSizeFunction:a.MakeSizeAlgorithmFromSizeFunction};function s(){}s.AssertionError=o;var l={default:s},c=l&&s||l,u=e=>{e&&e instanceof c.AssertionError&&setTimeout(()=>{throw e},0)},d={rethrowAssertionErrorRejection:u},f={default:d,__moduleExports:d,rethrowAssertionErrorRejection:u},m=i&&a||i;const{IsFiniteNonNegativeNumber:_}=m;var h=e=>{const r=e._queue.shift();return e._queueTotalSize-=r.size,e._queueTotalSize<0&&(e._queueTotalSize=0),r.value},b=(e,r,t)=>{if(t=Number(t),!_(t))throw new RangeError("Size must be a finite, non-NaN, non-negative number.");e._queue.push({value:r,size:t}),e._queueTotalSize+=t},y=e=>{return e._queue[0].value},p=e=>{e._queue=[],e._queueTotalSize=0},w={DequeueValue:h,EnqueueValueWithSize:b,PeekQueueValue:y,ResetQueue:p},S={default:w,__moduleExports:w,DequeueValue:h,EnqueueValueWithSize:b,PeekQueueValue:y,ResetQueue:p},g={default:o},v=g&&o||g,R=f&&d||f,P=S&&w||S;const{CreateAlgorithmFromUnderlyingMethod:q,InvokeOrNoop:C,ValidateAndNormalizeHighWaterMark:T,IsNonNegativeNumber:j,MakeSizeAlgorithmFromSizeFunction:E,typeIsObject:W}=m,{rethrowAssertionErrorRejection:A}=R,{DequeueValue:O,EnqueueValueWithSize:B,PeekQueueValue:z,ResetQueue:k}=P,I=(v("streams:writable-stream:verbose"),t("[[AbortSteps]]")),F=t("[[ErrorSteps]]");class WritableStream{constructor(e={},r={}){M(this);const t=r.size;let o=r.highWaterMark;if(void 0!==e.type)throw new RangeError("Invalid type is specified");const n=E(t);void 0===o&&(o=1),function(e,r,t,o){const n=Object.create(WritableStreamDefaultController.prototype);const a=q(r,"write",1,[n]),i=q(r,"close",0,[]),s=q(r,"abort",1,[]);oe(e,n,function(){return C(r,"start",[n])},a,i,s,t,o)}(this,e,o=T(o),n)}get locked(){if(!1===L(this))throw ue("locked");return V(this)}abort(e){return!1===L(this)?Promise.reject(ue("abort")):!0===V(this)?Promise.reject(new TypeError("Cannot abort a stream that already has a writer")):Y(this,e)}getWriter(){if(!1===L(this))throw ue("getWriter");return N(this)}}var D={AcquireWritableStreamDefaultWriter:N,CreateWritableStream:function(e,r,t,o,n=1,a=(()=>1)){const i=Object.create(WritableStream.prototype);M(i);const s=Object.create(WritableStreamDefaultController.prototype);return oe(i,s,e,r,t,o,n,a),i},IsWritableStream:L,IsWritableStreamLocked:V,WritableStream:WritableStream,WritableStreamAbort:Y,WritableStreamDefaultControllerErrorIfNeeded:se,WritableStreamDefaultWriterCloseWithErrorPropagation:function(e){const r=e._ownerWritableStream,t=r._state;if(!0===U(r)||"closed"===t)return Promise.resolve();if("errored"===t)return Promise.reject(r._storedError);return X(e)},WritableStreamDefaultWriterRelease:re,WritableStreamDefaultWriterWrite:te,WritableStreamCloseQueuedOrInFlight:U};function N(e){return new WritableStreamDefaultWriter(e)}function M(e){e._state="writable",e._storedError=void 0,e._writer=void 0,e._writableStreamController=void 0,e._writeRequests=[],e._inFlightWriteRequest=void 0,e._closeRequest=void 0,e._inFlightCloseRequest=void 0,e._pendingAbortRequest=void 0,e._backpressure=!1}function L(e){return!!W(e)&&!!Object.prototype.hasOwnProperty.call(e,"_writableStreamController")}function V(e){return void 0!==e._writer}function Y(e,r){const t=e._state;if("closed"===t||"errored"===t)return Promise.resolve(void 0);if(void 0!==e._pendingAbortRequest)return e._pendingAbortRequest._promise;let o=!1;"erroring"===t&&(o=!0,r=void 0);const n=new Promise((t,n)=>{e._pendingAbortRequest={_resolve:t,_reject:n,_reason:r,_wasAlreadyErroring:o}});return e._pendingAbortRequest._promise=n,!1===o&&H(e,r),n}function $(e,r){"writable"!==e._state?x(e):H(e,r)}function H(e,r){const t=e._writableStreamController;e._state="erroring",e._storedError=r;const o=e._writer;void 0!==o&&ee(o,r),!1===function(e){if(void 0===e._inFlightWriteRequest&&void 0===e._inFlightCloseRequest)return!1;return!0}(e)&&!0===t._started&&x(e)}function x(e){e._state="errored",e._writableStreamController[F]();const r=e._storedError;for(const t of e._writeRequests)t._reject(r);if(e._writeRequests=[],void 0===e._pendingAbortRequest)return void G(e);const t=e._pendingAbortRequest;if(e._pendingAbortRequest=void 0,!0===t._wasAlreadyErroring)return t._reject(r),void G(e);e._writableStreamController[I](t._reason).then(()=>{t._resolve(),G(e)},r=>{t._reject(r),G(e)})}function Q(e){e._inFlightCloseRequest._resolve(void 0),e._inFlightCloseRequest=void 0,"erroring"===e._state&&(e._storedError=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._resolve(),e._pendingAbortRequest=void 0)),e._state="closed";const r=e._writer;void 0!==r&&function(e){e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved"}(r)}function U(e){return void 0!==e._closeRequest||void 0!==e._inFlightCloseRequest}function G(e){void 0!==e._closeRequest&&(e._closeRequest._reject(e._storedError),e._closeRequest=void 0);const r=e._writer;void 0!==r&&(_e(r,e._storedError),r._closedPromise.catch(()=>{}))}function J(e,r){const t=e._writer;void 0!==t&&r!==e._backpressure&&(!0===r?function(e){e._readyPromise=new Promise((r,t)=>{e._readyPromise_resolve=r,e._readyPromise_reject=t}),e._readyPromiseState="pending"}(t):ye(t)),e._backpressure=r}class WritableStreamDefaultWriter{constructor(e){if(!1===L(e))throw new TypeError("WritableStreamDefaultWriter can only be constructed with a WritableStream instance");if(!0===V(e))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=e,e._writer=this;const r=e._state;if("writable"===r)!1===U(e)&&!0===e._backpressure?function(e){e._readyPromise=new Promise((r,t)=>{e._readyPromise_resolve=r,e._readyPromise_reject=t}),e._readyPromiseState="pending"}(this):be(this),me(this);else if("erroring"===r)he(this,e._storedError),this._readyPromise.catch(()=>{}),me(this);else if("closed"===r)be(this),function(e){e._closedPromise=Promise.resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved"}(this);else{const r=e._storedError;he(this,r),this._readyPromise.catch(()=>{}),function(e,r){e._closedPromise=Promise.reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected"}(this,r),this._closedPromise.catch(()=>{})}}get closed(){return!1===K(this)?Promise.reject(de("closed")):this._closedPromise}get desiredSize(){if(!1===K(this))throw de("desiredSize");if(void 0===this._ownerWritableStream)throw fe("desiredSize");return function(e){const r=e._ownerWritableStream,t=r._state;if("errored"===t||"erroring"===t)return null;if("closed"===t)return 0;return ae(r._writableStreamController)}(this)}get ready(){return!1===K(this)?Promise.reject(de("ready")):this._readyPromise}abort(e){return!1===K(this)?Promise.reject(de("abort")):void 0===this._ownerWritableStream?Promise.reject(fe("abort")):function(e,r){return Y(e._ownerWritableStream,r)}(this,e)}close(){if(!1===K(this))return Promise.reject(de("close"));const e=this._ownerWritableStream;return void 0===e?Promise.reject(fe("close")):!0===U(e)?Promise.reject(new TypeError("cannot close an already-closing stream")):X(this)}releaseLock(){if(!1===K(this))throw de("releaseLock");void 0!==this._ownerWritableStream&&re(this)}write(e){return!1===K(this)?Promise.reject(de("write")):void 0===this._ownerWritableStream?Promise.reject(fe("write to")):te(this,e)}}function K(e){return!!W(e)&&!!Object.prototype.hasOwnProperty.call(e,"_ownerWritableStream")}function X(e){const r=e._ownerWritableStream,t=r._state;if("closed"===t||"errored"===t)return Promise.reject(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));const o=new Promise((e,t)=>{const o={_resolve:e,_reject:t};r._closeRequest=o});return!0===r._backpressure&&"writable"===t&&ye(e),function(e){B(e,"close",0),ie(e)}(r._writableStreamController),o}function Z(e,r){"pending"===e._closedPromiseState?_e(e,r):function(e,r){e._closedPromise=Promise.reject(r),e._closedPromiseState="rejected"}(e,r),e._closedPromise.catch(()=>{})}function ee(e,r){"pending"===e._readyPromiseState?function(e,r){e._readyPromise_reject(r),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected"}(e,r):function(e,r){e._readyPromise=Promise.reject(r),e._readyPromiseState="rejected"}(e,r),e._readyPromise.catch(()=>{})}function re(e){const r=e._ownerWritableStream,t=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");ee(e,t),Z(e,t),r._writer=void 0,e._ownerWritableStream=void 0}function te(e,r){const t=e._ownerWritableStream,o=t._writableStreamController,n=function(e,r){try{return e._strategySizeAlgorithm(r)}catch(r){return se(e,r),1}}(o,r);if(t!==e._ownerWritableStream)return Promise.reject(fe("write to"));const a=t._state;if("errored"===a)return Promise.reject(t._storedError);if(!0===U(t)||"closed"===a)return Promise.reject(new TypeError("The stream is closing or closed and cannot be written to"));if("erroring"===a)return Promise.reject(t._storedError);const i=function(e){return new Promise((r,t)=>{const o={_resolve:r,_reject:t};e._writeRequests.push(o)})}(t);return function(e,r,t){const o={chunk:r};try{B(e,o,t)}catch(r){return void se(e,r)}const n=e._controlledWritableStream;if(!1===U(n)&&"writable"===n._state){const r=le(e);J(n,r)}ie(e)}(o,r,n),i}class WritableStreamDefaultController{constructor(){throw new TypeError("WritableStreamDefaultController cannot be constructed explicitly")}error(e){if(!1===function(e){if(!W(e))return!1;if(!Object.prototype.hasOwnProperty.call(e,"_controlledWritableStream"))return!1;return!0}(this))throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");"writable"===this._controlledWritableStream._state&&ce(this,e)}[I](e){const r=this._abortAlgorithm(e);return ne(this),r}[F](){k(this)}}function oe(e,r,t,o,n,a,i,s){r._controlledWritableStream=e,e._writableStreamController=r,r._queue=void 0,r._queueTotalSize=void 0,k(r),r._started=!1,r._strategySizeAlgorithm=s,r._strategyHWM=i,r._writeAlgorithm=o,r._closeAlgorithm=n,r._abortAlgorithm=a;const l=le(r);J(e,l);const c=t();Promise.resolve(c).then(()=>{r._started=!0,ie(r)},t=>{r._started=!0,$(e,t)}).catch(A)}function ne(e){e._writeAlgorithm=void 0,e._closeAlgorithm=void 0,e._abortAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function ae(e){return e._strategyHWM-e._queueTotalSize}function ie(e){const r=e._controlledWritableStream;if(!1===e._started)return;if(void 0!==r._inFlightWriteRequest)return;const t=r._state;if("closed"===t||"errored"===t)return;if("erroring"===t)return void x(r);if(0===e._queue.length)return;const o=z(e);"close"===o?function(e){const r=e._controlledWritableStream;(function(e){e._inFlightCloseRequest=e._closeRequest,e._closeRequest=void 0})(r),O(e);const t=e._closeAlgorithm();ne(e),t.then(()=>{Q(r)},e=>{!function(e,r){e._inFlightCloseRequest._reject(r),e._inFlightCloseRequest=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._reject(r),e._pendingAbortRequest=void 0),$(e,r)}(r,e)}).catch(A)}(e):function(e,r){const t=e._controlledWritableStream;(function(e){e._inFlightWriteRequest=e._writeRequests.shift()})(t),e._writeAlgorithm(r).then(()=>{!function(e){e._inFlightWriteRequest._resolve(void 0),e._inFlightWriteRequest=void 0}(t);const r=t._state;if(O(e),!1===U(t)&&"writable"===r){const r=le(e);J(t,r)}ie(e)},r=>{"writable"===t._state&&ne(e),function(e,r){e._inFlightWriteRequest._reject(r),e._inFlightWriteRequest=void 0,$(e,r)}(t,r)}).catch(A)}(e,o.chunk)}function se(e,r){"writable"===e._controlledWritableStream._state&&ce(e,r)}function le(e){return ae(e)<=0}function ce(e,r){const t=e._controlledWritableStream;ne(e),H(t,r)}function ue(e){return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`)}function de(e){return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`)}function fe(e){return new TypeError("Cannot "+e+" a stream using a released writer")}function me(e){e._closedPromise=new Promise((r,t)=>{e._closedPromise_resolve=r,e._closedPromise_reject=t,e._closedPromiseState="pending"})}function _e(e,r){e._closedPromise_reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected"}function he(e,r){e._readyPromise=Promise.reject(r),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected"}function be(e){e._readyPromise=Promise.resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled"}function ye(e){e._readyPromise_resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled"}var pe=D.WritableStream;const{ArrayBufferCopy:we,CreateAlgorithmFromUnderlyingMethod:Se,IsFiniteNonNegativeNumber:ge,InvokeOrNoop:ve,IsDetachedBuffer:Re,TransferArrayBuffer:Pe,ValidateAndNormalizeHighWaterMark:qe,IsNonNegativeNumber:Ce,MakeSizeAlgorithmFromSizeFunction:Te,createArrayFromList:je,typeIsObject:Ee}=m,{rethrowAssertionErrorRejection:We}=R,{DequeueValue:Ae,EnqueueValueWithSize:Oe,ResetQueue:Be}=P,{AcquireWritableStreamDefaultWriter:ze,IsWritableStream:ke,IsWritableStreamLocked:Ie,WritableStreamAbort:Fe,WritableStreamDefaultWriterCloseWithErrorPropagation:De,WritableStreamDefaultWriterRelease:Ne,WritableStreamDefaultWriterWrite:Me,WritableStreamCloseQueuedOrInFlight:Le}=D,Ve=t("[[CancelSteps]]"),Ye=t("[[PullSteps]]");class ReadableStream{constructor(e={},t={}){Qe(this);const o=t.size;let n=t.highWaterMark;const a=e.type;if("bytes"===String(a)){if(void 0!==o)throw new RangeError("The strategy for a byte stream cannot have a size function");void 0===n&&(n=0),function(e,t,o){const n=Object.create(ReadableByteStreamController.prototype);const a=Se(t,"pull",0,[n]),i=Se(t,"cancel",1,[]);let s=t.autoAllocateChunkSize;if(void 0!==s&&(s=Number(s),!1===r(s)||s<=0))throw new RangeError("autoAllocateChunkSize must be a positive integer");Mr(e,n,function(){return ve(t,"start",[n])},a,i,o,s)}(this,e,n=qe(n))}else{if(void 0!==a)throw new RangeError("Invalid type is specified");{const r=Te(o);void 0===n&&(n=1),function(e,r,t,o){const n=Object.create(ReadableStreamDefaultController.prototype);const a=Se(r,"pull",0,[n]),i=Se(r,"cancel",1,[]);vr(e,n,function(){return ve(r,"start",[n])},a,i,t,o)}(this,e,n=qe(n),r)}}}get locked(){if(!1===Ue(this))throw Lr("locked");return Ge(this)}cancel(e){return!1===Ue(this)?Promise.reject(Lr("cancel")):!0===Ge(this)?Promise.reject(new TypeError("Cannot cancel a stream that already has a reader")):Xe(this,e)}getReader({mode:e}={}){if(!1===Ue(this))throw Lr("getReader");if(void 0===e)return He(this);if("byob"===(e=String(e)))return function(e){return new ReadableStreamBYOBReader(e)}(this);throw new RangeError("Invalid mode is specified")}pipeThrough({writable:e,readable:r},t){if(void 0===e||void 0===r)throw new TypeError("readable and writable arguments must be defined");return function(e){try{Promise.prototype.then.call(e,void 0,()=>{})}catch(e){}}(this.pipeTo(e,t)),r}pipeTo(e,{preventClose:r,preventAbort:t,preventCancel:o}={}){if(!1===Ue(this))return Promise.reject(Lr("pipeTo"));if(!1===ke(e))return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));if(r=Boolean(r),t=Boolean(t),o=Boolean(o),!0===Ge(this))return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));if(!0===Ie(e))return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));const n=He(this),a=ze(e);let i=!1,s=Promise.resolve();return new Promise((l,c)=>{if(d(this,n._closedPromise,r=>{!1===t?f(()=>Fe(e,r),!0,r):m(!0,r)}),d(e,a._closedPromise,e=>{!1===o?f(()=>Xe(this,e),!0,e):m(!0,e)}),function(e,r,t){"closed"===e._state?t():r.then(t).catch(We)}(this,n._closedPromise,()=>{!1===r?f(()=>De(a)):m()}),!0===Le(e)||"closed"===e._state){const e=new TypeError("the destination writable stream closed before all data could be piped to it");!1===o?f(()=>Xe(this,e),!0,e):m(!0,e)}function u(){const e=s;return s.then(()=>e!==s?u():void 0)}function d(e,r,t){"errored"===e._state?t(e._storedError):r.catch(t).catch(We)}function f(r,t,o){function n(){r().then(()=>_(t,o),e=>_(!0,e)).catch(We)}!0!==i&&(i=!0,"writable"===e._state&&!1===Le(e)?u().then(n):n())}function m(r,t){!0!==i&&(i=!0,"writable"===e._state&&!1===Le(e)?u().then(()=>_(r,t)).catch(We):_(r,t))}function _(e,r){Ne(a),dr(n),e?c(r):l(void 0)}(function e(){return!0===i?Promise.resolve():a._readyPromise.then(()=>fr(n).then(({value:e,done:r})=>{!0!==r&&(s=Me(a,e).catch(()=>{}))})).then(e)})().catch(e=>{s=Promise.resolve(),We(e)})})}tee(){if(!1===Ue(this))throw Lr("tee");const e=function(e,r){const t=He(e);let o,n,a,i,s,l=!1,c=!1,u=!1;const d=new Promise(e=>{s=e});function f(){return fr(t).then(e=>{const r=e.value,t=e.done;if(!0===t&&!1===l&&(!1===c&&yr(a._readableStreamController),!1===u&&yr(i._readableStreamController),l=!0),!0===l)return;const o=r,n=r;!1===c&&pr(a._readableStreamController,o),!1===u&&pr(i._readableStreamController,n)})}function m(){}return a=xe(m,f,function(r){if(c=!0,o=r,!0===u){const r=je([o,n]),t=Xe(e,r);s(t)}return d}),i=xe(m,f,function(r){if(u=!0,n=r,!0===c){const r=je([o,n]),t=Xe(e,r);s(t)}return d}),t._closedPromise.catch(e=>{!0!==l&&(wr(a._readableStreamController,e),wr(i._readableStreamController,e),l=!0)}),[a,i]}(this);return je(e)}}var $e={CreateReadableByteStream:function(e,r,t,o=0,n){const a=Object.create(ReadableStream.prototype);Qe(a);const i=Object.create(ReadableByteStreamController.prototype);return Mr(a,i,e,r,t,o,n),a},CreateReadableStream:xe,ReadableStream:ReadableStream,IsReadableStreamDisturbed:function(e){return e._disturbed},ReadableStreamDefaultControllerClose:yr,ReadableStreamDefaultControllerEnqueue:pr,ReadableStreamDefaultControllerError:wr,ReadableStreamDefaultControllerGetDesiredSize:Sr,ReadableStreamDefaultControllerHasBackpressure:function(e){if(!0===hr(e))return!1;return!0},ReadableStreamDefaultControllerCanCloseOrEnqueue:gr};function He(e){return new ReadableStreamDefaultReader(e)}function xe(e,r,t,o=1,n=(()=>1)){const a=Object.create(ReadableStream.prototype);return Qe(a),vr(a,Object.create(ReadableStreamDefaultController.prototype),e,r,t,o,n),a}function Qe(e){e._state="readable",e._reader=void 0,e._storedError=void 0,e._disturbed=!1}function Ue(e){return!!Ee(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readableStreamController")}function Ge(e){return void 0!==e._reader}function Je(e,r){return new Promise((t,o)=>{const n={_resolve:t,_reject:o,_forAuthorCode:r};e._reader._readIntoRequests.push(n)})}function Ke(e,r){return new Promise((t,o)=>{const n={_resolve:t,_reject:o,_forAuthorCode:r};e._reader._readRequests.push(n)})}function Xe(e,r){if(e._disturbed=!0,"closed"===e._state)return Promise.resolve(void 0);if("errored"===e._state)return Promise.reject(e._storedError);return Ze(e),e._readableStreamController[Ve](r).then(()=>void 0)}function Ze(e){e._state="closed";const r=e._reader;if(void 0!==r){if(!0===lr(r)){for(const{_resolve:e,_forAuthorCode:t}of r._readRequests)e(er(void 0,!0,t));r._readRequests=[]}!function(e){e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}(r)}}function er(e,r,t){let o=null;!0===t&&(o=Object.prototype);const n=Object.create(o);return Object.defineProperty(n,"value",{value:e,enumerable:!0,writable:!0,configurable:!0}),Object.defineProperty(n,"done",{value:r,enumerable:!0,writable:!0,configurable:!0}),n}function rr(e,r){e._state="errored",e._storedError=r;const t=e._reader;if(void 0!==t){if(!0===lr(t)){for(const e of t._readRequests)e._reject(r);t._readRequests=[]}else{for(const e of t._readIntoRequests)e._reject(r);t._readIntoRequests=[]}$r(t,r),t._closedPromise.catch(()=>{})}}function tr(e,r,t){const o=e._reader._readRequests.shift();o._resolve(er(r,t,o._forAuthorCode))}function or(e){return e._reader._readIntoRequests.length}function nr(e){return e._reader._readRequests.length}function ar(e){const r=e._reader;return void 0!==r&&!1!==sr(r)}function ir(e){const r=e._reader;return void 0!==r&&!1!==lr(r)}class ReadableStreamDefaultReader{constructor(e){if(!1===Ue(e))throw new TypeError("ReadableStreamDefaultReader can only be constructed with a ReadableStream instance");if(!0===Ge(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");cr(this,e),this._readRequests=[]}get closed(){return!1===lr(this)?Promise.reject(Yr("closed")):this._closedPromise}cancel(e){return!1===lr(this)?Promise.reject(Yr("cancel")):void 0===this._ownerReadableStream?Promise.reject(Vr("cancel")):ur(this,e)}read(){return!1===lr(this)?Promise.reject(Yr("read")):void 0===this._ownerReadableStream?Promise.reject(Vr("read from")):fr(this,!0)}releaseLock(){if(!1===lr(this))throw Yr("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");dr(this)}}}class ReadableStreamBYOBReader{constructor(e){if(!Ue(e))throw new TypeError("ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a byte source");if(!1===Rr(e._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");if(Ge(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");cr(this,e),this._readIntoRequests=[]}get closed(){return sr(this)?this._closedPromise:Promise.reject(Hr("closed"))}cancel(e){return sr(this)?void 0===this._ownerReadableStream?Promise.reject(Vr("cancel")):ur(this,e):Promise.reject(Hr("cancel"))}read(e){return sr(this)?void 0===this._ownerReadableStream?Promise.reject(Vr("read from")):ArrayBuffer.isView(e)?!0===Re(e.buffer)?Promise.reject(new TypeError("Cannot read into a view onto a detached ArrayBuffer")):0===e.byteLength?Promise.reject(new TypeError("view must have non-zero byteLength")):function(e,r,t=!1){const o=e._ownerReadableStream;if(o._disturbed=!0,"errored"===o._state)return Promise.reject(o._storedError);return function(e,r,t){const o=e._controlledReadableByteStream;let n=1;r.constructor!==DataView&&(n=r.constructor.BYTES_PER_ELEMENT);const a=r.constructor,i={buffer:Pe(r.buffer),byteOffset:r.byteOffset,byteLength:r.byteLength,bytesFilled:0,elementSize:n,ctor:a,readerType:"byob"};if(e._pendingPullIntos.length>0)return e._pendingPullIntos.push(i),Je(o,t);if("closed"===o._state){const e=new r.constructor(i.buffer,i.byteOffset,0);return Promise.resolve(er(e,!0,t))}if(e._queueTotalSize>0){if(!0===Wr(e,i)){const r=jr(i);return Or(e),Promise.resolve(er(r,!1,t))}if(!0===e._closeRequested){const r=new TypeError("Insufficient bytes to fill elements in the given buffer");return Dr(e,r),Promise.reject(r)}}e._pendingPullIntos.push(i);const s=Je(o,t);return qr(e),s}(o._readableStreamController,r,t)}(this,e,!0):Promise.reject(new TypeError("view must be an array buffer view")):Promise.reject(Hr("read"))}releaseLock(){if(!sr(this))throw Hr("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readIntoRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");dr(this)}}}function sr(e){return!!Ee(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readIntoRequests")}function lr(e){return!!Ee(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readRequests")}function cr(e,r){e._ownerReadableStream=r,r._reader=e,"readable"===r._state?function(e){e._closedPromise=new Promise((r,t)=>{e._closedPromise_resolve=r,e._closedPromise_reject=t})}(e):"closed"===r._state?function(e){e._closedPromise=Promise.resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}(e):(!function(e,r){e._closedPromise=Promise.reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}(e,r._storedError),e._closedPromise.catch(()=>{}))}function ur(e,r){return Xe(e._ownerReadableStream,r)}function dr(e){"readable"===e._ownerReadableStream._state?$r(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):function(e,r){e._closedPromise=Promise.reject(r)}(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),e._closedPromise.catch(()=>{}),e._ownerReadableStream._reader=void 0,e._ownerReadableStream=void 0}function fr(e,r=!1){const t=e._ownerReadableStream;return t._disturbed=!0,"closed"===t._state?Promise.resolve(er(void 0,!0,r)):"errored"===t._state?Promise.reject(t._storedError):t._readableStreamController[Ye](r)}class ReadableStreamDefaultController{constructor(){throw new TypeError}get desiredSize(){if(!1===mr(this))throw xr("desiredSize");return Sr(this)}close(){if(!1===mr(this))throw xr("close");if(!1===gr(this))throw new TypeError("The stream is not in a state that permits close");yr(this)}enqueue(e){if(!1===mr(this))throw xr("enqueue");if(!1===gr(this))throw new TypeError("The stream is not in a state that permits enqueue");return pr(this,e)}error(e){if(!1===mr(this))throw xr("error");wr(this,e)}[Ve](e){Be(this);const r=this._cancelAlgorithm(e);return br(this),r}[Ye](e){const r=this._controlledReadableStream;if(this._queue.length>0){const t=Ae(this);return!0===this._closeRequested&&0===this._queue.length?(br(this),Ze(r)):_r(this),Promise.resolve(er(t,!1,e))}const t=Ke(r,e);return _r(this),t}}function mr(e){return!!Ee(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableStream")}function _r(e){!1!==hr(e)&&(!0!==e._pulling?(e._pulling=!0,e._pullAlgorithm().then(()=>{if(e._pulling=!1,!0===e._pullAgain)return e._pullAgain=!1,_r(e)},r=>{wr(e,r)}).catch(We)):e._pullAgain=!0)}function hr(e){const r=e._controlledReadableStream;return!1!==gr(e)&&(!1!==e._started&&(!0===Ge(r)&&nr(r)>0||Sr(e)>0))}function br(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function yr(e){const r=e._controlledReadableStream;e._closeRequested=!0,0===e._queue.length&&(br(e),Ze(r))}function pr(e,r){const t=e._controlledReadableStream;if(!0===Ge(t)&&nr(t)>0)tr(t,r,!1);else{let t;try{t=e._strategySizeAlgorithm(r)}catch(r){throw wr(e,r),r}try{Oe(e,r,t)}catch(r){throw wr(e,r),r}}_r(e)}function wr(e,r){const t=e._controlledReadableStream;"readable"===t._state&&(Be(e),br(e),rr(t,r))}function Sr(e){const r=e._controlledReadableStream._state;return"errored"===r?null:"closed"===r?0:e._strategyHWM-e._queueTotalSize}function gr(e){const r=e._controlledReadableStream._state;return!1===e._closeRequested&&"readable"===r}function vr(e,r,t,o,n,a,i){r._controlledReadableStream=e,r._queue=void 0,r._queueTotalSize=void 0,Be(r),r._started=!1,r._closeRequested=!1,r._pullAgain=!1,r._pulling=!1,r._strategySizeAlgorithm=i,r._strategyHWM=a,r._pullAlgorithm=o,r._cancelAlgorithm=n,e._readableStreamController=r;const s=t();Promise.resolve(s).then(()=>{r._started=!0,_r(r)},e=>{wr(r,e)}).catch(We)}class ReadableStreamBYOBRequest{constructor(){throw new TypeError("ReadableStreamBYOBRequest cannot be used directly")}get view(){if(!1===Pr(this))throw Qr("view");return this._view}respond(e){if(!1===Pr(this))throw Qr("respond");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");if(!0===Re(this._view.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");!function(e,r){if(r=Number(r),!1===ge(r))throw new RangeError("bytesWritten must be a finite");kr(e,r)}(this._associatedReadableByteStreamController,e)}respondWithNewView(e){if(!1===Pr(this))throw Qr("respond");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");if(!ArrayBuffer.isView(e))throw new TypeError("You can only respond with array buffer views");if(!0===Re(e.buffer))throw new TypeError("The supplied view's buffer has been detached and so cannot be used as a response");!function(e,r){const t=e._pendingPullIntos[0];if(t.byteOffset+t.bytesFilled!==r.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(t.byteLength!==r.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");t.buffer=r.buffer,kr(e,r.byteLength)}(this._associatedReadableByteStreamController,e)}}class ReadableByteStreamController{constructor(){throw new TypeError("ReadableByteStreamController constructor cannot be used directly")}get byobRequest(){if(!1===Rr(this))throw Ur("byobRequest");if(void 0===this._byobRequest&&this._pendingPullIntos.length>0){const e=this._pendingPullIntos[0],r=new Uint8Array(e.buffer,e.byteOffset+e.bytesFilled,e.byteLength-e.bytesFilled),t=Object.create(ReadableStreamBYOBRequest.prototype);!function(e,r,t){e._associatedReadableByteStreamController=r,e._view=t}(t,this,r),this._byobRequest=t}return this._byobRequest}get desiredSize(){if(!1===Rr(this))throw Ur("desiredSize");return Nr(this)}close(){if(!1===Rr(this))throw Ur("close");if(!0===this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const e=this._controlledReadableByteStream._state;if("readable"!==e)throw new TypeError(`The stream (in ${e} state) is not in the readable state and cannot be closed`);!function(e){const r=e._controlledReadableByteStream;if(e._queueTotalSize>0)return void(e._closeRequested=!0);if(e._pendingPullIntos.length>0){const r=e._pendingPullIntos[0];if(r.bytesFilled>0){const r=new TypeError("Insufficient bytes to fill elements in the given buffer");throw Dr(e,r),r}}Fr(e),Ze(r)}(this)}enqueue(e){if(!1===Rr(this))throw Ur("enqueue");if(!0===this._closeRequested)throw new TypeError("stream is closed or draining");const r=this._controlledReadableByteStream._state;if("readable"!==r)throw new TypeError(`The stream (in ${r} state) is not in the readable state and cannot be enqueued to`);if(!ArrayBuffer.isView(e))throw new TypeError("You can only enqueue array buffer views when using a ReadableByteStreamController");if(!0===Re(e.buffer))throw new TypeError("Cannot enqueue a view onto a detached ArrayBuffer");!function(e,r){const t=e._controlledReadableByteStream,o=r.buffer,n=r.byteOffset,a=r.byteLength,i=Pe(o);if(!0===ir(t))if(0===nr(t))Er(e,i,n,a);else{const e=new Uint8Array(i,n,a);tr(t,e,!1)}else!0===ar(t)?(Er(e,i,n,a),zr(e)):Er(e,i,n,a);qr(e)}(this,e)}error(e){if(!1===Rr(this))throw Ur("error");Dr(this,e)}[Ve](e){if(this._pendingPullIntos.length>0){this._pendingPullIntos[0].bytesFilled=0}Be(this);const r=this._cancelAlgorithm(e);return Fr(this),r}[Ye](e){const r=this._controlledReadableByteStream;if(this._queueTotalSize>0){const r=this._queue.shift();let t;this._queueTotalSize-=r.byteLength,Or(this);try{t=new Uint8Array(r.buffer,r.byteOffset,r.byteLength)}catch(e){return Promise.reject(e)}return Promise.resolve(er(t,!1,e))}const t=this._autoAllocateChunkSize;if(void 0!==t){let e;try{e=new ArrayBuffer(t)}catch(e){return Promise.reject(e)}const r={buffer:e,byteOffset:0,byteLength:t,bytesFilled:0,elementSize:1,ctor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(r)}const o=Ke(r,e);return qr(this),o}}function Rr(e){return!!Ee(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableByteStream")}function Pr(e){return!!Ee(e)&&!!Object.prototype.hasOwnProperty.call(e,"_associatedReadableByteStreamController")}function qr(e){!1!==function(e){const r=e._controlledReadableByteStream;if("readable"!==r._state)return!1;if(!0===e._closeRequested)return!1;if(!1===e._started)return!1;if(!0===ir(r)&&nr(r)>0)return!0;if(!0===ar(r)&&or(r)>0)return!0;if(Nr(e)>0)return!0;return!1}(e)&&(!0!==e._pulling?(e._pulling=!0,e._pullAlgorithm().then(()=>{e._pulling=!1,!0===e._pullAgain&&(e._pullAgain=!1,qr(e))},r=>{Dr(e,r)}).catch(We)):e._pullAgain=!0)}function Cr(e){Br(e),e._pendingPullIntos=[]}function Tr(e,r){let t=!1;"closed"===e._state&&(t=!0);const o=jr(r);"default"===r.readerType?tr(e,o,t):function(e,r,t){const o=e._reader._readIntoRequests.shift();o._resolve(er(r,t,o._forAuthorCode))}(e,o,t)}function jr(e){const r=e.bytesFilled,t=e.elementSize;return new e.ctor(e.buffer,e.byteOffset,r/t)}function Er(e,r,t,o){e._queue.push({buffer:r,byteOffset:t,byteLength:o}),e._queueTotalSize+=o}function Wr(e,r){const t=r.elementSize,o=r.bytesFilled-r.bytesFilled%t,n=Math.min(e._queueTotalSize,r.byteLength-r.bytesFilled),a=r.bytesFilled+n,i=a-a%t;let s=n,l=!1;i>o&&(s=i-r.bytesFilled,l=!0);const c=e._queue;for(;s>0;){const t=c[0],o=Math.min(s,t.byteLength),n=r.byteOffset+r.bytesFilled;we(r.buffer,n,t.buffer,t.byteOffset,o),t.byteLength===o?c.shift():(t.byteOffset+=o,t.byteLength-=o),e._queueTotalSize-=o,Ar(e,o,r),s-=o}return l}function Ar(e,r,t){Br(e),t.bytesFilled+=r}function Or(e){0===e._queueTotalSize&&!0===e._closeRequested?(Fr(e),Ze(e._controlledReadableByteStream)):qr(e)}function Br(e){void 0!==e._byobRequest&&(e._byobRequest._associatedReadableByteStreamController=void 0,e._byobRequest._view=void 0,e._byobRequest=void 0)}function zr(e){for(;e._pendingPullIntos.length>0;){if(0===e._queueTotalSize)return;const r=e._pendingPullIntos[0];!0===Wr(e,r)&&(Ir(e),Tr(e._controlledReadableByteStream,r))}}function kr(e,r){const t=e._pendingPullIntos[0];if("closed"===e._controlledReadableByteStream._state){if(0!==r)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");!function(e,r){r.buffer=Pe(r.buffer);const t=e._controlledReadableByteStream;if(!0===ar(t))for(;or(t)>0;)Tr(t,Ir(e))}(e,t)}else!function(e,r,t){if(t.bytesFilled+r>t.byteLength)throw new RangeError("bytesWritten out of range");if(Ar(e,r,t),t.bytesFilled<t.elementSize)return;Ir(e);const o=t.bytesFilled%t.elementSize;if(o>0){const r=t.byteOffset+t.bytesFilled,n=t.buffer.slice(r-o,r);Er(e,n,0,n.byteLength)}t.buffer=Pe(t.buffer),t.bytesFilled-=o,Tr(e._controlledReadableByteStream,t),zr(e)}(e,r,t);qr(e)}function Ir(e){const r=e._pendingPullIntos.shift();return Br(e),r}function Fr(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0}function Dr(e,r){const t=e._controlledReadableByteStream;"readable"===t._state&&(Cr(e),Be(e),Fr(e),rr(t,r))}function Nr(e){const r=e._controlledReadableByteStream._state;return"errored"===r?null:"closed"===r?0:e._strategyHWM-e._queueTotalSize}function Mr(e,r,t,o,n,a,i){r._controlledReadableByteStream=e,r._pullAgain=!1,r._pulling=!1,Cr(r),r._queue=r._queueTotalSize=void 0,Be(r),r._closeRequested=!1,r._started=!1,r._strategyHWM=qe(a),r._pullAlgorithm=o,r._cancelAlgorithm=n,r._autoAllocateChunkSize=i,r._pendingPullIntos=[],e._readableStreamController=r;const s=t();Promise.resolve(s).then(()=>{r._started=!0,qr(r)},e=>{Dr(r,e)}).catch(We)}function Lr(e){return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`)}function Vr(e){return new TypeError("Cannot "+e+" a stream using a released reader")}function Yr(e){return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`)}function $r(e,r){e._closedPromise_reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}function Hr(e){return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`)}function xr(e){return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`)}function Qr(e){return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`)}function Ur(e){return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`)}var Gr=$e.ReadableStream;const{createDataProperty:Jr}=m;const{createDataProperty:Kr}=m;const{InvokeOrNoop:Xr,CreateAlgorithmFromUnderlyingMethod:Zr,PromiseCall:et,typeIsObject:rt,ValidateAndNormalizeHighWaterMark:tt,IsNonNegativeNumber:ot,MakeSizeAlgorithmFromSizeFunction:nt}=m,{CreateReadableStream:at,ReadableStreamDefaultControllerClose:it,ReadableStreamDefaultControllerEnqueue:st,ReadableStreamDefaultControllerError:lt,ReadableStreamDefaultControllerGetDesiredSize:ct,ReadableStreamDefaultControllerHasBackpressure:ut,ReadableStreamDefaultControllerCanCloseOrEnqueue:dt}=$e,{CreateWritableStream:ft,WritableStreamDefaultControllerErrorIfNeeded:mt}=D;v("streams:transform-stream:verbose");class TransformStream{constructor(e={},r={},t={}){const o=r.size;let n=r.highWaterMark;const a=t.size;let i=t.highWaterMark;if(void 0!==e.writableType)throw new RangeError("Invalid writable type specified");const s=nt(o);if(void 0===n&&(n=1),n=tt(n),void 0!==e.readableType)throw new RangeError("Invalid readable type specified");const l=nt(a);let c;void 0===i&&(i=0),i=tt(i),_t(this,new Promise(e=>{c=e}),n,s,i,l),function(e,r){const t=Object.create(TransformStreamDefaultController.prototype);let o=e=>{try{return vt(t,e),Promise.resolve()}catch(e){return Promise.reject(e)}};const n=r.transform;if(void 0!==n){if("function"!=typeof n)throw new TypeError("transform is not a method");o=(e=>et(n,r,[e,t]))}const a=Zr(r,"flush",0,[t]);St(e,t,o,a)}(this,e);const u=Xr(e,"start",[this._transformStreamController]);c(u)}get readable(){if(!1===ht(this))throw qt("readable");return this._readable}get writable(){if(!1===ht(this))throw qt("writable");return this._writable}}function _t(e,r,t,o,n,a){function i(){return r}e._writable=ft(i,function(r){return function(e,r){const t=e._transformStreamController;if(!0===e._backpressure){const o=e._backpressureChangePromise;return o.then(()=>{const o=e._writable,n=o._state;if("erroring"===n)throw o._storedError;return Rt(t,r)})}return Rt(t,r)}(e,r)},function(){return function(e){const r=e._readable,t=e._transformStreamController,o=t._flushAlgorithm();return gt(t),o.then(()=>{if("errored"===r._state)throw r._storedError;const e=r._readableStreamController;!0===dt(e)&&it(e)}).catch(t=>{throw bt(e,t),r._storedError})}(e)},function(r){return function(e,r){return bt(e,r),Promise.resolve()}(e,r)},t,o),e._readable=at(i,function(){return function(e){return pt(e,!1),e._backpressureChangePromise}(e)},function(r){return yt(e,r),Promise.resolve()},n,a),e._backpressure=void 0,e._backpressureChangePromise=void 0,e._backpressureChangePromise_resolve=void 0,pt(e,!0),e._transformStreamController=void 0}function ht(e){return!!rt(e)&&!!Object.prototype.hasOwnProperty.call(e,"_transformStreamController")}function bt(e,r){lt(e._readable._readableStreamController,r),yt(e,r)}function yt(e,r){gt(e._transformStreamController),mt(e._writable._writableStreamController,r),!0===e._backpressure&&pt(e,!1)}function pt(e,r){void 0!==e._backpressureChangePromise&&e._backpressureChangePromise_resolve(),e._backpressureChangePromise=new Promise(r=>{e._backpressureChangePromise_resolve=r}),e._backpressure=r}class TransformStreamDefaultController{constructor(){throw new TypeError("TransformStreamDefaultController instances cannot be created directly")}get desiredSize(){if(!1===wt(this))throw Pt("desiredSize");const e=this._controlledTransformStream._readable._readableStreamController;return ct(e)}enqueue(e){if(!1===wt(this))throw Pt("enqueue");vt(this,e)}error(e){if(!1===wt(this))throw Pt("error");!function(e,r){bt(e._controlledTransformStream,r)}(this,e)}terminate(){if(!1===wt(this))throw Pt("terminate");!function(e){const r=e._controlledTransformStream,t=r._readable._readableStreamController;!0===dt(t)&&it(t);const o=new TypeError("TransformStream terminated");yt(r,o)}(this)}}function wt(e){return!!rt(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledTransformStream")}function St(e,r,t,o){r._controlledTransformStream=e,e._transformStreamController=r,r._transformAlgorithm=t,r._flushAlgorithm=o}function gt(e){e._transformAlgorithm=void 0,e._flushAlgorithm=void 0}function vt(e,r){const t=e._controlledTransformStream,o=t._readable._readableStreamController;if(!1===dt(o))throw new TypeError("Readable side is not in a state that permits enqueue");try{st(o,r)}catch(e){throw yt(t,e),t._readable._storedError}ut(o)!==t._backpressure&&pt(t,!0)}function Rt(e,r){return e._transformAlgorithm(r).catch(r=>{throw bt(e._controlledTransformStream,r),r})}function Pt(e){return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`)}function qt(e){return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`)}var Ct={CreateTransformStream:function(e,r,t,o=1,n=(()=>1),a=0,i=(()=>1)){const s=Object.create(TransformStream.prototype);let l;_t(s,new Promise(e=>{l=e}),o,n,a,i),St(s,Object.create(TransformStreamDefaultController.prototype),r,t);const c=e();return l(c),s},TransformStream:TransformStream}.TransformStream;e.ReadableStream=Gr,e.WritableStream=pe,e.ByteLengthQueuingStrategy=class ByteLengthQueuingStrategy{constructor({highWaterMark:e}){Jr(this,"highWaterMark",e)}size(e){return e.byteLength}},e.CountQueuingStrategy=class CountQueuingStrategy{constructor({highWaterMark:e}){Kr(this,"highWaterMark",e)}size(){return 1}},e.TransformStream=Ct,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=ponyfill.es6.min.js.map
