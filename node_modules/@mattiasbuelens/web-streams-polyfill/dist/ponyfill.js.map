{"version":3,"file":"ponyfill.js","sources":["../src/stub/number-isinteger.js","../src/stub/symbol.js","../src/utils.js","../src/stub/number-isnan.js","../spec/reference-implementation/lib/helpers.js","../src/stub/assert.js","../spec/reference-implementation/lib/utils.js","../spec/reference-implementation/lib/queue-with-sizes.js","../spec/reference-implementation/lib/writable-stream.js","../spec/reference-implementation/lib/readable-stream.js","../spec/reference-implementation/lib/byte-length-queuing-strategy.js","../spec/reference-implementation/lib/count-queuing-strategy.js","../spec/reference-implementation/lib/transform-stream.js"],"sourcesContent":["// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger#Polyfill\nconst NumberIsInteger = Number.isInteger || function (value) {\n  return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\nexport default NumberIsInteger;\n","const SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n  Symbol :\n  description => `Symbol(${description})`;\n\nexport default SymbolPolyfill;\n","export function noop() {\n  // do nothing\n}\n\nfunction getGlobals() {\n  /* global self, window, global */\n  if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  }\n  return undefined;\n}\n\nexport const globals = getGlobals();\n","// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN = Number.isNaN || function (x) {\n  // eslint-disable-next-line no-self-compare\n  return x !== x;\n};\n\nexport default NumberIsNaN;\n","'use strict';\nconst assert = require('better-assert');\n\nconst isFakeDetached = Symbol('is \"detached\" for our purposes');\n\nfunction IsPropertyKey(argument) {\n  return typeof argument === 'string' || typeof argument === 'symbol';\n}\n\nexports.typeIsObject = x => (typeof x === 'object' && x !== null) || typeof x === 'function';\n\nexports.createDataProperty = (o, p, v) => {\n  assert(exports.typeIsObject(o));\n  Object.defineProperty(o, p, { value: v, writable: true, enumerable: true, configurable: true });\n};\n\nexports.createArrayFromList = elements => {\n  // We use arrays to represent lists, so this is basically a no-op.\n  // Do a slice though just in case we happen to depend on the unique-ness.\n  return elements.slice();\n};\n\nexports.ArrayBufferCopy = (dest, destOffset, src, srcOffset, n) => {\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n};\n\nexports.IsFiniteNonNegativeNumber = v => {\n  if (exports.IsNonNegativeNumber(v) === false) {\n    return false;\n  }\n\n  if (v === Infinity) {\n    return false;\n  }\n\n  return true;\n};\n\nexports.IsNonNegativeNumber = v => {\n  if (typeof v !== 'number') {\n    return false;\n  }\n\n  if (Number.isNaN(v)) {\n    return false;\n  }\n\n  if (v < 0) {\n    return false;\n  }\n\n  return true;\n};\n\nfunction Call(F, V, args) {\n  if (typeof F !== 'function') {\n    throw new TypeError('Argument is not a function');\n  }\n\n  return Function.prototype.apply.call(F, V, args);\n}\n\nexports.Call = Call;\n\nexports.CreateAlgorithmFromUnderlyingMethod = (underlyingObject, methodName, algoArgCount, extraArgs) => {\n  assert(underlyingObject !== undefined);\n  assert(IsPropertyKey(methodName));\n  assert(algoArgCount === 0 || algoArgCount === 1);\n  assert(Array.isArray(extraArgs));\n  const method = underlyingObject[methodName];\n  if (method !== undefined) {\n    if (typeof method !== 'function') {\n      throw new TypeError(`${method} is not a method`);\n    }\n    switch (algoArgCount) {\n      case 0: {\n        return () => {\n          return PromiseCall(method, underlyingObject, extraArgs);\n        };\n      }\n\n      case 1: {\n        return arg => {\n          const fullArgs = [arg].concat(extraArgs);\n          return PromiseCall(method, underlyingObject, fullArgs);\n        };\n      }\n    }\n  }\n  return () => Promise.resolve();\n};\n\nexports.InvokeOrNoop = (O, P, args) => {\n  assert(O !== undefined);\n  assert(IsPropertyKey(P));\n  assert(Array.isArray(args));\n\n  const method = O[P];\n  if (method === undefined) {\n    return undefined;\n  }\n\n  return Call(method, O, args);\n};\n\nfunction PromiseCall(F, V, args) {\n  assert(typeof F === 'function');\n  assert(V !== undefined);\n  assert(Array.isArray(args));\n  try {\n    return Promise.resolve(Call(F, V, args));\n  } catch (value) {\n    return Promise.reject(value);\n  }\n}\n\nexports.PromiseCall = PromiseCall;\n\n// Not implemented correctly\nexports.TransferArrayBuffer = O => {\n  assert(!exports.IsDetachedBuffer(O));\n  const transferredIshVersion = O.slice();\n\n  // This is specifically to fool tests that test \"is transferred\" by taking a non-zero-length\n  // ArrayBuffer and checking if its byteLength starts returning 0.\n  Object.defineProperty(O, 'byteLength', {\n    get() {\n      return 0;\n    }\n  });\n  O[isFakeDetached] = true;\n\n  return transferredIshVersion;\n};\n\n// Not implemented correctly\nexports.IsDetachedBuffer = O => {\n  return isFakeDetached in O;\n};\n\nexports.ValidateAndNormalizeHighWaterMark = highWaterMark => {\n  highWaterMark = Number(highWaterMark);\n  if (Number.isNaN(highWaterMark) || highWaterMark < 0) {\n    throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');\n  }\n\n  return highWaterMark;\n};\n\nexports.MakeSizeAlgorithmFromSizeFunction = size => {\n  if (size === undefined) {\n    return () => 1;\n  }\n  if (typeof size !== 'function') {\n    throw new TypeError('size property of a queuing strategy must be a function');\n  }\n  return chunk => size(chunk);\n};\n","import { noop } from '../utils';\n\nexport default function assert() {\n  // do nothing\n}\n\nassert.AssertionError = noop;\n","'use strict';\nconst assert = require('assert');\n\nexports.rethrowAssertionErrorRejection = e => {\n  // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\n  // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\n  // expect any errors, but assertion errors are always problematic.\n  if (e && e instanceof assert.AssertionError) {\n    setTimeout(() => {\n      throw e;\n    }, 0);\n  }\n};\n","'use strict';\nconst assert = require('better-assert');\nconst { IsFiniteNonNegativeNumber } = require('./helpers.js');\n\nexports.DequeueValue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.shift();\n  container._queueTotalSize -= pair.size;\n  if (container._queueTotalSize < 0) {\n    container._queueTotalSize = 0;\n  }\n\n  return pair.value;\n};\n\nexports.EnqueueValueWithSize = (container, value, size) => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  size = Number(size);\n  if (!IsFiniteNonNegativeNumber(size)) {\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n\n  container._queue.push({ value, size });\n  container._queueTotalSize += size;\n};\n\nexports.PeekQueueValue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue[0];\n  return pair.value;\n};\n\nexports.ResetQueue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  container._queue = [];\n  container._queueTotalSize = 0;\n};\n","'use strict';\nconst assert = require('better-assert');\n\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\n// and do not appear in the standard text.\nconst verbose = require('debug')('streams:writable-stream:verbose');\n\nconst { CreateAlgorithmFromUnderlyingMethod, InvokeOrNoop, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction, typeIsObject } = require('./helpers.js');\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\nconst { DequeueValue, EnqueueValueWithSize, PeekQueueValue, ResetQueue } = require('./queue-with-sizes.js');\n\nconst AbortSteps = Symbol('[[AbortSteps]]');\nconst ErrorSteps = Symbol('[[ErrorSteps]]');\n\nclass WritableStream {\n  constructor(underlyingSink = {}, strategy = {}) {\n    InitializeWritableStream(this);\n\n    const size = strategy.size;\n    let highWaterMark = strategy.highWaterMark;\n\n    const type = underlyingSink.type;\n\n    if (type !== undefined) {\n      throw new RangeError('Invalid type is specified');\n    }\n\n    const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n    if (highWaterMark === undefined) {\n      highWaterMark = 1;\n    }\n    highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n  }\n\n  get locked() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsWritableStreamLocked(this);\n  }\n\n  abort(reason) {\n    if (IsWritableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('abort'));\n    }\n\n    if (IsWritableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot abort a stream that already has a writer'));\n    }\n\n    return WritableStreamAbort(this, reason);\n  }\n\n  getWriter() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException('getWriter');\n    }\n\n    return AcquireWritableStreamDefaultWriter(this);\n  }\n}\n\nmodule.exports = {\n  AcquireWritableStreamDefaultWriter,\n  CreateWritableStream,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamDefaultControllerErrorIfNeeded,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite,\n  WritableStreamCloseQueuedOrInFlight\n};\n\n// Abstract operations for the WritableStream.\n\nfunction AcquireWritableStreamDefaultWriter(stream) {\n  return new WritableStreamDefaultWriter(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1,\n                              sizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n\n  const stream = Object.create(WritableStream.prototype);\n  InitializeWritableStream(stream);\n\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n}\n\nfunction InitializeWritableStream(stream) {\n  stream._state = 'writable';\n\n  // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n  // 'erroring' or 'errored'. May be set to an undefined value.\n  stream._storedError = undefined;\n\n  stream._writer = undefined;\n\n  // Initialize to undefined first because the constructor of the controller checks this\n  // variable to validate the caller.\n  stream._writableStreamController = undefined;\n\n  // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  // producer without waiting for the queued writes to finish.\n  stream._writeRequests = [];\n\n  // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  stream._inFlightWriteRequest = undefined;\n\n  // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  // has been detached.\n  stream._closeRequest = undefined;\n\n  // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n  stream._inFlightCloseRequest = undefined;\n\n  // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n  stream._pendingAbortRequest = undefined;\n\n  // The backpressure signal set by the controller.\n  stream._backpressure = false;\n}\n\nfunction IsWritableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsWritableStreamLocked(stream) {\n  assert(IsWritableStream(stream) === true);\n\n  if (stream._writer === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamAbort(stream, reason) {\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return Promise.resolve(undefined);\n  }\n  if (stream._pendingAbortRequest !== undefined) {\n    return stream._pendingAbortRequest._promise;\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  let wasAlreadyErroring = false;\n  if (state === 'erroring') {\n    wasAlreadyErroring = true;\n    // reason will not be used, so don't keep a reference to it.\n    reason = undefined;\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    stream._pendingAbortRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _reason: reason,\n      _wasAlreadyErroring: wasAlreadyErroring\n    };\n  });\n  stream._pendingAbortRequest._promise = promise;\n\n  if (wasAlreadyErroring === false) {\n    WritableStreamStartErroring(stream, reason);\n  }\n\n  return promise;\n}\n\n// WritableStream API exposed for controllers.\n\nfunction WritableStreamAddWriteRequest(stream) {\n  assert(IsWritableStreamLocked(stream) === true);\n  assert(stream._state === 'writable');\n\n  const promise = new Promise((resolve, reject) => {\n    const writeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._writeRequests.push(writeRequest);\n  });\n\n  return promise;\n}\n\nfunction WritableStreamDealWithRejection(stream, error) {\n  verbose('WritableStreamDealWithRejection(stream, %o)', error);\n  const state = stream._state;\n\n  if (state === 'writable') {\n    WritableStreamStartErroring(stream, error);\n    return;\n  }\n\n  assert(state === 'erroring');\n  WritableStreamFinishErroring(stream);\n}\n\nfunction WritableStreamStartErroring(stream, reason) {\n  verbose('WritableStreamStartErroring(stream, %o)', reason);\n  assert(stream._storedError === undefined);\n  assert(stream._state === 'writable');\n\n  const controller = stream._writableStreamController;\n  assert(controller !== undefined);\n\n  stream._state = 'erroring';\n  stream._storedError = reason;\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n\n  if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {\n    WritableStreamFinishErroring(stream);\n  }\n}\n\nfunction WritableStreamFinishErroring(stream) {\n  verbose('WritableStreamFinishErroring()');\n  assert(stream._state === 'erroring');\n  assert(WritableStreamHasOperationMarkedInFlight(stream) === false);\n  stream._state = 'errored';\n  stream._writableStreamController[ErrorSteps]();\n\n  const storedError = stream._storedError;\n  for (const writeRequest of stream._writeRequests) {\n    writeRequest._reject(storedError);\n  }\n  stream._writeRequests = [];\n\n  if (stream._pendingAbortRequest === undefined) {\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const abortRequest = stream._pendingAbortRequest;\n  stream._pendingAbortRequest = undefined;\n\n  if (abortRequest._wasAlreadyErroring === true) {\n    abortRequest._reject(storedError);\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n  promise.then(\n      () => {\n        abortRequest._resolve();\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      },\n      reason => {\n        abortRequest._reject(reason);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      });\n}\n\nfunction WritableStreamFinishInFlightWrite(stream) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest._resolve(undefined);\n  stream._inFlightWriteRequest = undefined;\n}\n\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest._reject(error);\n  stream._inFlightWriteRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  WritableStreamDealWithRejection(stream, error);\n}\n\nfunction WritableStreamFinishInFlightClose(stream) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest._resolve(undefined);\n  stream._inFlightCloseRequest = undefined;\n\n  const state = stream._state;\n\n  assert(state === 'writable' || state === 'erroring');\n\n  if (state === 'erroring') {\n    // The error was too late to do anything, so it is ignored.\n    stream._storedError = undefined;\n    if (stream._pendingAbortRequest !== undefined) {\n      stream._pendingAbortRequest._resolve();\n      stream._pendingAbortRequest = undefined;\n    }\n  }\n\n  stream._state = 'closed';\n\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseResolve(writer);\n  }\n\n  assert(stream._pendingAbortRequest === undefined);\n  assert(stream._storedError === undefined);\n}\n\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest._reject(error);\n  stream._inFlightCloseRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  // Never execute sink abort() after sink close().\n  if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._reject(error);\n    stream._pendingAbortRequest = undefined;\n  }\n  WritableStreamDealWithRejection(stream, error);\n}\n\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    verbose('WritableStreamHasOperationMarkedInFlight() is false');\n    return false;\n  }\n\n  verbose('WritableStreamHasOperationMarkedInFlight() is true');\n  return true;\n}\n\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\n  assert(stream._inFlightCloseRequest === undefined);\n  assert(stream._closeRequest !== undefined);\n  stream._inFlightCloseRequest = stream._closeRequest;\n  stream._closeRequest = undefined;\n}\n\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\n  assert(stream._inFlightWriteRequest === undefined);\n  assert(stream._writeRequests.length !== 0);\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\n\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n  verbose('WritableStreamRejectCloseAndClosedPromiseIfNeeded()');\n  assert(stream._state === 'errored');\n  if (stream._closeRequest !== undefined) {\n    assert(stream._inFlightCloseRequest === undefined);\n\n    stream._closeRequest._reject(stream._storedError);\n    stream._closeRequest = undefined;\n  }\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\n    writer._closedPromise.catch(() => {});\n  }\n}\n\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\n  assert(stream._state === 'writable');\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\n\n  const writer = stream._writer;\n  if (writer !== undefined && backpressure !== stream._backpressure) {\n    if (backpressure === true) {\n      defaultWriterReadyPromiseReset(writer);\n    } else {\n      assert(backpressure === false);\n\n      defaultWriterReadyPromiseResolve(writer);\n    }\n  }\n\n  stream._backpressure = backpressure;\n}\n\nclass WritableStreamDefaultWriter {\n  constructor(stream) {\n    if (IsWritableStream(stream) === false) {\n      throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');\n    }\n    if (IsWritableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n    }\n\n    this._ownerWritableStream = stream;\n    stream._writer = this;\n\n    const state = stream._state;\n\n    if (state === 'writable') {\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {\n        defaultWriterReadyPromiseInitialize(this);\n      } else {\n        defaultWriterReadyPromiseInitializeAsResolved(this);\n      }\n\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'erroring') {\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n      this._readyPromise.catch(() => {});\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'closed') {\n      defaultWriterReadyPromiseInitializeAsResolved(this);\n      defaultWriterClosedPromiseInitializeAsResolved(this);\n    } else {\n      assert(state === 'errored');\n\n      const storedError = stream._storedError;\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n      this._readyPromise.catch(() => {});\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n      this._closedPromise.catch(() => {});\n    }\n  }\n\n  get closed() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  get desiredSize() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException('desiredSize');\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      throw defaultWriterLockException('desiredSize');\n    }\n\n    return WritableStreamDefaultWriterGetDesiredSize(this);\n  }\n\n  get ready() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('ready'));\n    }\n\n    return this._readyPromise;\n  }\n\n  abort(reason) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('abort'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return Promise.reject(defaultWriterLockException('abort'));\n    }\n\n    return WritableStreamDefaultWriterAbort(this, reason);\n  }\n\n  close() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('close'));\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return Promise.reject(defaultWriterLockException('close'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true) {\n      return Promise.reject(new TypeError('cannot close an already-closing stream'));\n    }\n\n    return WritableStreamDefaultWriterClose(this);\n  }\n\n  releaseLock() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException('releaseLock');\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return;\n    }\n\n    assert(stream._writer !== undefined);\n\n    WritableStreamDefaultWriterRelease(this);\n  }\n\n  write(chunk) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('write'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return Promise.reject(defaultWriterLockException('write to'));\n    }\n\n    return WritableStreamDefaultWriterWrite(this, chunk);\n  }\n}\n\n// Abstract operations for the WritableStreamDefaultWriter.\n\nfunction IsWritableStreamDefaultWriter(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamAbort(stream, reason);\n}\n\nfunction WritableStreamDefaultWriterClose(writer) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return Promise.reject(new TypeError(\n      `The stream (in ${state} state) is not in the writable state and cannot be closed`));\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\n\n  const promise = new Promise((resolve, reject) => {\n    const closeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._closeRequest = closeRequest;\n  });\n\n  if (stream._backpressure === true && state === 'writable') {\n    defaultWriterReadyPromiseResolve(writer);\n  }\n\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n\n  return promise;\n}\n\n\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n    return Promise.resolve();\n  }\n\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  return WritableStreamDefaultWriterClose(writer);\n}\n\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n  if (writer._closedPromiseState === 'pending') {\n    defaultWriterClosedPromiseReject(writer, error);\n  } else {\n    defaultWriterClosedPromiseResetToRejected(writer, error);\n  }\n  writer._closedPromise.catch(() => {});\n}\n\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n  verbose('WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, %o)', error);\n  if (writer._readyPromiseState === 'pending') {\n    defaultWriterReadyPromiseReject(writer, error);\n  } else {\n    defaultWriterReadyPromiseResetToRejected(writer, error);\n  }\n  writer._readyPromise.catch(() => {});\n}\n\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\n  const stream = writer._ownerWritableStream;\n  const state = stream._state;\n\n  if (state === 'errored' || state === 'erroring') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\n\nfunction WritableStreamDefaultWriterRelease(writer) {\n  const stream = writer._ownerWritableStream;\n  assert(stream !== undefined);\n  assert(stream._writer === writer);\n\n  const releasedError = new TypeError(\n    'Writer was released and can no longer be used to monitor the stream\\'s closedness');\n\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n\n  // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  // rejected until afterwards. This means that simply testing state will not work.\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined;\n}\n\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const controller = stream._writableStreamController;\n\n  const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n\n  if (stream !== writer._ownerWritableStream) {\n    return Promise.reject(defaultWriterLockException('write to'));\n  }\n\n  const state = stream._state;\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n    return Promise.reject(new TypeError('The stream is closing or closed and cannot be written to'));\n  }\n  if (state === 'erroring') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(state === 'writable');\n\n  const promise = WritableStreamAddWriteRequest(stream);\n\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n\n  return promise;\n}\n\nclass WritableStreamDefaultController {\n  constructor() {\n    throw new TypeError('WritableStreamDefaultController cannot be constructed explicitly');\n  }\n\n  error(e) {\n    if (IsWritableStreamDefaultController(this) === false) {\n      throw new TypeError(\n        'WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\n    }\n    const state = this._controlledWritableStream._state;\n    if (state !== 'writable') {\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n      // just treat it as a no-op.\n      return;\n    }\n\n    WritableStreamDefaultControllerError(this, e);\n  }\n\n  [AbortSteps](reason) {\n    const result = this._abortAlgorithm(reason);\n    WritableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  [ErrorSteps]() {\n    ResetQueue(this);\n  }\n}\n\n// Abstract operations implementing interface required by the WritableStream.\n\nfunction IsWritableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                              abortAlgorithm, highWaterMark, sizeAlgorithm) {\n  assert(IsWritableStream(stream) === true);\n  assert(stream._writableStreamController === undefined);\n\n  controller._controlledWritableStream = stream;\n  stream._writableStreamController = controller;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._started = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._writeAlgorithm = writeAlgorithm;\n  controller._closeAlgorithm = closeAlgorithm;\n  controller._abortAlgorithm = abortAlgorithm;\n\n  const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n  WritableStreamUpdateBackpressure(stream, backpressure);\n\n  const startResult = startAlgorithm();\n  const startPromise = Promise.resolve(startResult);\n  startPromise.then(\n      () => {\n        assert(stream._state === 'writable' || stream._state === 'erroring');\n        controller._started = true;\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n      },\n      r => {\n        assert(stream._state === 'writable' || stream._state === 'erroring');\n        controller._started = true;\n        WritableStreamDealWithRejection(stream, r);\n      }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n  assert(underlyingSink !== undefined);\n\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingSink, 'start', [controller]);\n  }\n\n  const writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'write', 1, [controller]);\n  const closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'close', 0, []);\n  const abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'abort', 1, []);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n}\n\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller) {\n  controller._writeAlgorithm = undefined;\n  controller._closeAlgorithm = undefined;\n  controller._abortAlgorithm = undefined;\n  controller._strategySizeAlgorithm = undefined;\n}\n\nfunction WritableStreamDefaultControllerClose(controller) {\n  EnqueueValueWithSize(controller, 'close', 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n  try {\n    return controller._strategySizeAlgorithm(chunk);\n  } catch (chunkSizeE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n    return 1;\n  }\n}\n\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n  const writeRecord = { chunk };\n\n  try {\n    EnqueueValueWithSize(controller, writeRecord, chunkSize);\n  } catch (enqueueE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n    return;\n  }\n\n  const stream = controller._controlledWritableStream;\n  if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n  }\n\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\n// Abstract operations for the WritableStreamDefaultController.\n\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n  verbose('WritableStreamDefaultControllerAdvanceQueueIfNeeded()');\n  const stream = controller._controlledWritableStream;\n\n  if (controller._started === false) {\n    return;\n  }\n\n  if (stream._inFlightWriteRequest !== undefined) {\n    return;\n  }\n\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return;\n  }\n  if (state === 'erroring') {\n    WritableStreamFinishErroring(stream);\n    return;\n  }\n\n  if (controller._queue.length === 0) {\n    return;\n  }\n\n  const writeRecord = PeekQueueValue(controller);\n  if (writeRecord === 'close') {\n    WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n    WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);\n  }\n}\n\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n  if (controller._controlledWritableStream._state === 'writable') {\n    WritableStreamDefaultControllerError(controller, error);\n  }\n}\n\nfunction WritableStreamDefaultControllerProcessClose(controller) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkCloseRequestInFlight(stream);\n\n  DequeueValue(controller);\n  assert(controller._queue.length === 0);\n\n  const sinkClosePromise = controller._closeAlgorithm();\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  sinkClosePromise.then(\n    () => {\n      WritableStreamFinishInFlightClose(stream);\n    },\n    reason => {\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\n\n  const sinkWritePromise = controller._writeAlgorithm(chunk);\n  sinkWritePromise.then(\n    () => {\n      WritableStreamFinishInFlightWrite(stream);\n\n      const state = stream._state;\n      assert(state === 'writable' || state === 'erroring');\n\n      DequeueValue(controller);\n\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n      }\n\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    },\n    reason => {\n      if (stream._state === 'writable') {\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n      }\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n}\n\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultControllerError(controller, error) {\n  const stream = controller._controlledWritableStream;\n\n  assert(stream._state === 'writable');\n\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  WritableStreamStartErroring(stream, error);\n}\n\n// Helper functions for the WritableStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n\n// Helper functions for the WritableStreamDefaultWriter.\n\nfunction defaultWriterBrandCheckException(name) {\n  return new TypeError(\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\n\nfunction defaultWriterLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\n\nfunction defaultWriterClosedPromiseInitialize(writer) {\n  writer._closedPromise = new Promise((resolve, reject) => {\n    writer._closedPromise_resolve = resolve;\n    writer._closedPromise_reject = reject;\n    writer._closedPromiseState = 'pending';\n  });\n}\n\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n  writer._closedPromise = Promise.reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\n  writer._closedPromise = Promise.resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterClosedPromiseReject(writer, reason) {\n  assert(writer._closedPromise_resolve !== undefined);\n  assert(writer._closedPromise_reject !== undefined);\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\n  assert(writer._closedPromise_resolve === undefined);\n  assert(writer._closedPromise_reject === undefined);\n  assert(writer._closedPromiseState !== 'pending');\n\n  writer._closedPromise = Promise.reject(reason);\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResolve(writer) {\n  assert(writer._closedPromise_resolve !== undefined);\n  assert(writer._closedPromise_reject !== undefined);\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterReadyPromiseInitialize(writer) {\n  verbose('defaultWriterReadyPromiseInitialize()');\n  writer._readyPromise = new Promise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n  verbose('defaultWriterReadyPromiseInitializeAsRejected(writer, %o)', reason);\n  writer._readyPromise = Promise.reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\n  verbose('defaultWriterReadyPromiseInitializeAsResolved()');\n  writer._readyPromise = Promise.resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n\nfunction defaultWriterReadyPromiseReject(writer, reason) {\n  verbose('defaultWriterReadyPromiseReject(writer, %o)', reason);\n  assert(writer._readyPromise_resolve !== undefined);\n  assert(writer._readyPromise_reject !== undefined);\n\n  writer._readyPromise_reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseReset(writer) {\n  verbose('defaultWriterReadyPromiseReset()');\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  writer._readyPromise = new Promise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\n  verbose('defaultWriterReadyPromiseResetToRejected(writer, %o)', reason);\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  writer._readyPromise = Promise.reject(reason);\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseResolve(writer) {\n  verbose('defaultWriterReadyPromiseResolve()');\n  assert(writer._readyPromise_resolve !== undefined);\n  assert(writer._readyPromise_reject !== undefined);\n\n  writer._readyPromise_resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n","'use strict';\nconst assert = require('better-assert');\nconst { ArrayBufferCopy, CreateAlgorithmFromUnderlyingMethod, IsFiniteNonNegativeNumber, InvokeOrNoop,\n        IsDetachedBuffer, TransferArrayBuffer, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction, createArrayFromList, typeIsObject } = require('./helpers.js');\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\nconst { DequeueValue, EnqueueValueWithSize, ResetQueue } = require('./queue-with-sizes.js');\nconst { AcquireWritableStreamDefaultWriter, IsWritableStream, IsWritableStreamLocked,\n        WritableStreamAbort, WritableStreamDefaultWriterCloseWithErrorPropagation,\n        WritableStreamDefaultWriterRelease, WritableStreamDefaultWriterWrite, WritableStreamCloseQueuedOrInFlight } =\n      require('./writable-stream.js');\n\nconst CancelSteps = Symbol('[[CancelSteps]]');\nconst PullSteps = Symbol('[[PullSteps]]');\n\nclass ReadableStream {\n  constructor(underlyingSource = {}, strategy = {}) {\n    InitializeReadableStream(this);\n\n    const size = strategy.size;\n    let highWaterMark = strategy.highWaterMark;\n\n    const type = underlyingSource.type;\n    const typeString = String(type);\n    if (typeString === 'bytes') {\n      if (size !== undefined) {\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\n      }\n\n      if (highWaterMark === undefined) {\n        highWaterMark = 0;\n      }\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n      SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n    } else if (type === undefined) {\n      const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n\n      if (highWaterMark === undefined) {\n        highWaterMark = 1;\n      }\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n    } else {\n      throw new RangeError('Invalid type is specified');\n    }\n  }\n\n  get locked() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsReadableStreamLocked(this);\n  }\n\n  cancel(reason) {\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('cancel'));\n    }\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));\n    }\n\n    return ReadableStreamCancel(this, reason);\n  }\n\n  getReader({ mode } = {}) {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('getReader');\n    }\n\n    if (mode === undefined) {\n      return AcquireReadableStreamDefaultReader(this);\n    }\n\n    mode = String(mode);\n\n    if (mode === 'byob') {\n      return AcquireReadableStreamBYOBReader(this);\n    }\n\n    throw new RangeError('Invalid mode is specified');\n  }\n\n  pipeThrough({ writable, readable }, options) {\n    if (writable === undefined || readable === undefined) {\n      throw new TypeError('readable and writable arguments must be defined');\n    }\n\n    const promise = this.pipeTo(writable, options);\n\n    ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise);\n\n    return readable;\n  }\n\n  pipeTo(dest, { preventClose, preventAbort, preventCancel } = {}) {\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('pipeTo'));\n    }\n    if (IsWritableStream(dest) === false) {\n      return Promise.reject(\n        new TypeError('ReadableStream.prototype.pipeTo\\'s first argument must be a WritableStream'));\n    }\n\n    preventClose = Boolean(preventClose);\n    preventAbort = Boolean(preventAbort);\n    preventCancel = Boolean(preventCancel);\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n    }\n    if (IsWritableStreamLocked(dest) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n    }\n\n    const reader = AcquireReadableStreamDefaultReader(this);\n    const writer = AcquireWritableStreamDefaultWriter(dest);\n\n    let shuttingDown = false;\n\n    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n    let currentWrite = Promise.resolve();\n\n    return new Promise((resolve, reject) => {\n      // Using reader and writer, read all chunks from this and write them to dest\n      // - Backpressure must be enforced\n      // - Shutdown must stop all activity\n      function pipeLoop() {\n        if (shuttingDown === true) {\n          return Promise.resolve();\n        }\n\n        return writer._readyPromise.then(() => {\n          return ReadableStreamDefaultReaderRead(reader).then(({ value, done }) => {\n            if (done === true) {\n              return;\n            }\n\n            currentWrite = WritableStreamDefaultWriterWrite(writer, value).catch(() => {});\n          });\n        })\n        .then(pipeLoop);\n      }\n\n      // Errors must be propagated forward\n      isOrBecomesErrored(this, reader._closedPromise, storedError => {\n        if (preventAbort === false) {\n          shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n        } else {\n          shutdown(true, storedError);\n        }\n      });\n\n      // Errors must be propagated backward\n      isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n        if (preventCancel === false) {\n          shutdownWithAction(() => ReadableStreamCancel(this, storedError), true, storedError);\n        } else {\n          shutdown(true, storedError);\n        }\n      });\n\n      // Closing must be propagated forward\n      isOrBecomesClosed(this, reader._closedPromise, () => {\n        if (preventClose === false) {\n          shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n        } else {\n          shutdown();\n        }\n      });\n\n      // Closing must be propagated backward\n      if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === 'closed') {\n        const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n\n        if (preventCancel === false) {\n          shutdownWithAction(() => ReadableStreamCancel(this, destClosed), true, destClosed);\n        } else {\n          shutdown(true, destClosed);\n        }\n      }\n\n      pipeLoop().catch(err => {\n        currentWrite = Promise.resolve();\n        rethrowAssertionErrorRejection(err);\n      });\n\n      function waitForWritesToFinish() {\n        // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n        // for that too.\n        const oldCurrentWrite = currentWrite;\n        return currentWrite.then(() => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n      }\n\n      function isOrBecomesErrored(stream, promise, action) {\n        if (stream._state === 'errored') {\n          action(stream._storedError);\n        } else {\n          promise.catch(action).catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function isOrBecomesClosed(stream, promise, action) {\n        if (stream._state === 'closed') {\n          action();\n        } else {\n          promise.then(action).catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function shutdownWithAction(action, originalIsError, originalError) {\n        if (shuttingDown === true) {\n          return;\n        }\n        shuttingDown = true;\n\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n          waitForWritesToFinish().then(doTheRest);\n        } else {\n          doTheRest();\n        }\n\n        function doTheRest() {\n          action().then(\n            () => finalize(originalIsError, originalError),\n            newError => finalize(true, newError)\n          )\n          .catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function shutdown(isError, error) {\n        if (shuttingDown === true) {\n          return;\n        }\n        shuttingDown = true;\n\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n          waitForWritesToFinish().then(() => finalize(isError, error)).catch(rethrowAssertionErrorRejection);\n        } else {\n          finalize(isError, error);\n        }\n      }\n\n      function finalize(isError, error) {\n        WritableStreamDefaultWriterRelease(writer);\n        ReadableStreamReaderGenericRelease(reader);\n\n        if (isError) {\n          reject(error);\n        } else {\n          resolve(undefined);\n        }\n      }\n    });\n  }\n\n  tee() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('tee');\n    }\n\n    const branches = ReadableStreamTee(this, false);\n    return createArrayFromList(branches);\n  }\n}\n\nmodule.exports = {\n  CreateReadableByteStream,\n  CreateReadableStream,\n  ReadableStream,\n  IsReadableStreamDisturbed,\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError,\n  ReadableStreamDefaultControllerGetDesiredSize,\n  ReadableStreamDefaultControllerHasBackpressure,\n  ReadableStreamDefaultControllerCanCloseOrEnqueue\n};\n\n// Abstract operations for the ReadableStream.\n\nfunction AcquireReadableStreamBYOBReader(stream) {\n  return new ReadableStreamBYOBReader(stream);\n}\n\nfunction AcquireReadableStreamDefaultReader(stream) {\n  return new ReadableStreamDefaultReader(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1,\n                              sizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n\n  const stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\n\n  SetUpReadableStreamDefaultController(\n      stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n\n  return stream;\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 0,\n                                  autoAllocateChunkSize = undefined) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  const stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller = Object.create(ReadableByteStreamController.prototype);\n\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\n                                    autoAllocateChunkSize);\n\n  return stream;\n}\n\nfunction InitializeReadableStream(stream) {\n  stream._state = 'readable';\n  stream._reader = undefined;\n  stream._storedError = undefined;\n  stream._disturbed = false;\n}\n\nfunction IsReadableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDisturbed(stream) {\n  assert(IsReadableStream(stream) === true);\n\n  return stream._disturbed;\n}\n\nfunction IsReadableStreamLocked(stream) {\n  assert(IsReadableStream(stream) === true);\n\n  if (stream._reader === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamTee(stream, cloneForBranch2) {\n  assert(IsReadableStream(stream) === true);\n  assert(typeof cloneForBranch2 === 'boolean');\n\n  const reader = AcquireReadableStreamDefaultReader(stream);\n\n  let closedOrErrored = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1;\n  let reason2;\n  let branch1;\n  let branch2;\n\n  let resolveCancelPromise;\n  const cancelPromise = new Promise(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function pullAlgorithm() {\n    return ReadableStreamDefaultReaderRead(reader).then(result => {\n      assert(typeIsObject(result));\n      const value = result.value;\n      const done = result.done;\n      assert(typeof done === 'boolean');\n\n      if (done === true && closedOrErrored === false) {\n        if (canceled1 === false) {\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n        }\n        if (canceled2 === false) {\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n        }\n        closedOrErrored = true;\n      }\n\n      if (closedOrErrored === true) {\n        return;\n      }\n\n      const value1 = value;\n      const value2 = value;\n\n      // There is no way to access the cloning code right now in the reference implementation.\n      // If we add one then we'll need an implementation for serializable objects.\n      // if (canceled2 === false && cloneForBranch2 === true) {\n      //   value2 = StructuredDeserialize(StructuredSerialize(value2));\n      // }\n\n      if (canceled1 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\n      }\n\n      if (canceled2 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\n      }\n    });\n  }\n\n  function cancel1Algorithm(reason) {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2 === true) {\n      const compositeReason = createArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason) {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1 === true) {\n      const compositeReason = createArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm() {}\n\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n\n  reader._closedPromise.catch(r => {\n    if (closedOrErrored === true) {\n      return;\n    }\n\n    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n    closedOrErrored = true;\n  });\n\n  return [branch1, branch2];\n}\n\n// ReadableStream API exposed for controllers.\n\nfunction ReadableStreamAddReadIntoRequest(stream, forAuthorCode) {\n  assert(IsReadableStreamBYOBReader(stream._reader) === true);\n  assert(stream._state === 'readable' || stream._state === 'closed');\n\n  const promise = new Promise((resolve, reject) => {\n    const readIntoRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _forAuthorCode: forAuthorCode\n    };\n\n    stream._reader._readIntoRequests.push(readIntoRequest);\n  });\n\n  return promise;\n}\n\nfunction ReadableStreamAddReadRequest(stream, forAuthorCode) {\n  assert(IsReadableStreamDefaultReader(stream._reader) === true);\n  assert(stream._state === 'readable');\n\n  const promise = new Promise((resolve, reject) => {\n    const readRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _forAuthorCode: forAuthorCode\n    };\n\n    stream._reader._readRequests.push(readRequest);\n  });\n\n  return promise;\n}\n\nfunction ReadableStreamCancel(stream, reason) {\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(undefined);\n  }\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  ReadableStreamClose(stream);\n\n  const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n  return sourceCancelPromise.then(() => undefined);\n}\n\nfunction ReadableStreamClose(stream) {\n  assert(stream._state === 'readable');\n\n  stream._state = 'closed';\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (const { _resolve, _forAuthorCode } of reader._readRequests) {\n      _resolve(ReadableStreamCreateReadResult(undefined, true, _forAuthorCode));\n    }\n    reader._readRequests = [];\n  }\n\n  defaultReaderClosedPromiseResolve(reader);\n\n  return undefined;\n}\n\nfunction ReadableStreamCreateReadResult(value, done, forAuthorCode) {\n  let prototype = null;\n  if (forAuthorCode === true) {\n    prototype = Object.prototype;\n  }\n  assert(typeof done === 'boolean');\n  const obj = Object.create(prototype);\n  Object.defineProperty(obj, 'value', { value, enumerable: true, writable: true, configurable: true });\n  Object.defineProperty(obj, 'done', { value: done, enumerable: true, writable: true, configurable: true });\n  return obj;\n}\n\nfunction ReadableStreamError(stream, e) {\n  assert(IsReadableStream(stream) === true);\n  assert(stream._state === 'readable');\n\n  stream._state = 'errored';\n  stream._storedError = e;\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (const readRequest of reader._readRequests) {\n      readRequest._reject(e);\n    }\n\n    reader._readRequests = [];\n  } else {\n    assert(IsReadableStreamBYOBReader(reader));\n\n    for (const readIntoRequest of reader._readIntoRequests) {\n      readIntoRequest._reject(e);\n    }\n\n    reader._readIntoRequests = [];\n  }\n\n  defaultReaderClosedPromiseReject(reader, e);\n  reader._closedPromise.catch(() => {});\n}\n\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n  const reader = stream._reader;\n\n  assert(reader._readIntoRequests.length > 0);\n\n  const readIntoRequest = reader._readIntoRequests.shift();\n  readIntoRequest._resolve(ReadableStreamCreateReadResult(chunk, done, readIntoRequest._forAuthorCode));\n}\n\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n  const reader = stream._reader;\n\n  assert(reader._readRequests.length > 0);\n\n  const readRequest = reader._readRequests.shift();\n  readRequest._resolve(ReadableStreamCreateReadResult(chunk, done, readRequest._forAuthorCode));\n}\n\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n  return stream._reader._readIntoRequests.length;\n}\n\nfunction ReadableStreamGetNumReadRequests(stream) {\n  return stream._reader._readRequests.length;\n}\n\nfunction ReadableStreamHasBYOBReader(stream) {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamBYOBReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamHasDefaultReader(stream) {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nclass ReadableStreamDefaultReader {\n  constructor(stream) {\n    if (IsReadableStream(stream) === false) {\n      throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');\n    }\n    if (IsReadableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readRequests = [];\n  }\n\n  get closed() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  cancel(reason) {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  read() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    return ReadableStreamDefaultReaderRead(this, true);\n  }\n\n  releaseLock() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      throw defaultReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\nclass ReadableStreamBYOBReader {\n  constructor(stream) {\n    if (!IsReadableStream(stream)) {\n      throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' +\n          'byte source');\n    }\n    if (IsReadableByteStreamController(stream._readableStreamController) === false) {\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n          'source');\n    }\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readIntoRequests = [];\n  }\n\n  get closed() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  cancel(reason) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  read(view) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      return Promise.reject(new TypeError('view must be an array buffer view'));\n    }\n\n    if (IsDetachedBuffer(view.buffer) === true) {\n      return Promise.reject(new TypeError('Cannot read into a view onto a detached ArrayBuffer'));\n    }\n\n    if (view.byteLength === 0) {\n      return Promise.reject(new TypeError('view must have non-zero byteLength'));\n    }\n\n    return ReadableStreamBYOBReaderRead(this, view, true);\n  }\n\n  releaseLock() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      throw byobReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readIntoRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\n// Abstract operations for the readers.\n\nfunction IsReadableStreamBYOBReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDefaultReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === 'closed') {\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n    assert(stream._state === 'errored');\n\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n    reader._closedPromise.catch(() => {});\n  }\n}\n\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\n\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  return ReadableStreamCancel(stream, reason);\n}\n\nfunction ReadableStreamReaderGenericRelease(reader) {\n  assert(reader._ownerReadableStream !== undefined);\n  assert(reader._ownerReadableStream._reader === reader);\n\n  if (reader._ownerReadableStream._state === 'readable') {\n    defaultReaderClosedPromiseReject(\n        reader,\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  } else {\n    defaultReaderClosedPromiseResetToRejected(\n        reader,\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  }\n  reader._closedPromise.catch(() => {});\n\n  reader._ownerReadableStream._reader = undefined;\n  reader._ownerReadableStream = undefined;\n}\n\nfunction ReadableStreamBYOBReaderRead(reader, view, forAuthorCode = false) {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  // Controllers must implement this.\n  return ReadableByteStreamControllerPullInto(stream._readableStreamController, view, forAuthorCode);\n}\n\nfunction ReadableStreamDefaultReaderRead(reader, forAuthorCode = false) {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(ReadableStreamCreateReadResult(undefined, true, forAuthorCode));\n  }\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(stream._state === 'readable');\n\n  return stream._readableStreamController[PullSteps](forAuthorCode);\n}\n\n// Controllers\n\nclass ReadableStreamDefaultController {\n  constructor() {\n    throw new TypeError();\n  }\n\n  get desiredSize() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('close');\n    }\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError('The stream is not in a state that permits close');\n    }\n\n    ReadableStreamDefaultControllerClose(this);\n  }\n\n  enqueue(chunk) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError('The stream is not in a state that permits enqueue');\n    }\n\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  error(e) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    ReadableStreamDefaultControllerError(this, e);\n  }\n\n  [CancelSteps](reason) {\n    ResetQueue(this);\n    const result = this._cancelAlgorithm(reason);\n    ReadableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  [PullSteps](forAuthorCode) {\n    const stream = this._controlledReadableStream;\n\n    if (this._queue.length > 0) {\n      const chunk = DequeueValue(this);\n\n      if (this._closeRequested === true && this._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        ReadableStreamClose(stream);\n      } else {\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n      }\n\n      return Promise.resolve(ReadableStreamCreateReadResult(chunk, false, forAuthorCode));\n    }\n\n    const pendingPromise = ReadableStreamAddReadRequest(stream, forAuthorCode);\n    ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    return pendingPromise;\n  }\n}\n\n// Abstract operations for the ReadableStreamDefaultController.\n\nfunction IsReadableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  assert(controller._pullAgain === false);\n\n  controller._pulling = true;\n\n  const pullPromise = controller._pullAlgorithm();\n  pullPromise.then(\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        return ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n      return undefined;\n    },\n    e => {\n      ReadableStreamDefaultControllerError(controller, e);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableStream;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller) {\n  controller._pullAlgorithm = undefined;\n  controller._cancelAlgorithm = undefined;\n  controller._strategySizeAlgorithm = undefined;\n}\n\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction ReadableStreamDefaultControllerClose(controller) {\n  const stream = controller._controlledReadableStream;\n\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\n\n  controller._closeRequested = true;\n\n  if (controller._queue.length === 0) {\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n  }\n}\n\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableStream;\n\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    let chunkSize;\n    try {\n      chunkSize = controller._strategySizeAlgorithm(chunk);\n    } catch (chunkSizeE) {\n      ReadableStreamDefaultControllerError(controller, chunkSizeE);\n      throw chunkSizeE;\n    }\n\n    try {\n      EnqueueValueWithSize(controller, chunk, chunkSize);\n    } catch (enqueueE) {\n      ReadableStreamDefaultControllerError(controller, enqueueE);\n      throw enqueueE;\n    }\n  }\n\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerError(controller, e) {\n  const stream = controller._controlledReadableStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ResetQueue(controller);\n\n  ReadableStreamDefaultControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n  const stream = controller._controlledReadableStream;\n  const state = stream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\n// This is used in the implementation of TransformStream.\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\n  if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n  const state = controller._controlledReadableStream._state;\n\n  if (controller._closeRequested === false && state === 'readable') {\n    return true;\n  }\n\n  return false;\n}\n\nfunction SetUpReadableStreamDefaultController(\n  stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n  assert(stream._readableStreamController === undefined);\n\n  controller._controlledReadableStream = stream;\n\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._started = false;\n  controller._closeRequested = false;\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  Promise.resolve(startResult).then(\n    () => {\n      controller._started = true;\n\n      assert(controller._pulling === false);\n      assert(controller._pullAgain === false);\n\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    },\n    r => {\n      ReadableStreamDefaultControllerError(controller, r);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark,\n                                                                  sizeAlgorithm) {\n  assert(underlyingSource !== undefined);\n\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingSource, 'start', [controller]);\n  }\n\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'pull', 0, [controller]);\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'cancel', 1, []);\n\n  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\n                                       highWaterMark, sizeAlgorithm);\n}\n\nclass ReadableStreamBYOBRequest {\n  constructor() {\n    throw new TypeError('ReadableStreamBYOBRequest cannot be used directly');\n  }\n\n  get view() {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('view');\n    }\n\n    return this._view;\n  }\n\n  respond(bytesWritten) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(this._view.buffer) === true) {\n      throw new TypeError('The BYOB request\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  }\n\n  respondWithNewView(view) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      throw new TypeError('You can only respond with array buffer views');\n    }\n\n    if (IsDetachedBuffer(view.buffer) === true) {\n      throw new TypeError('The supplied view\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  }\n}\n\nclass ReadableByteStreamController {\n  constructor() {\n    throw new TypeError('ReadableByteStreamController constructor cannot be used directly');\n  }\n\n  get byobRequest() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('byobRequest');\n    }\n\n    if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos[0];\n      const view = new Uint8Array(firstDescriptor.buffer,\n                                  firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\n                                  firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n\n      const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n      SetUpReadableStreamBYOBRequest(byobRequest, this, view);\n      this._byobRequest = byobRequest;\n    }\n\n    return this._byobRequest;\n  }\n\n  get desiredSize() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableByteStreamControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('close');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n    }\n\n    ReadableByteStreamControllerClose(this);\n  }\n\n  enqueue(chunk) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('enqueue');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n    }\n\n    if (!ArrayBuffer.isView(chunk)) {\n      throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');\n    }\n\n    if (IsDetachedBuffer(chunk.buffer) === true) {\n      throw new TypeError('Cannot enqueue a view onto a detached ArrayBuffer');\n    }\n\n    ReadableByteStreamControllerEnqueue(this, chunk);\n  }\n\n  error(e) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('error');\n    }\n\n    ReadableByteStreamControllerError(this, e);\n  }\n\n  [CancelSteps](reason) {\n    if (this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos[0];\n      firstDescriptor.bytesFilled = 0;\n    }\n\n    ResetQueue(this);\n\n    const result = this._cancelAlgorithm(reason);\n    ReadableByteStreamControllerClearAlgorithms(this);\n    return result;\n  }\n\n  [PullSteps](forAuthorCode) {\n    const stream = this._controlledReadableByteStream;\n    assert(ReadableStreamHasDefaultReader(stream) === true);\n\n    if (this._queueTotalSize > 0) {\n      assert(ReadableStreamGetNumReadRequests(stream) === 0);\n\n      const entry = this._queue.shift();\n      this._queueTotalSize -= entry.byteLength;\n\n      ReadableByteStreamControllerHandleQueueDrain(this);\n\n      let view;\n      try {\n        view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n      } catch (viewE) {\n        return Promise.reject(viewE);\n      }\n\n      return Promise.resolve(ReadableStreamCreateReadResult(view, false, forAuthorCode));\n    }\n\n    const autoAllocateChunkSize = this._autoAllocateChunkSize;\n    if (autoAllocateChunkSize !== undefined) {\n      let buffer;\n      try {\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\n      } catch (bufferE) {\n        return Promise.reject(bufferE);\n      }\n\n      const pullIntoDescriptor = {\n        buffer,\n        byteOffset: 0,\n        byteLength: autoAllocateChunkSize,\n        bytesFilled: 0,\n        elementSize: 1,\n        ctor: Uint8Array,\n        readerType: 'default'\n      };\n\n      this._pendingPullIntos.push(pullIntoDescriptor);\n    }\n\n    const promise = ReadableStreamAddReadRequest(stream, forAuthorCode);\n\n    ReadableByteStreamControllerCallPullIfNeeded(this);\n\n    return promise;\n  }\n}\n\n// Abstract operations for the ReadableByteStreamController.\n\nfunction IsReadableByteStreamController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamBYOBRequest(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  assert(controller._pullAgain === false);\n\n  controller._pulling = true;\n\n  // TODO: Test controller argument\n  const pullPromise = controller._pullAlgorithm();\n  pullPromise.then(\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n    },\n    e => {\n      ReadableByteStreamControllerError(controller, e);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n\n  return undefined;\n}\n\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = [];\n}\n\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n  assert(stream._state !== 'errored');\n\n  let done = false;\n  if (stream._state === 'closed') {\n    assert(pullIntoDescriptor.bytesFilled === 0);\n    done = true;\n  }\n\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n  if (pullIntoDescriptor.readerType === 'default') {\n    ReadableStreamFulfillReadRequest(stream, filledView, done);\n  } else {\n    assert(pullIntoDescriptor.readerType === 'byob');\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\n\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\n  assert(bytesFilled % elementSize === 0);\n\n  return new pullIntoDescriptor.ctor(\n      pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n}\n\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n  controller._queue.push({ buffer, byteOffset, byteLength });\n  controller._queueTotalSize += byteLength;\n}\n\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n\n  const maxBytesToCopy = Math.min(controller._queueTotalSize,\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n  const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  if (maxAlignedBytes > currentAlignedBytes) {\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n    ready = true;\n  }\n\n  const queue = controller._queue;\n\n  while (totalBytesToCopyRemaining > 0) {\n    const headOfQueue = queue[0];\n\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n\n    if (headOfQueue.byteLength === bytesToCopy) {\n      queue.shift();\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller._queueTotalSize -= bytesToCopy;\n\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  if (ready === false) {\n    assert(controller._queueTotalSize === 0);\n    assert(pullIntoDescriptor.bytesFilled > 0);\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);\n  }\n\n  return ready;\n}\n\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos[0] === pullIntoDescriptor);\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  pullIntoDescriptor.bytesFilled += size;\n}\n\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n  assert(controller._controlledReadableByteStream._state === 'readable');\n\n  if (controller._queueTotalSize === 0 && controller._closeRequested === true) {\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(controller._controlledReadableByteStream);\n  } else {\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n}\n\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n  if (controller._byobRequest === undefined) {\n    return;\n  }\n\n  controller._byobRequest._associatedReadableByteStreamController = undefined;\n  controller._byobRequest._view = undefined;\n  controller._byobRequest = undefined;\n}\n\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n  assert(controller._closeRequested === false);\n\n  while (controller._pendingPullIntos.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n\n    const pullIntoDescriptor = controller._pendingPullIntos[0];\n\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\n        controller._controlledReadableByteStream,\n        pullIntoDescriptor\n      );\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerPullInto(controller, view, forAuthorCode) {\n  const stream = controller._controlledReadableByteStream;\n\n  let elementSize = 1;\n  if (view.constructor !== DataView) {\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\n  }\n\n  const ctor = view.constructor;\n\n  const buffer = TransferArrayBuffer(view.buffer);\n  const pullIntoDescriptor = {\n    buffer,\n    byteOffset: view.byteOffset,\n    byteLength: view.byteLength,\n    bytesFilled: 0,\n    elementSize,\n    ctor,\n    readerType: 'byob'\n  };\n\n  if (controller._pendingPullIntos.length > 0) {\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n    // - No change happens on desiredSize\n    // - The source has already been notified of that there's at least 1 pending read(view)\n\n    return ReadableStreamAddReadIntoRequest(stream, forAuthorCode);\n  }\n\n  if (stream._state === 'closed') {\n    const emptyView = new view.constructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n    return Promise.resolve(ReadableStreamCreateReadResult(emptyView, true, forAuthorCode));\n  }\n\n  if (controller._queueTotalSize > 0) {\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n\n      ReadableByteStreamControllerHandleQueueDrain(controller);\n\n      return Promise.resolve(ReadableStreamCreateReadResult(filledView, false, forAuthorCode));\n    }\n\n    if (controller._closeRequested === true) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      return Promise.reject(e);\n    }\n  }\n\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n\n  const promise = ReadableStreamAddReadIntoRequest(stream, forAuthorCode);\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n\n  return promise;\n}\n\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n\n  assert(firstDescriptor.bytesFilled === 0);\n\n  const stream = controller._controlledReadableByteStream;\n  if (ReadableStreamHasBYOBReader(stream) === true) {\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n      const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\n    throw new RangeError('bytesWritten out of range');\n  }\n\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n    // TODO: Figure out whether we should detach the buffer or not here.\n    return;\n  }\n\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n  if (remainderSize > 0) {\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n  }\n\n  pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n  const firstDescriptor = controller._pendingPullIntos[0];\n\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state === 'closed') {\n    if (bytesWritten !== 0) {\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n    }\n\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n    assert(stream._state === 'readable');\n\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n  const descriptor = controller._pendingPullIntos.shift();\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  return descriptor;\n}\n\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return false;\n  }\n\n  if (controller._closeRequested === true) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableByteStreamControllerClearAlgorithms(controller) {\n  controller._pullAlgorithm = undefined;\n  controller._cancelAlgorithm = undefined;\n}\n\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\n\nfunction ReadableByteStreamControllerClose(controller) {\n  const stream = controller._controlledReadableByteStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  if (controller._queueTotalSize > 0) {\n    controller._closeRequested = true;\n\n    return;\n  }\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos[0];\n    if (firstPendingPullInto.bytesFilled > 0) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      throw e;\n    }\n  }\n\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamClose(stream);\n}\n\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableByteStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  const buffer = chunk.buffer;\n  const byteOffset = chunk.byteOffset;\n  const byteLength = chunk.byteLength;\n  const transferredBuffer = TransferArrayBuffer(buffer);\n\n  if (ReadableStreamHasDefaultReader(stream) === true) {\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    } else {\n      assert(controller._queue.length === 0);\n\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n      ReadableStreamFulfillReadRequest(stream, transferredView, false);\n    }\n  } else if (ReadableStreamHasBYOBReader(stream) === true) {\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n    assert(IsReadableStreamLocked(stream) === false);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerError(controller, e) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  ResetQueue(controller);\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n  const stream = controller._controlledReadableByteStream;\n  const state = stream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n  bytesWritten = Number(bytesWritten);\n  if (IsFiniteNonNegativeNumber(bytesWritten) === false) {\n    throw new RangeError('bytesWritten must be a finite');\n  }\n\n  assert(controller._pendingPullIntos.length > 0);\n\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\n\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n  assert(controller._pendingPullIntos.length > 0);\n\n  const firstDescriptor = controller._pendingPullIntos[0];\n\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n    throw new RangeError('The region specified by view does not match byobRequest');\n  }\n  if (firstDescriptor.byteLength !== view.byteLength) {\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n\n  firstDescriptor.buffer = view.buffer;\n\n  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n}\n\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\n                                           highWaterMark, autoAllocateChunkSize) {\n  assert(stream._readableStreamController === undefined);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  controller._controlledReadableByteStream = stream;\n\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._closeRequested = false;\n  controller._started = false;\n\n  controller._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\n\n  controller._pendingPullIntos = [];\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  Promise.resolve(startResult).then(\n      () => {\n        controller._started = true;\n\n        assert(controller._pulling === false);\n        assert(controller._pullAgain === false);\n\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      },\n      r => {\n        ReadableByteStreamControllerError(controller, r);\n      }\n  )\n      .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n  assert(underlyingByteSource !== undefined);\n\n  const controller = Object.create(ReadableByteStreamController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingByteSource, 'start', [controller]);\n  }\n\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'pull', 0, [controller]);\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'cancel', 1, []);\n\n  let autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n  if (autoAllocateChunkSize !== undefined) {\n    autoAllocateChunkSize = Number(autoAllocateChunkSize);\n    if (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {\n      throw new RangeError('autoAllocateChunkSize must be a positive integer');\n    }\n  }\n\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\n                                    autoAllocateChunkSize);\n}\n\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\n  assert(IsReadableByteStreamController(controller) === true);\n  assert(typeof view === 'object');\n  assert(ArrayBuffer.isView(view) === true);\n  assert(IsDetachedBuffer(view.buffer) === false);\n  request._associatedReadableByteStreamController = controller;\n  request._view = view;\n}\n\n// Helper functions for the ReadableStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n\n// Helper functions for the readers.\n\nfunction readerLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction defaultReaderBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n\nfunction defaultReaderClosedPromiseInitialize(reader) {\n  reader._closedPromise = new Promise((resolve, reject) => {\n    reader._closedPromise_resolve = resolve;\n    reader._closedPromise_reject = reject;\n  });\n}\n\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n  reader._closedPromise = Promise.reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\n  reader._closedPromise = Promise.resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseReject(reader, reason) {\n  assert(reader._closedPromise_resolve !== undefined);\n  assert(reader._closedPromise_reject !== undefined);\n\n  reader._closedPromise_reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\n  assert(reader._closedPromise_resolve === undefined);\n  assert(reader._closedPromise_reject === undefined);\n\n  reader._closedPromise = Promise.reject(reason);\n}\n\nfunction defaultReaderClosedPromiseResolve(reader) {\n  assert(reader._closedPromise_resolve !== undefined);\n  assert(reader._closedPromise_reject !== undefined);\n\n  reader._closedPromise_resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction byobReaderBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n\n// Helper functions for the ReadableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n\n// Helper functions for the ReadableStreamBYOBRequest.\n\nfunction byobRequestBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n\n// Helper functions for the ReadableByteStreamController.\n\nfunction byteStreamControllerBrandCheckException(name) {\n  return new TypeError(\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n\n// Helper function for ReadableStream pipeThrough\n\nfunction ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise) {\n  try {\n    // This relies on the brand-check that is enforced by Promise.prototype.then(). As with the rest of the reference\n    // implementation, it doesn't attempt to do the right thing if someone has modified the global environment.\n    Promise.prototype.then.call(promise, undefined, () => {});\n  } catch (e) {\n    // The brand check failed, therefore the internal slot is not present and there's nothing further to do.\n  }\n}\n","'use strict';\nconst { createDataProperty } = require('./helpers.js');\n\nmodule.exports = class ByteLengthQueuingStrategy {\n  constructor({ highWaterMark }) {\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  size(chunk) {\n    return chunk.byteLength;\n  }\n};\n","'use strict';\nconst { createDataProperty } = require('./helpers.js');\n\nmodule.exports = class CountQueuingStrategy {\n  constructor({ highWaterMark }) {\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  size() {\n    return 1;\n  }\n};\n","'use strict';\nconst assert = require('better-assert');\n\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\n// and do not appear in the standard text.\nconst verbose = require('debug')('streams:transform-stream:verbose');\nconst { InvokeOrNoop, CreateAlgorithmFromUnderlyingMethod, PromiseCall, typeIsObject,\n        ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction } = require('./helpers.js');\nconst { CreateReadableStream, ReadableStreamDefaultControllerClose, ReadableStreamDefaultControllerEnqueue,\n        ReadableStreamDefaultControllerError, ReadableStreamDefaultControllerGetDesiredSize,\n        ReadableStreamDefaultControllerHasBackpressure,\n        ReadableStreamDefaultControllerCanCloseOrEnqueue } = require('./readable-stream.js');\nconst { CreateWritableStream, WritableStreamDefaultControllerErrorIfNeeded } = require('./writable-stream.js');\n\n// Class TransformStream\n\nclass TransformStream {\n  constructor(transformer = {}, writableStrategy = {}, readableStrategy = {}) {\n    const writableSizeFunction = writableStrategy.size;\n    let writableHighWaterMark = writableStrategy.highWaterMark;\n    const readableSizeFunction = readableStrategy.size;\n    let readableHighWaterMark = readableStrategy.highWaterMark;\n\n    const writableType = transformer.writableType;\n\n    if (writableType !== undefined) {\n      throw new RangeError('Invalid writable type specified');\n    }\n\n    const writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(writableSizeFunction);\n    if (writableHighWaterMark === undefined) {\n      writableHighWaterMark = 1;\n    }\n    writableHighWaterMark = ValidateAndNormalizeHighWaterMark(writableHighWaterMark);\n\n    const readableType = transformer.readableType;\n\n    if (readableType !== undefined) {\n      throw new RangeError('Invalid readable type specified');\n    }\n\n    const readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(readableSizeFunction);\n    if (readableHighWaterMark === undefined) {\n      readableHighWaterMark = 0;\n    }\n    readableHighWaterMark = ValidateAndNormalizeHighWaterMark(readableHighWaterMark);\n\n    let startPromise_resolve;\n    const startPromise = new Promise(resolve => {\n      startPromise_resolve = resolve;\n    });\n\n    InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                              readableSizeAlgorithm);\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n\n    const startResult = InvokeOrNoop(transformer, 'start', [this._transformStreamController]);\n    startPromise_resolve(startResult);\n  }\n\n  get readable() {\n    if (IsTransformStream(this) === false) {\n      throw streamBrandCheckException('readable');\n    }\n\n    return this._readable;\n  }\n\n  get writable() {\n    if (IsTransformStream(this) === false) {\n      throw streamBrandCheckException('writable');\n    }\n\n    return this._writable;\n  }\n}\n\n// Transform Stream Abstract Operations\n\nfunction CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm, writableHighWaterMark = 1,\n                               writableSizeAlgorithm = () => 1, readableHighWaterMark = 0,\n                               readableSizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(writableHighWaterMark));\n  assert(IsNonNegativeNumber(readableHighWaterMark));\n\n  const stream = Object.create(TransformStream.prototype);\n\n  let startPromise_resolve;\n  const startPromise = new Promise(resolve => {\n    startPromise_resolve = resolve;\n  });\n\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                            readableSizeAlgorithm);\n\n  const controller = Object.create(TransformStreamDefaultController.prototype);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n\n  const startResult = startAlgorithm();\n  startPromise_resolve(startResult);\n  return stream;\n}\n\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm,\n                                   readableHighWaterMark, readableSizeAlgorithm) {\n  function startAlgorithm() {\n    return startPromise;\n  }\n\n  function writeAlgorithm(chunk) {\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  }\n\n  function abortAlgorithm(reason) {\n    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n  }\n\n  function closeAlgorithm() {\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  }\n\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm,\n                                          writableHighWaterMark, writableSizeAlgorithm);\n\n  function pullAlgorithm() {\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\n  }\n\n  function cancelAlgorithm(reason) {\n    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n    return Promise.resolve();\n  }\n\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark,\n                                          readableSizeAlgorithm);\n\n  // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n  stream._backpressure = undefined;\n  stream._backpressureChangePromise = undefined;\n  stream._backpressureChangePromise_resolve = undefined;\n  TransformStreamSetBackpressure(stream, true);\n\n  // Used by IsWritableStream() which is called by SetUpTransformStreamDefaultController().\n  stream._transformStreamController = undefined;\n}\n\nfunction IsTransformStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream, e) {\n  verbose('TransformStreamError()');\n\n  ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\n\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n  if (stream._backpressure === true) {\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n    // _backpressure is set.\n    TransformStreamSetBackpressure(stream, false);\n  }\n}\n\nfunction TransformStreamSetBackpressure(stream, backpressure) {\n  verbose(`TransformStreamSetBackpressure() [backpressure = ${backpressure}]`);\n\n  // Passes also when called during construction.\n  assert(stream._backpressure !== backpressure);\n\n  if (stream._backpressureChangePromise !== undefined) {\n    stream._backpressureChangePromise_resolve();\n  }\n\n  stream._backpressureChangePromise = new Promise(resolve => {\n    stream._backpressureChangePromise_resolve = resolve;\n  });\n\n  stream._backpressure = backpressure;\n}\n\n// Class TransformStreamDefaultController\n\nclass TransformStreamDefaultController {\n  constructor() {\n    throw new TypeError('TransformStreamDefaultController instances cannot be created directly');\n  }\n\n  get desiredSize() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    const readableController = this._controlledTransformStream._readable._readableStreamController;\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n  }\n\n  enqueue(chunk) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    TransformStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  error(reason) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    TransformStreamDefaultControllerError(this, reason);\n  }\n\n  terminate() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('terminate');\n    }\n\n    TransformStreamDefaultControllerTerminate(this);\n  }\n}\n\n// Transform Stream Default Controller Abstract Operations\n\nfunction IsTransformStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n  assert(IsTransformStream(stream) === true);\n  assert(stream._transformStreamController === undefined);\n\n  controller._controlledTransformStream = stream;\n  stream._transformStreamController = controller;\n\n  controller._transformAlgorithm = transformAlgorithm;\n  controller._flushAlgorithm = flushAlgorithm;\n}\n\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n  assert(transformer !== undefined);\n\n  const controller = Object.create(TransformStreamDefaultController.prototype);\n\n  let transformAlgorithm = chunk => {\n    try {\n      TransformStreamDefaultControllerEnqueue(controller, chunk);\n      return Promise.resolve();\n    } catch (transformResultE) {\n      return Promise.reject(transformResultE);\n    }\n  };\n  const transformMethod = transformer.transform;\n  if (transformMethod !== undefined) {\n    if (typeof transformMethod !== 'function') {\n      throw new TypeError('transform is not a method');\n    }\n    transformAlgorithm = chunk => PromiseCall(transformMethod, transformer, [chunk, controller]);\n  }\n\n  const flushAlgorithm = CreateAlgorithmFromUnderlyingMethod(transformer, 'flush', 0, [controller]);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\n\nfunction TransformStreamDefaultControllerClearAlgorithms(controller) {\n  controller._transformAlgorithm = undefined;\n  controller._flushAlgorithm = undefined;\n}\n\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\n  verbose('TransformStreamDefaultControllerEnqueue()');\n\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === false) {\n    throw new TypeError('Readable side is not in a state that permits enqueue');\n  }\n\n  // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n  // accept TransformStreamDefaultControllerEnqueue() calls.\n\n  try {\n    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  } catch (e) {\n    // This happens when readableStrategy.size() throws.\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n\n    throw stream._readable._storedError;\n  }\n\n  const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n  if (backpressure !== stream._backpressure) {\n    assert(backpressure === true);\n    TransformStreamSetBackpressure(stream, true);\n  }\n}\n\nfunction TransformStreamDefaultControllerError(controller, e) {\n  TransformStreamError(controller._controlledTransformStream, e);\n}\n\nfunction TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n  const transformPromise = controller._transformAlgorithm(chunk);\n  return transformPromise.catch(r => {\n    TransformStreamError(controller._controlledTransformStream, r);\n    throw r;\n  });\n}\n\nfunction TransformStreamDefaultControllerTerminate(controller) {\n  verbose('TransformStreamDefaultControllerTerminate()');\n\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n    ReadableStreamDefaultControllerClose(readableController);\n  }\n\n  const error = new TypeError('TransformStream terminated');\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n\n// TransformStreamDefaultSink Algorithms\n\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n  verbose('TransformStreamDefaultSinkWriteAlgorithm()');\n\n  assert(stream._writable._state === 'writable');\n\n  const controller = stream._transformStreamController;\n\n  if (stream._backpressure === true) {\n    const backpressureChangePromise = stream._backpressureChangePromise;\n    assert(backpressureChangePromise !== undefined);\n    return backpressureChangePromise\n        .then(() => {\n          const writable = stream._writable;\n          const state = writable._state;\n          if (state === 'erroring') {\n            throw writable._storedError;\n          }\n          assert(state === 'writable');\n          return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n        });\n  }\n\n  return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n}\n\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n  // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n  // errored.\n  TransformStreamError(stream, reason);\n  return Promise.resolve();\n}\n\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\n  verbose('TransformStreamDefaultSinkCloseAlgorithm()');\n\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  const readable = stream._readable;\n\n  const controller = stream._transformStreamController;\n  const flushPromise = controller._flushAlgorithm();\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n\n  // Return a promise that is fulfilled with undefined on success.\n  return flushPromise.then(() => {\n    if (readable._state === 'errored') {\n      throw readable._storedError;\n    }\n    const readableController = readable._readableStreamController;\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n      ReadableStreamDefaultControllerClose(readableController);\n    }\n  }).catch(r => {\n    TransformStreamError(stream, r);\n    throw readable._storedError;\n  });\n}\n\n// TransformStreamDefaultSource Algorithms\n\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\n  verbose('TransformStreamDefaultSourcePullAlgorithm()');\n\n  // Invariant. Enforced by the promises returned by start() and pull().\n  assert(stream._backpressure === true);\n\n  assert(stream._backpressureChangePromise !== undefined);\n\n  TransformStreamSetBackpressure(stream, false);\n\n  // Prevent the next pull() call until there is backpressure.\n  return stream._backpressureChangePromise;\n}\n\nmodule.exports = { CreateTransformStream, TransformStream };\n\n// Helper functions for the TransformStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name) {\n  return new TypeError(\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n\n// Helper functions for the TransformStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(\n    `TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n"],"names":["NumberIsInteger","Number","isInteger","value","isFinite","Math","floor","SymbolPolyfill","Symbol","iterator","description","noop","NumberIsNaN","isNaN","x","isFakeDetached","exports","o","p","v","Object","defineProperty","writable","enumerable","configurable","elements","slice","dest","destOffset","src","srcOffset","n","Uint8Array","set","IsNonNegativeNumber","Infinity","Number.isNaN","Call","F","V","args","TypeError","Function","prototype","apply","call","underlyingObject","methodName","algoArgCount","extraArgs","method","undefined","PromiseCall","fullArgs","arg","concat","Promise","resolve","O","P","reject","transferredIshVersion","get","highWaterMark","RangeError","size","chunk","assert","AssertionError","e","setTimeout","IsFiniteNonNegativeNumber","require$$0","pair","container","_queue","shift","_queueTotalSize","push","verbose","CreateAlgorithmFromUnderlyingMethod","require$$1","InvokeOrNoop","ValidateAndNormalizeHighWaterMark","MakeSizeAlgorithmFromSizeFunction","typeIsObject","rethrowAssertionErrorRejection","require$$2","DequeueValue","require$$3","EnqueueValueWithSize","PeekQueueValue","ResetQueue","AbortSteps","ErrorSteps","WritableStream","underlyingSink","strategy","InitializeWritableStream","type","sizeAlgorithm","SetUpWritableStreamDefaultControllerFromUnderlyingSink","abort","reason","IsWritableStream","streamBrandCheckException","IsWritableStreamLocked","WritableStreamAbort","getWriter","AcquireWritableStreamDefaultWriter","CreateWritableStream","WritableStreamDefaultControllerErrorIfNeeded","WritableStreamDefaultWriterCloseWithErrorPropagation","WritableStreamDefaultWriterRelease","WritableStreamDefaultWriterWrite","WritableStreamCloseQueuedOrInFlight","stream","WritableStreamDefaultWriter","startAlgorithm","writeAlgorithm","closeAlgorithm","abortAlgorithm","create","controller","WritableStreamDefaultController","SetUpWritableStreamDefaultController","_state","_storedError","_writer","_writableStreamController","_writeRequests","_inFlightWriteRequest","_closeRequest","_inFlightCloseRequest","_pendingAbortRequest","_backpressure","hasOwnProperty","state","_promise","wasAlreadyErroring","promise","_resolve","_reject","_reason","_wasAlreadyErroring","WritableStreamStartErroring","WritableStreamAddWriteRequest","writeRequest","WritableStreamDealWithRejection","error","WritableStreamFinishErroring","writer","WritableStreamDefaultWriterEnsureReadyPromiseRejected","WritableStreamHasOperationMarkedInFlight","_started","storedError","WritableStreamRejectCloseAndClosedPromiseIfNeeded","abortRequest","then","WritableStreamFinishInFlightWrite","WritableStreamFinishInFlightWriteWithError","WritableStreamFinishInFlightClose","defaultWriterClosedPromiseResolve","WritableStreamFinishInFlightCloseWithError","WritableStreamMarkCloseRequestInFlight","WritableStreamMarkFirstWriteRequestInFlight","defaultWriterClosedPromiseReject","_closedPromise","catch","WritableStreamUpdateBackpressure","backpressure","defaultWriterReadyPromiseReset","defaultWriterReadyPromiseResolve","_ownerWritableStream","defaultWriterReadyPromiseInitialize","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterClosedPromiseInitialize","defaultWriterReadyPromiseInitializeAsRejected","_readyPromise","defaultWriterClosedPromiseInitializeAsResolved","defaultWriterClosedPromiseInitializeAsRejected","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","defaultWriterLockException","WritableStreamDefaultWriterAbort","close","WritableStreamDefaultWriterClose","releaseLock","write","WritableStreamDefaultWriterGetDesiredSize","closeRequest","WritableStreamDefaultControllerClose","WritableStreamDefaultWriterEnsureClosedPromiseRejected","_closedPromiseState","defaultWriterClosedPromiseResetToRejected","_readyPromiseState","defaultWriterReadyPromiseReject","defaultWriterReadyPromiseResetToRejected","WritableStreamDefaultControllerGetDesiredSize","releasedError","chunkSize","WritableStreamDefaultControllerGetChunkSize","WritableStreamDefaultControllerWrite","IsWritableStreamDefaultController","_controlledWritableStream","WritableStreamDefaultControllerError","result","_abortAlgorithm","WritableStreamDefaultControllerClearAlgorithms","_strategySizeAlgorithm","_strategyHWM","_writeAlgorithm","_closeAlgorithm","WritableStreamDefaultControllerGetBackpressure","startResult","startPromise","WritableStreamDefaultControllerAdvanceQueueIfNeeded","r","chunkSizeE","writeRecord","enqueueE","length","WritableStreamDefaultControllerProcessClose","WritableStreamDefaultControllerProcessWrite","sinkClosePromise","sinkWritePromise","desiredSize","name","_closedPromise_resolve","_closedPromise_reject","_readyPromise_resolve","_readyPromise_reject","ArrayBufferCopy","IsDetachedBuffer","TransferArrayBuffer","createArrayFromList","CancelSteps","PullSteps","ReadableStream","underlyingSource","InitializeReadableStream","typeString","String","SetUpReadableByteStreamControllerFromUnderlyingSource","SetUpReadableStreamDefaultControllerFromUnderlyingSource","cancel","IsReadableStream","IsReadableStreamLocked","ReadableStreamCancel","getReader","mode","AcquireReadableStreamDefaultReader","AcquireReadableStreamBYOBReader","pipeThrough","options","readable","pipeTo","ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue","preventClose","preventAbort","preventCancel","Boolean","reader","shuttingDown","currentWrite","pipeLoop","ReadableStreamDefaultReaderRead","done","isOrBecomesErrored","shutdownWithAction","shutdown","isOrBecomesClosed","destClosed","err","waitForWritesToFinish","oldCurrentWrite","action","originalIsError","originalError","doTheRest","finalize","newError","isError","ReadableStreamReaderGenericRelease","tee","branches","ReadableStreamTee","CreateReadableByteStream","CreateReadableStream","IsReadableStreamDisturbed","ReadableStreamDefaultControllerClose","ReadableStreamDefaultControllerEnqueue","ReadableStreamDefaultControllerError","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerHasBackpressure","ReadableStreamDefaultControllerCanCloseOrEnqueue","ReadableStreamBYOBReader","ReadableStreamDefaultReader","pullAlgorithm","cancelAlgorithm","ReadableStreamDefaultController","SetUpReadableStreamDefaultController","autoAllocateChunkSize","ReadableByteStreamController","SetUpReadableByteStreamController","_reader","_disturbed","cloneForBranch2","closedOrErrored","canceled1","canceled2","reason1","reason2","branch1","branch2","resolveCancelPromise","cancelPromise","_readableStreamController","value1","value2","cancel1Algorithm","compositeReason","cancelResult","cancel2Algorithm","ReadableStreamAddReadIntoRequest","forAuthorCode","readIntoRequest","_forAuthorCode","_readIntoRequests","ReadableStreamAddReadRequest","readRequest","_readRequests","ReadableStreamClose","sourceCancelPromise","IsReadableStreamDefaultReader","ReadableStreamCreateReadResult","defaultReaderClosedPromiseResolve","obj","ReadableStreamError","defaultReaderClosedPromiseReject","ReadableStreamFulfillReadIntoRequest","ReadableStreamFulfillReadRequest","ReadableStreamGetNumReadIntoRequests","ReadableStreamGetNumReadRequests","ReadableStreamHasBYOBReader","IsReadableStreamBYOBReader","ReadableStreamHasDefaultReader","ReadableStreamReaderGenericInitialize","defaultReaderBrandCheckException","_ownerReadableStream","readerLockException","ReadableStreamReaderGenericCancel","read","IsReadableByteStreamController","byobReaderBrandCheckException","view","ArrayBuffer","isView","buffer","byteLength","ReadableStreamBYOBReaderRead","defaultReaderClosedPromiseInitialize","defaultReaderClosedPromiseInitializeAsResolved","defaultReaderClosedPromiseInitializeAsRejected","defaultReaderClosedPromiseResetToRejected","ReadableByteStreamControllerPullInto","IsReadableStreamDefaultController","defaultControllerBrandCheckException","enqueue","_cancelAlgorithm","ReadableStreamDefaultControllerClearAlgorithms","_controlledReadableStream","_closeRequested","ReadableStreamDefaultControllerCallPullIfNeeded","pendingPromise","shouldPull","ReadableStreamDefaultControllerShouldCallPull","_pulling","_pullAgain","pullPromise","_pullAlgorithm","ReadableStreamBYOBRequest","respond","bytesWritten","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","_associatedReadableByteStreamController","_view","ReadableByteStreamControllerRespond","respondWithNewView","ReadableByteStreamControllerRespondWithNewView","byteStreamControllerBrandCheckException","_controlledReadableByteStream","ReadableByteStreamControllerClose","ReadableByteStreamControllerEnqueue","ReadableByteStreamControllerError","_pendingPullIntos","firstDescriptor","bytesFilled","ReadableByteStreamControllerClearAlgorithms","entry","ReadableByteStreamControllerHandleQueueDrain","byteOffset","viewE","_autoAllocateChunkSize","bufferE","pullIntoDescriptor","elementSize","ctor","readerType","ReadableByteStreamControllerCallPullIfNeeded","_byobRequest","byobRequest","SetUpReadableStreamBYOBRequest","ReadableByteStreamControllerGetDesiredSize","ReadableByteStreamControllerShouldCallPull","ReadableByteStreamControllerClearPendingPullIntos","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerCommitPullIntoDescriptor","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","ReadableByteStreamControllerEnqueueChunkToQueue","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","currentAlignedBytes","maxBytesToCopy","min","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","ready","queue","headOfQueue","bytesToCopy","destStart","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","ReadableByteStreamControllerShiftPendingPullInto","constructor","DataView","BYTES_PER_ELEMENT","emptyView","ReadableByteStreamControllerRespondInClosedState","ReadableByteStreamControllerRespondInReadableState","remainderSize","end","remainder","ReadableByteStreamControllerRespondInternal","descriptor","firstPendingPullInto","transferredBuffer","transferredView","underlyingByteSource","Number.isInteger","request","createDataProperty","TransformStream","transformer","writableStrategy","readableStrategy","writableSizeFunction","writableHighWaterMark","readableSizeFunction","readableHighWaterMark","writableType","writableSizeAlgorithm","readableType","readableSizeAlgorithm","startPromise_resolve","InitializeTransformStream","SetUpTransformStreamDefaultControllerFromTransformer","_transformStreamController","IsTransformStream","_readable","_writable","CreateTransformStream","transformAlgorithm","flushAlgorithm","TransformStreamDefaultController","SetUpTransformStreamDefaultController","TransformStreamDefaultSinkWriteAlgorithm","TransformStreamDefaultSinkAbortAlgorithm","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamDefaultSourcePullAlgorithm","TransformStreamErrorWritableAndUnblockWrite","_backpressureChangePromise","_backpressureChangePromise_resolve","TransformStreamSetBackpressure","TransformStreamError","TransformStreamDefaultControllerClearAlgorithms","IsTransformStreamDefaultController","TransformStreamDefaultControllerEnqueue","TransformStreamDefaultControllerError","terminate","TransformStreamDefaultControllerTerminate","readableController","_controlledTransformStream","_transformAlgorithm","_flushAlgorithm","transformResultE","transformMethod","transform","TransformStreamDefaultControllerPerformTransform","transformPromise","backpressureChangePromise","flushPromise"],"mappings":"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"}